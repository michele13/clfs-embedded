diff -Nru linux-2.6.30.5/Documentation/gpiommc.txt linux-2.6.30.5-wrt/Documentation/gpiommc.txt
--- linux-2.6.30.5/Documentation/gpiommc.txt	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/Documentation/gpiommc.txt	2009-09-06 18:44:06.807166783 +0200
@@ -0,0 +1,97 @@
+GPIOMMC - Driver for an MMC/SD card on a bitbanging GPIO SPI bus
+================================================================
+
+The gpiommc module hooks up the mmc_spi and spi_gpio modules for running an
+MMC or SD card on GPIO pins.
+
+Two interfaces for registering a new MMC/SD card device are provided:
+A static platform-device based mechanism and a dynamic configfs based interface.
+
+
+Registering devices via platform-device
+=======================================
+
+The platform-device interface is used for registering MMC/SD devices that are
+part of the hardware platform. This is most useful only for embedded machines
+with MMC/SD devices statically connected to the platform GPIO bus.
+
+The data structures are declared in <linux/mmc/gpiommc.h>.
+
+To register a new device, define an instance of struct gpiommc_platform_data.
+This structure holds any information about how the device is hooked up to the
+GPIO pins and what hardware modes the device supports. See the docbook-style
+documentation in the header file for more information on the struct fields.
+
+Then allocate a new instance of a platform device by doing:
+
+	pdev = platform_device_alloc(GPIOMMC_PLATDEV_NAME, gpiommc_next_id());
+
+This will allocate the platform device data structures and hook it up to the
+gpiommc driver.
+Then add the gpiommc_platform_data to the platform device.
+
+	err = platform_device_add_data(pdev, pdata, sizeof(struct gpiommc_platform_data));
+
+You may free the local instance of struct gpiommc_platform_data now. (So the
+struct may be allocated on the stack, too).
+Now simply register the platform device.
+
+	err = platform_device_add(pdev);
+
+Done. The gpiommc probe routine will be invoked now and you should see a kernel
+log message for the added device.
+
+
+Registering devices via configfs
+================================
+
+MMC/SD cards connected via GPIO often are a pretty dynamic thing, as for example
+selfmade hacks for soldering an MMC/SD card to standard GPIO pins on embedded
+hardware are a common situation.
+So we provide a dynamic interface to conveniently handle adding and removing
+devices from userspace, without the need to recompile the kernel.
+
+The "gpiommc" subdirectory at the configfs mountpoint is used for handling
+the dynamic configuration.
+
+To create a new device, it must first be allocated with mkdir.
+The following command will allocate a device named "my_mmc":
+	mkdir /config/gpiommc/my_mmc
+
+There are several configuration files available in the new
+/config/gpiommc/my_mmc/ directory:
+
+gpio_data_in			= The SPI data-IN GPIO pin number.
+gpio_data_out			= The SPI data-OUT GPIO pin number.
+gpio_clock			= The SPI Clock GPIO pin number.
+gpio_chipselect			= The SPI Chipselect GPIO pin number.
+gpio_chipselect_activelow	= Boolean. If 0, Chipselect is active-HIGH.
+				  If 1, Chipselect is active-LOW.
+spi_mode			= The SPI data mode. Can be 0-3.
+spi_delay			= Enable all delays in the lowlevel bitbanging.
+max_bus_speed			= The maximum SPI bus speed. In Hertz.
+
+register			= Not a configuration parameter.
+				  Used to register the configured card
+				  with the kernel.
+
+The device must first get configured and then registered by writing "1" to
+the "register" file.
+The configuration parameters "gpio_data_in", "gpio_data_out", "gpio_clock"
+and "gpio_chipselect" are essential and _must_ be configured before writing
+"1" to the "register" file. The registration will fail, otherwise.
+
+The default values for the other parameters are:
+gpio_chipselect_activelow	= 1		(CS active-LOW)
+spi_mode			= 0		(SPI_MODE_0)
+spi_delay			= 1		(enabled)
+max_bus_speed			= 5000000	(5 Mhz)
+
+Configuration values can not be changed after registration. To unregister
+the device, write a "0" to the "register" file. The configuration can be
+changed again after unregistering.
+
+To completely remove the device, simply rmdir the directory
+(/config/gpiommc/my_mmc in this example).
+There's no need to first unregister the device before removing it. That will
+be done automatically.
diff -Nru linux-2.6.30.5/MAINTAINERS linux-2.6.30.5-wrt/MAINTAINERS
--- linux-2.6.30.5/MAINTAINERS	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/MAINTAINERS	2009-09-06 18:44:06.811167583 +0200
@@ -2504,6 +2504,11 @@
 S:	Maintained
 F:	drivers/media/video/gspca/
 
+GPIOMMC DRIVER
+P:	Michael Buesch
+M:	mb@bu3sch.de
+S:	Maintained
+
 HARDWARE MONITORING
 L:	lm-sensors@lm-sensors.org
 W:	http://www.lm-sensors.org/
diff -Nru linux-2.6.30.5/Makefile linux-2.6.30.5-wrt/Makefile
--- linux-2.6.30.5/Makefile	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/Makefile	2009-09-06 18:43:48.334667043 +0200
@@ -567,6 +567,9 @@
 NOSTDINC_FLAGS += -nostdinc -isystem $(shell $(CC) -print-file-name=include)
 CHECKFLAGS     += $(NOSTDINC_FLAGS)
 
+# improve gcc optimization
+CFLAGS += $(call cc-option,-funit-at-a-time,)
+
 # warn about C99 declaration after statement
 KBUILD_CFLAGS += $(call cc-option,-Wdeclaration-after-statement,)
 
@@ -991,7 +994,7 @@
 # Leave this as default for preprocessing vmlinux.lds.S, which is now
 # done in arch/$(ARCH)/kernel/Makefile
 
-export CPPFLAGS_vmlinux.lds += -P -C -U$(ARCH)
+export CPPFLAGS_vmlinux.lds += -P -C -U$(ARCH) $(EXTRA_LDSFLAGS)
 
 # The asm symlink changes when $(ARCH) changes.
 # Detect this and ask user to run make mrproper
diff -Nru linux-2.6.30.5/arch/arm/boot/compressed/Makefile linux-2.6.30.5-wrt/arch/arm/boot/compressed/Makefile
--- linux-2.6.30.5/arch/arm/boot/compressed/Makefile	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/arm/boot/compressed/Makefile	2009-09-06 18:44:06.831166738 +0200
@@ -63,7 +63,7 @@
 
 SEDFLAGS	= s/TEXT_START/$(ZTEXTADDR)/;s/BSS_START/$(ZBSSADDR)/
 
-targets       := vmlinux vmlinux.lds piggy.gz piggy.o font.o font.c \
+targets       := vmlinux vmlinux.lds piggy.lzma piggy.o font.o font.c \
 		 head.o misc.o $(OBJS)
 
 ifeq ($(CONFIG_FUNCTION_TRACER),y)
@@ -96,10 +96,10 @@
 	$(call if_changed,ld)
 	@:
 
-$(obj)/piggy.gz: $(obj)/../Image FORCE
-	$(call if_changed,gzip)
+$(obj)/piggy.lzma: $(obj)/../Image FORCE
+	$(call if_changed,lzma)
 
-$(obj)/piggy.o:  $(obj)/piggy.gz FORCE
+$(obj)/piggy.o:  $(obj)/piggy.lzma FORCE
 
 CFLAGS_font.o := -Dstatic=
 
diff -Nru linux-2.6.30.5/arch/arm/boot/compressed/misc.c linux-2.6.30.5-wrt/arch/arm/boot/compressed/misc.c
--- linux-2.6.30.5/arch/arm/boot/compressed/misc.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/arm/boot/compressed/misc.c	2009-09-06 18:44:06.831166738 +0200
@@ -186,36 +186,10 @@
 	return __dest;
 }
 
-/*
- * gzip delarations
- */
-#define OF(args)  args
-#define STATIC static
-
-typedef unsigned char  uch;
-typedef unsigned short ush;
-typedef unsigned long  ulg;
-
-#define WSIZE 0x8000		/* Window size must be at least 32k, */
+#define WSIZE 0x20000		/* Window size must be at least 128k, */
 				/* and a power of two */
 
-static uch *inbuf;		/* input buffer */
-static uch window[WSIZE];	/* Sliding window buffer */
-
-static unsigned insize;		/* valid bytes in inbuf */
-static unsigned inptr;		/* index of next byte to be processed in inbuf */
-static unsigned outcnt;		/* bytes in output buffer */
-
-/* gzip flag byte */
-#define ASCII_FLAG   0x01 /* bit 0 set: file probably ascii text */
-#define CONTINUATION 0x02 /* bit 1 set: continuation of multi-part gzip file */
-#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */
-#define ORIG_NAME    0x08 /* bit 3 set: original file name present */
-#define COMMENT      0x10 /* bit 4 set: file comment present */
-#define ENCRYPTED    0x20 /* bit 5 set: file is encrypted */
-#define RESERVED     0xC0 /* bit 6,7:   reserved */
-
-#define get_byte()  (inptr < insize ? inbuf[inptr++] : fill_inbuf())
+static u8 window[WSIZE];	/* Sliding window buffer */
 
 /* Diagnostic functions */
 #ifdef DEBUG
@@ -234,24 +208,21 @@
 #  define Tracecv(c,x)
 #endif
 
-static int  fill_inbuf(void);
-static void flush_window(void);
 static void error(char *m);
 
 extern char input_data[];
 extern char input_data_end[];
 
-static uch *output_data;
-static ulg output_ptr;
-static ulg bytes_out;
+static unsigned long output_ptr;
+static unsigned long bytes_out;
 
 static void error(char *m);
 
 static void putstr(const char *);
 
 extern int end;
-static ulg free_mem_ptr;
-static ulg free_mem_end_ptr;
+static unsigned long free_mem_ptr;
+static unsigned long free_mem_end_ptr;
 
 #ifdef STANDALONE_DEBUG
 #define NO_INFLATE_MALLOC
@@ -259,50 +230,10 @@
 
 #define ARCH_HAS_DECOMP_WDOG
 
-#include "../../../../lib/inflate.c"
-
-/* ===========================================================================
- * Fill the input buffer. This is called only when the buffer is empty
- * and at least one byte is really needed.
- */
-int fill_inbuf(void)
-{
-	if (insize != 0)
-		error("ran out of input data");
-
-	inbuf = input_data;
-	insize = &input_data_end[0] - &input_data[0];
-
-	inptr = 1;
-	return inbuf[0];
-}
-
-/* ===========================================================================
- * Write the output window window[0..outcnt-1] and update crc and bytes_out.
- * (Used for the decompressed data only.)
- */
-void flush_window(void)
-{
-	ulg c = crc;
-	unsigned n;
-	uch *in, *out, ch;
-
-	in = window;
-	out = &output_data[output_ptr];
-	for (n = 0; n < outcnt; n++) {
-		ch = *out++ = *in++;
-		c = crc_32_tab[((int)c ^ ch) & 0xff] ^ (c >> 8);
-	}
-	crc = c;
-	bytes_out += (ulg)outcnt;
-	output_ptr += (ulg)outcnt;
-	outcnt = 0;
-	putstr(".");
-}
-
 #ifndef arch_error
 #define arch_error(x)
 #endif
+#include "unlzma.c"
 
 static void error(char *x)
 {
@@ -317,20 +248,16 @@
 
 #ifndef STANDALONE_DEBUG
 
-ulg
-decompress_kernel(ulg output_start, ulg free_mem_ptr_p, ulg free_mem_ptr_end_p,
+unsigned long
+decompress_kernel(unsigned long output_start, unsigned long free_mem_ptr_p, unsigned long free_mem_ptr_end_p,
 		  int arch_id)
 {
-	output_data		= (uch *)output_start;	/* Points to kernel start */
-	free_mem_ptr		= free_mem_ptr_p;
-	free_mem_end_ptr	= free_mem_ptr_end_p;
 	__machine_arch_type	= arch_id;
 
 	arch_decomp_setup();
 
-	makecrc();
 	putstr("Uncompressing Linux...");
-	gunzip();
+	output_ptr += unlzma((u8 *) output_start, input_data, window);
 	putstr(" done, booting the kernel.\n");
 	return output_ptr;
 }
@@ -340,11 +267,8 @@
 
 int main()
 {
-	output_data = output_buffer;
-
-	makecrc();
 	putstr("Uncompressing Linux...");
-	gunzip();
+	unlzma((u8 *) output_buffer, input_data, window);
 	putstr("done.\n");
 	return 0;
 }
diff -Nru linux-2.6.30.5/arch/arm/boot/compressed/piggy.S linux-2.6.30.5-wrt/arch/arm/boot/compressed/piggy.S
--- linux-2.6.30.5/arch/arm/boot/compressed/piggy.S	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/arm/boot/compressed/piggy.S	2009-09-06 18:44:06.831166738 +0200
@@ -1,6 +1,6 @@
 	.section .piggydata,#alloc
 	.globl	input_data
 input_data:
-	.incbin	"arch/arm/boot/compressed/piggy.gz"
+	.incbin	"arch/arm/boot/compressed/piggy.lzma"
 	.globl	input_data_end
 input_data_end:
diff -Nru linux-2.6.30.5/arch/arm/boot/compressed/unlzma.c linux-2.6.30.5-wrt/arch/arm/boot/compressed/unlzma.c
--- linux-2.6.30.5/arch/arm/boot/compressed/unlzma.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/arch/arm/boot/compressed/unlzma.c	2009-09-06 18:44:06.831166738 +0200
@@ -0,0 +1,429 @@
+/*
+ * Copyright (c) 2009  Felix Fietkau <nbd@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * uncompress.c
+ */
+
+#include <linux/types.h>
+#include <asm/byteorder.h>
+#include "unlzma.h"
+
+struct unlzma_ctx {
+	const u8 *next_in;
+	u8 *next_out;
+	u8 *outbuf;
+
+	/* reader state */
+	u32 code;
+	u32 range;
+	u32 bound;
+
+	/* writer state */
+	u8 previous_byte;
+	ssize_t pos;
+
+	/* cstate */
+	int state;
+	u32 rep0, rep1, rep2, rep3;
+
+	void *workspace;
+} ctx;
+
+static int inbs = 0;
+static inline u8
+rc_read(void)
+{
+#if 0
+	if (unlikely(++inbs > 16 * 1024)) {
+		putstr(".");
+		inbs = 0;
+	}
+#endif
+	return *(ctx.next_in++);
+}
+
+
+static inline void
+rc_get_code(void)
+{
+	ctx.code = (ctx.code << 8) | rc_read();
+}
+
+static inline void
+rc_normalize(void)
+{
+	if (ctx.range < (1 << RC_TOP_BITS)) {
+		ctx.range <<= 8;
+		rc_get_code();
+	}
+}
+
+static inline int
+rc_is_bit_0(u16 *p)
+{
+	rc_normalize();
+	ctx.bound = *p * (ctx.range >> RC_MODEL_TOTAL_BITS);
+	return ctx.code < ctx.bound;
+}
+
+static inline void
+rc_update_bit_0(u16 *p)
+{
+	ctx.range = ctx.bound;
+	*p += ((1 << RC_MODEL_TOTAL_BITS) - *p) >> RC_MOVE_BITS;
+}
+
+static inline void
+rc_update_bit_1(u16 *p)
+{
+	ctx.range -= ctx.bound;
+	ctx.code -= ctx.bound;
+	*p -= *p >> RC_MOVE_BITS;
+}
+
+static inline bool
+rc_get_bit(u16 *p, int *symbol)
+{
+	if (rc_is_bit_0(p)) {
+		rc_update_bit_0(p);
+		*symbol *= 2;
+		return 0;
+	} else {
+		rc_update_bit_1(p);
+		*symbol = *symbol * 2 + 1;
+		return 1;
+	}
+}
+
+static inline int
+rc_direct_bit(void)
+{
+	rc_normalize();
+	ctx.range >>= 1;
+	if (ctx.code >= ctx.range) {
+		ctx.code -= ctx.range;
+		return 1;
+	}
+	return 0;
+}
+
+static inline void
+rc_bit_tree_decode(u16 *p, int num_levels, int *symbol)
+{
+	int i = num_levels;
+
+	*symbol = 1;
+	while (i--)
+		rc_get_bit(p + *symbol, symbol);
+	*symbol -= 1 << num_levels;
+}
+
+static inline u8
+peek_old_byte(u32 offs)
+{
+	u32 pos = ctx.pos - offs;
+	return ctx.outbuf[pos];
+}
+
+static inline void
+write_byte(u8 byte)
+{
+	ctx.previous_byte = byte;
+	*(ctx.next_out++) = byte;
+	ctx.pos++;
+}
+
+
+static inline void
+copy_byte(u32 offs)
+{
+	write_byte(peek_old_byte(offs));
+}
+
+static inline void
+copy_bytes(u32 rep0, int len)
+{
+	do {
+		copy_byte(rep0);
+		len--;
+	} while (len != 0);
+}
+
+static inline void
+process_bit0(u16 *p, int pos_state, u16 *prob,
+             int lc, u32 literal_pos_mask)
+{
+	int mi = 1;
+	rc_update_bit_0(prob);
+	prob = (p + LZMA_LITERAL +
+		(LZMA_LIT_SIZE
+		 * (((ctx.pos & literal_pos_mask) << lc)
+		    + (ctx.previous_byte >> (8 - lc))))
+		);
+
+	if (ctx.state >= LZMA_NUM_LIT_STATES) {
+		int match_byte = peek_old_byte(ctx.rep0);
+		do {
+			u16 bit;
+			u16 *prob_lit;
+
+			match_byte <<= 1;
+			bit = match_byte & 0x100;
+			prob_lit = prob + 0x100 + bit + mi;
+			if (rc_get_bit(prob_lit, &mi) != !!bit)
+				break;
+		} while (mi < 0x100);
+	}
+	while (mi < 0x100) {
+		u16 *prob_lit = prob + mi;
+		rc_get_bit(prob_lit, &mi);
+	}
+	write_byte(mi);
+	if (ctx.state < 4)
+		ctx.state = 0;
+	else if (ctx.state < 10)
+		ctx.state -= 3;
+	else
+		ctx.state -= 6;
+}
+
+static inline void
+process_bit1(u16 *p, int pos_state, u16 *prob)
+{
+	int offset;
+	u16 *prob_len;
+	int num_bits;
+	int len;
+
+	rc_update_bit_1(prob);
+	prob = p + LZMA_IS_REP + ctx.state;
+	if (rc_is_bit_0(prob)) {
+		rc_update_bit_0(prob);
+		ctx.rep3 = ctx.rep2;
+		ctx.rep2 = ctx.rep1;
+		ctx.rep1 = ctx.rep0;
+		ctx.state = ctx.state < LZMA_NUM_LIT_STATES ? 0 : 3;
+		prob = p + LZMA_LEN_CODER;
+	} else {
+		rc_update_bit_1(prob);
+		prob = p + LZMA_IS_REP_G0 + ctx.state;
+		if (rc_is_bit_0(prob)) {
+			rc_update_bit_0(prob);
+			prob = (p + LZMA_IS_REP_0_LONG
+				+ (ctx.state <<
+				   LZMA_NUM_POS_BITS_MAX) +
+				pos_state);
+			if (rc_is_bit_0(prob)) {
+				rc_update_bit_0(prob);
+
+				ctx.state = ctx.state < LZMA_NUM_LIT_STATES ?
+					9 : 11;
+				copy_byte(ctx.rep0);
+				return;
+			} else {
+				rc_update_bit_1(prob);
+			}
+		} else {
+			u32 distance;
+
+			rc_update_bit_1(prob);
+			prob = p + LZMA_IS_REP_G1 + ctx.state;
+			if (rc_is_bit_0(prob)) {
+				rc_update_bit_0(prob);
+				distance = ctx.rep1;
+			} else {
+				rc_update_bit_1(prob);
+				prob = p + LZMA_IS_REP_G2 + ctx.state;
+				if (rc_is_bit_0(prob)) {
+					rc_update_bit_0(prob);
+					distance = ctx.rep2;
+				} else {
+					rc_update_bit_1(prob);
+					distance = ctx.rep3;
+					ctx.rep3 = ctx.rep2;
+				}
+				ctx.rep2 = ctx.rep1;
+			}
+			ctx.rep1 = ctx.rep0;
+			ctx.rep0 = distance;
+		}
+		ctx.state = ctx.state < LZMA_NUM_LIT_STATES ? 8 : 11;
+		prob = p + LZMA_REP_LEN_CODER;
+	}
+
+	prob_len = prob + LZMA_LEN_CHOICE;
+	if (rc_is_bit_0(prob_len)) {
+		rc_update_bit_0(prob_len);
+		prob_len = (prob + LZMA_LEN_LOW
+			    + (pos_state <<
+			       LZMA_LEN_NUM_LOW_BITS));
+		offset = 0;
+		num_bits = LZMA_LEN_NUM_LOW_BITS;
+	} else {
+		rc_update_bit_1(prob_len);
+		prob_len = prob + LZMA_LEN_CHOICE_2;
+		if (rc_is_bit_0(prob_len)) {
+			rc_update_bit_0(prob_len);
+			prob_len = (prob + LZMA_LEN_MID
+				    + (pos_state <<
+				       LZMA_LEN_NUM_MID_BITS));
+			offset = 1 << LZMA_LEN_NUM_LOW_BITS;
+			num_bits = LZMA_LEN_NUM_MID_BITS;
+		} else {
+			rc_update_bit_1(prob_len);
+			prob_len = prob + LZMA_LEN_HIGH;
+			offset = ((1 << LZMA_LEN_NUM_LOW_BITS)
+				  + (1 << LZMA_LEN_NUM_MID_BITS));
+			num_bits = LZMA_LEN_NUM_HIGH_BITS;
+		}
+	}
+
+	rc_bit_tree_decode(prob_len, num_bits, &len);
+	len += offset;
+
+	if (ctx.state < 4) {
+		int pos_slot;
+
+		ctx.state += LZMA_NUM_LIT_STATES;
+		prob =
+			p + LZMA_POS_SLOT +
+			((len <
+			  LZMA_NUM_LEN_TO_POS_STATES ? len :
+			  LZMA_NUM_LEN_TO_POS_STATES - 1)
+			 << LZMA_NUM_POS_SLOT_BITS);
+		rc_bit_tree_decode(prob,
+				   LZMA_NUM_POS_SLOT_BITS,
+				   &pos_slot);
+		if (pos_slot >= LZMA_START_POS_MODEL_INDEX) {
+			int i, mi;
+			num_bits = (pos_slot >> 1) - 1;
+			ctx.rep0 = 2 | (pos_slot & 1);
+			if (pos_slot < LZMA_END_POS_MODEL_INDEX) {
+				ctx.rep0 <<= num_bits;
+				prob = p + LZMA_SPEC_POS +
+					ctx.rep0 - pos_slot - 1;
+			} else {
+				num_bits -= LZMA_NUM_ALIGN_BITS;
+				while (num_bits--)
+					ctx.rep0 = (ctx.rep0 << 1) |
+						rc_direct_bit();
+				prob = p + LZMA_ALIGN;
+				ctx.rep0 <<= LZMA_NUM_ALIGN_BITS;
+				num_bits = LZMA_NUM_ALIGN_BITS;
+			}
+			i = 1;
+			mi = 1;
+			while (num_bits--) {
+				if (rc_get_bit(prob + mi, &mi))
+					ctx.rep0 |= i;
+				i <<= 1;
+			}
+		} else
+			ctx.rep0 = pos_slot;
+		if (++(ctx.rep0) == 0)
+			return;
+	}
+
+	len += LZMA_MATCH_MIN_LEN;
+
+	copy_bytes(ctx.rep0, len);
+}
+
+
+static int
+do_unlzma(void)
+{
+	u8 hdr_buf[sizeof(struct lzma_header)];
+	struct lzma_header *header = (struct lzma_header *)hdr_buf;
+	u32 pos_state_mask;
+	u32 literal_pos_mask;
+	int lc, pb, lp;
+	int num_probs;
+	int i, mi;
+	u16 *p;
+
+	for (i = 0; i < sizeof(struct lzma_header); i++) {
+		hdr_buf[i] = rc_read();
+	}
+
+	ctx.pos = 0;
+	ctx.state = 0;
+	ctx.rep0 = ctx.rep1 = ctx.rep2 = ctx.rep3 = 1;
+
+	ctx.previous_byte = 0;
+	ctx.code = 0;
+	ctx.range = 0xFFFFFFFF;
+
+	if (header->pos >= (9 * 5 * 5))
+		return -1;
+
+	mi = 0;
+	lc = header->pos;
+	while (lc >= 9) {
+		mi++;
+		lc -= 9;
+	}
+	pb = 0;
+	lp = mi;
+	while (lp >= 5) {
+		pb++;
+		lp -= 5;
+	}
+	pos_state_mask = (1 << pb) - 1;
+	literal_pos_mask = (1 << lp) - 1;
+
+	p = (u16 *) ctx.workspace;
+	if (!p)
+		return -1;
+
+	num_probs = LZMA_LITERAL + (LZMA_LIT_SIZE << (lc + lp));
+	for (i = 0; i < num_probs; i++)
+		p[i] = (1 << RC_MODEL_TOTAL_BITS) >> 1;
+
+	for (i = 0; i < 5; i++)
+		rc_get_code();
+
+	while (1) {
+		int pos_state =	ctx.pos & pos_state_mask;
+		u16 *prob = p + LZMA_IS_MATCH +
+			(ctx.state << LZMA_NUM_POS_BITS_MAX) + pos_state;
+		if (rc_is_bit_0(prob))
+			process_bit0(p, pos_state, prob,
+				     lc, literal_pos_mask);
+		else {
+			process_bit1(p, pos_state, prob);
+			if (ctx.rep0 == 0)
+				break;
+		}
+	}
+
+	return ctx.pos;
+}
+
+
+static int unlzma(unsigned char *dest, const unsigned char *src, unsigned char *workspace)
+{
+	memset(&ctx, 0, sizeof(ctx));
+	ctx.outbuf = dest;
+	ctx.next_in = src;
+	ctx.next_out = dest;
+	ctx.workspace = workspace;
+
+	return do_unlzma();
+}
+
+
diff -Nru linux-2.6.30.5/arch/arm/boot/compressed/unlzma.h linux-2.6.30.5-wrt/arch/arm/boot/compressed/unlzma.h
--- linux-2.6.30.5/arch/arm/boot/compressed/unlzma.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/arch/arm/boot/compressed/unlzma.h	2009-09-06 18:44:06.831166738 +0200
@@ -0,0 +1,81 @@
+/* LZMA uncompresion module for pcomp
+ * Copyright (C) 2009  Felix Fietkau <nbd@openwrt.org>
+ *
+ * Based on:
+ *  Initial Linux kernel adaptation
+ *  Copyright (C) 2006  Alain < alain@knaff.lu >
+ *
+ *  Based on small lzma deflate implementation/Small range coder
+ *  implementation for lzma.
+ *  Copyright (C) 2006  Aurelien Jacobs < aurel@gnuage.org >
+ *
+ *  Based on LzmaDecode.c from the LZMA SDK 4.22 (http://www.7-zip.org/)
+ *  Copyright (C) 1999-2005  Igor Pavlov
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+#ifndef __UNLZMA_H
+#define __UNLZMA_H
+
+struct lzma_header {
+	__u8 pos;
+	__le32 dict_size;
+	__le64 uncompr_size;
+} __attribute__ ((packed));
+
+
+#define RC_TOP_BITS 24
+#define RC_MOVE_BITS 5
+#define RC_MODEL_TOTAL_BITS 11
+
+#define LZMA_BASE_SIZE 1846
+#define LZMA_LIT_SIZE 768
+
+#define LZMA_NUM_POS_BITS_MAX 4
+
+#define LZMA_LEN_NUM_LOW_BITS 3
+#define LZMA_LEN_NUM_MID_BITS 3
+#define LZMA_LEN_NUM_HIGH_BITS 8
+
+#define LZMA_LEN_CHOICE 0
+#define LZMA_LEN_CHOICE_2 (LZMA_LEN_CHOICE + 1)
+#define LZMA_LEN_LOW (LZMA_LEN_CHOICE_2 + 1)
+#define LZMA_LEN_MID (LZMA_LEN_LOW \
+		      + (1 << (LZMA_NUM_POS_BITS_MAX + LZMA_LEN_NUM_LOW_BITS)))
+#define LZMA_LEN_HIGH (LZMA_LEN_MID \
+		       +(1 << (LZMA_NUM_POS_BITS_MAX + LZMA_LEN_NUM_MID_BITS)))
+#define LZMA_NUM_LEN_PROBS (LZMA_LEN_HIGH + (1 << LZMA_LEN_NUM_HIGH_BITS))
+
+#define LZMA_NUM_STATES 12
+#define LZMA_NUM_LIT_STATES 7
+
+#define LZMA_START_POS_MODEL_INDEX 4
+#define LZMA_END_POS_MODEL_INDEX 14
+#define LZMA_NUM_FULL_DISTANCES (1 << (LZMA_END_POS_MODEL_INDEX >> 1))
+
+#define LZMA_NUM_POS_SLOT_BITS 6
+#define LZMA_NUM_LEN_TO_POS_STATES 4
+
+#define LZMA_NUM_ALIGN_BITS 4
+
+#define LZMA_MATCH_MIN_LEN 2
+
+#define LZMA_IS_MATCH 0
+#define LZMA_IS_REP (LZMA_IS_MATCH + (LZMA_NUM_STATES << LZMA_NUM_POS_BITS_MAX))
+#define LZMA_IS_REP_G0 (LZMA_IS_REP + LZMA_NUM_STATES)
+#define LZMA_IS_REP_G1 (LZMA_IS_REP_G0 + LZMA_NUM_STATES)
+#define LZMA_IS_REP_G2 (LZMA_IS_REP_G1 + LZMA_NUM_STATES)
+#define LZMA_IS_REP_0_LONG (LZMA_IS_REP_G2 + LZMA_NUM_STATES)
+#define LZMA_POS_SLOT (LZMA_IS_REP_0_LONG \
+		       + (LZMA_NUM_STATES << LZMA_NUM_POS_BITS_MAX))
+#define LZMA_SPEC_POS (LZMA_POS_SLOT \
+		       +(LZMA_NUM_LEN_TO_POS_STATES << LZMA_NUM_POS_SLOT_BITS))
+#define LZMA_ALIGN (LZMA_SPEC_POS \
+		    + LZMA_NUM_FULL_DISTANCES - LZMA_END_POS_MODEL_INDEX)
+#define LZMA_LEN_CODER (LZMA_ALIGN + (1 << LZMA_NUM_ALIGN_BITS))
+#define LZMA_REP_LEN_CODER (LZMA_LEN_CODER + LZMA_NUM_LEN_PROBS)
+#define LZMA_LITERAL (LZMA_REP_LEN_CODER + LZMA_NUM_LEN_PROBS)
+
+#endif
diff -Nru linux-2.6.30.5/arch/arm/kernel/vmlinux.lds.S linux-2.6.30.5-wrt/arch/arm/kernel/vmlinux.lds.S
--- linux-2.6.30.5/arch/arm/kernel/vmlinux.lds.S	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/arm/kernel/vmlinux.lds.S	2009-09-06 18:43:48.334667043 +0200
@@ -78,18 +78,6 @@
 #endif
 	}
 
-	/DISCARD/ : {			/* Exit code and data		*/
-		EXIT_TEXT
-		EXIT_DATA
-		*(.exitcall.exit)
-		*(.ARM.exidx.exit.text)
-		*(.ARM.extab.exit.text)
-#ifndef CONFIG_MMU
-		*(.fixup)
-		*(__ex_table)
-#endif
-	}
-
 	.text : {			/* Real text segment		*/
 		_text = .;		/* Text and read-only data	*/
 			__exception_text_start = .;
@@ -194,6 +182,20 @@
 		*(COMMON)
 		_end = .;
 	}
+
+	/DISCARD/ : {			/* Exit code and data		*/
+		EXIT_TEXT
+		EXIT_DATA
+		*(.discard)
+		*(.exitcall.exit)
+		*(.ARM.exidx.exit.text)
+		*(.ARM.extab.exit.text)
+#ifndef CONFIG_MMU
+		*(.fixup)
+		*(__ex_table)
+#endif
+	}
+
 					/* Stabs debugging sections.	*/
 	.stab 0 : { *(.stab) }
 	.stabstr 0 : { *(.stabstr) }
diff -Nru linux-2.6.30.5/arch/arm/vfp/vfphw.S linux-2.6.30.5-wrt/arch/arm/vfp/vfphw.S
--- linux-2.6.30.5/arch/arm/vfp/vfphw.S	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/arm/vfp/vfphw.S	2009-09-06 18:44:12.071167890 +0200
@@ -100,6 +100,7 @@
 	beq	no_old_VFP_process
 	VFPFSTMIA r4, r5		@ save the working registers
 	VFPFMRX	r5, FPSCR		@ current status
+#ifndef CONFIG_CPU_FEROCEON
 	tst	r1, #FPEXC_EX		@ is there additional state to save?
 	beq	1f
 	VFPFMRX	r6, FPINST		@ FPINST (only if FPEXC.EX is set)
@@ -107,6 +108,7 @@
 	beq	1f
 	VFPFMRX	r8, FPINST2		@ FPINST2 if needed (and present)
 1:
+#endif
 	stmia	r4, {r1, r5, r6, r8}	@ save FPEXC, FPSCR, FPINST, FPINST2
 					@ and point r4 at the word at the
 					@ start of the register dump
@@ -119,6 +121,7 @@
 	VFPFLDMIA r10, r5		@ reload the working registers while
 					@ FPEXC is in a safe state
 	ldmia	r10, {r1, r5, r6, r8}	@ load FPEXC, FPSCR, FPINST, FPINST2
+#ifndef CONFIG_CPU_FEROCEON
 	tst	r1, #FPEXC_EX		@ is there additional state to restore?
 	beq	1f
 	VFPFMXR	FPINST, r6		@ restore FPINST (only if FPEXC.EX is set)
@@ -126,6 +129,7 @@
 	beq	1f
 	VFPFMXR	FPINST2, r8		@ FPINST2 if needed (and present)
 1:
+#endif
 	VFPFMXR	FPSCR, r5		@ restore status
 
 check_for_exception:
diff -Nru linux-2.6.30.5/arch/arm/vfp/vfpmodule.c linux-2.6.30.5-wrt/arch/arm/vfp/vfpmodule.c
--- linux-2.6.30.5/arch/arm/vfp/vfpmodule.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/arm/vfp/vfpmodule.c	2009-09-06 18:44:12.071167890 +0200
@@ -253,12 +253,14 @@
 	}
 
 	if (fpexc & FPEXC_EX) {
+#ifndef CONFIG_CPU_FEROCEON
 		/*
 		 * Asynchronous exception. The instruction is read from FPINST
 		 * and the interrupted instruction has to be restarted.
 		 */
 		trigger = fmrx(FPINST);
 		regs->ARM_pc -= 4;
+#endif
 	} else if (!(fpexc & FPEXC_DEX)) {
 		/*
 		 * Illegal combination of bits. It can be caused by an
diff -Nru linux-2.6.30.5/arch/cris/include/arch-v10/arch/Kbuild linux-2.6.30.5-wrt/arch/cris/include/arch-v10/arch/Kbuild
--- linux-2.6.30.5/arch/cris/include/arch-v10/arch/Kbuild	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/cris/include/arch-v10/arch/Kbuild	2009-09-06 18:44:12.071167890 +0200
@@ -1,3 +1,5 @@
+header-y += elf.h
+header-y += ptrace.h
 header-y += user.h
 header-y += svinto.h
 header-y += sv_addr_ag.h
diff -Nru linux-2.6.30.5/arch/cris/include/asm/Kbuild linux-2.6.30.5-wrt/arch/cris/include/asm/Kbuild
--- linux-2.6.30.5/arch/cris/include/asm/Kbuild	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/cris/include/asm/Kbuild	2009-09-06 18:44:12.071167890 +0200
@@ -1,11 +1,14 @@
 include include/asm-generic/Kbuild.asm
 
-header-y += arch-v10/
-header-y += arch-v32/
+header-y += ../arch-v10/arch/
+header-y += ../arch-v32/arch/
 
+header-y += elf.h
 header-y += ethernet.h
+header-y += page.h
 header-y += rtc.h
 header-y += sync_serial.h
+header-y += user.h
 
 unifdef-y += etraxgpio.h
 unifdef-y += rs485.h
diff -Nru linux-2.6.30.5/arch/mips/Kconfig linux-2.6.30.5-wrt/arch/mips/Kconfig
--- linux-2.6.30.5/arch/mips/Kconfig	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/mips/Kconfig	2009-09-06 20:06:17.767667418 +0200
@@ -53,9 +53,9 @@
 	select SSB_DRIVER_MIPS
 	select SSB_DRIVER_EXTIF
 	select SSB_EMBEDDED
+	select SSB_B43_PCI_BRIDGE if PCI
 	select SSB_PCICORE_HOSTMODE if PCI
 	select GENERIC_GPIO
-	select SYS_HAS_EARLY_PRINTK
 	select CFE
 	help
 	 Support for BCM47XX based boards
@@ -195,7 +195,6 @@
 	select I8259
 	select MIPS_BOARDS_GEN
 	select MIPS_BONITO64
-	select MIPS_CPU_SCACHE
 	select PCI_GT64XXX_PCI0
 	select MIPS_MSC
 	select SWAP_IO_SPACE
@@ -791,6 +790,17 @@
 config MIPS_BONITO64
 	bool
 
+config MIPS_FPU_EMU
+	bool
+	default y
+	help
+	   This option allows building a kernel with or without the Algorithmics
+	   FPU emulator enabled. Turning off this option results in a kernel which
+	   does not catch floating operations exceptions. Make sure that your toolchain
+	   is configured to enable software floating point emulation in that case.
+		
+	   If unsure say Y here.
+
 config MIPS_MSC
 	bool
 
@@ -803,6 +813,12 @@
 config SYNC_R4K
 	bool
 
+config MIPS_MACHINE
+	def_bool n
+	
+config PROM_EMU
+	def_bool n
+
 config NO_IOPORT
 	def_bool n
 
@@ -1455,13 +1471,6 @@
 	bool
 	select BOARD_SCACHE
 
-#
-# Support for a MIPS32 / MIPS64 style S-caches
-#
-config MIPS_CPU_SCACHE
-	bool
-	select BOARD_SCACHE
-
 config R5000_CPU_SCACHE
 	bool
 	select BOARD_SCACHE
diff -Nru linux-2.6.30.5/arch/mips/Makefile linux-2.6.30.5-wrt/arch/mips/Makefile
--- linux-2.6.30.5/arch/mips/Makefile	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/mips/Makefile	2009-09-06 18:43:48.406667725 +0200
@@ -83,7 +83,7 @@
 cflags-y			+= -G 0 -mno-abicalls -fno-pic -pipe
 cflags-y			+= -msoft-float
 LDFLAGS_vmlinux			+= -G 0 -static -n -nostdlib
-MODFLAGS			+= -mlong-calls
+MODFLAGS			+= -mno-long-calls
 
 cflags-y += -ffreestanding
 
@@ -603,6 +603,9 @@
 load-$(CONFIG_CPU_CAVIUM_OCTEON) 	+= 0xffffffff81100000
 endif
 
+# temporary until string.h is fixed
+cflags-y += -ffreestanding
+
 cflags-y			+= -I$(srctree)/arch/mips/include/asm/mach-generic
 drivers-$(CONFIG_PCI)		+= arch/mips/pci/
 
diff -Nru linux-2.6.30.5/arch/mips/bcm47xx/Makefile linux-2.6.30.5-wrt/arch/mips/bcm47xx/Makefile
--- linux-2.6.30.5/arch/mips/bcm47xx/Makefile	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/mips/bcm47xx/Makefile	2009-09-06 18:48:23.514666979 +0200
@@ -3,4 +3,4 @@
 # under Linux.
 #
 
-obj-y := gpio.o irq.o prom.o serial.o setup.o time.o wgt634u.o
+obj-y := cfe_env.o gpio.o irq.o nvram.o prom.o serial.o setup.o time.o
diff -Nru linux-2.6.30.5/arch/mips/bcm47xx/cfe_env.c linux-2.6.30.5-wrt/arch/mips/bcm47xx/cfe_env.c
--- linux-2.6.30.5/arch/mips/bcm47xx/cfe_env.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/arch/mips/bcm47xx/cfe_env.c	2009-09-06 18:48:09.942698957 +0200
@@ -0,0 +1,229 @@
+/*
+ * CFE environment variable access
+ *
+ * Copyright 2001-2003, Broadcom Corporation
+ * Copyright 2006, Felix Fietkau <nbd@openwrt.org>
+ * 
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#define NVRAM_SIZE       (0x1ff0)
+static char _nvdata[NVRAM_SIZE];
+static char _valuestr[256];
+
+/*
+ * TLV types.  These codes are used in the "type-length-value"
+ * encoding of the items stored in the NVRAM device (flash or EEPROM)
+ *
+ * The layout of the flash/nvram is as follows:
+ *
+ * <type> <length> <data ...> <type> <length> <data ...> <type_end>
+ *
+ * The type code of "ENV_TLV_TYPE_END" marks the end of the list.
+ * The "length" field marks the length of the data section, not
+ * including the type and length fields.
+ *
+ * Environment variables are stored as follows:
+ *
+ * <type_env> <length> <flags> <name> = <value>
+ *
+ * If bit 0 (low bit) is set, the length is an 8-bit value.
+ * If bit 0 (low bit) is clear, the length is a 16-bit value
+ * 
+ * Bit 7 set indicates "user" TLVs.  In this case, bit 0 still
+ * indicates the size of the length field.  
+ *
+ * Flags are from the constants below:
+ *
+ */
+#define ENV_LENGTH_16BITS	0x00	/* for low bit */
+#define ENV_LENGTH_8BITS	0x01
+
+#define ENV_TYPE_USER		0x80
+
+#define ENV_CODE_SYS(n,l) (((n)<<1)|(l))
+#define ENV_CODE_USER(n,l) ((((n)<<1)|(l)) | ENV_TYPE_USER)
+
+/*
+ * The actual TLV types we support
+ */
+
+#define ENV_TLV_TYPE_END	0x00	
+#define ENV_TLV_TYPE_ENV	ENV_CODE_SYS(0,ENV_LENGTH_8BITS)
+
+/*
+ * Environment variable flags 
+ */
+
+#define ENV_FLG_NORMAL		0x00	/* normal read/write */
+#define ENV_FLG_BUILTIN		0x01	/* builtin - not stored in flash */
+#define ENV_FLG_READONLY	0x02	/* read-only - cannot be changed */
+
+#define ENV_FLG_MASK		0xFF	/* mask of attributes we keep */
+#define ENV_FLG_ADMIN		0x100	/* lets us internally override permissions */
+
+
+/*  *********************************************************************
+    *  _nvram_read(buffer,offset,length)
+    *  
+    *  Read data from the NVRAM device
+    *  
+    *  Input parameters: 
+    *  	   buffer - destination buffer
+    *  	   offset - offset of data to read
+    *  	   length - number of bytes to read
+    *  	   
+    *  Return value:
+    *  	   number of bytes read, or <0 if error occured
+    ********************************************************************* */
+static int
+_nvram_read(unsigned char *nv_buf, unsigned char *buffer, int offset, int length)
+{
+    int i;
+    if (offset > NVRAM_SIZE)
+	return -1; 
+
+    for ( i = 0; i < length; i++) {
+	buffer[i] = ((volatile unsigned char*)nv_buf)[offset + i];
+    }
+    return length;
+}
+
+
+static char*
+_strnchr(const char *dest,int c,size_t cnt)
+{
+	while (*dest && (cnt > 0)) {
+	if (*dest == c) return (char *) dest;
+	dest++;
+	cnt--;
+	}
+	return NULL;
+}
+
+
+
+/*
+ * Core support API: Externally visible.
+ */
+
+/*
+ * Get the value of an NVRAM variable
+ * @param	name	name of variable to get
+ * @return	value of variable or NULL if undefined
+ */
+
+char* 
+cfe_env_get(unsigned char *nv_buf, char* name)
+{
+    int size;
+    unsigned char *buffer;
+    unsigned char *ptr;
+    unsigned char *envval;
+    unsigned int reclen;
+    unsigned int rectype;
+    int offset;
+    int flg;
+    
+	if (!strcmp(name, "nvram_type"))
+		return "cfe";
+	
+    size = NVRAM_SIZE;
+    buffer = &_nvdata[0];
+
+    ptr = buffer;
+    offset = 0;
+
+    /* Read the record type and length */
+    if (_nvram_read(nv_buf, ptr,offset,1) != 1) {
+	goto error;
+    }
+    
+    while ((*ptr != ENV_TLV_TYPE_END)  && (size > 1)) {
+
+	/* Adjust pointer for TLV type */
+	rectype = *(ptr);
+	offset++;
+	size--;
+
+	/* 
+	 * Read the length.  It can be either 1 or 2 bytes
+	 * depending on the code 
+	 */
+	if (rectype & ENV_LENGTH_8BITS) {
+	    /* Read the record type and length - 8 bits */
+	    if (_nvram_read(nv_buf, ptr,offset,1) != 1) {
+		goto error;
+	    }
+	    reclen = *(ptr);
+	    size--;
+	    offset++;
+	}
+	else {
+	    /* Read the record type and length - 16 bits, MSB first */
+	    if (_nvram_read(nv_buf, ptr,offset,2) != 2) {
+		goto error;
+	    }
+	    reclen = (((unsigned int) *(ptr)) << 8) + (unsigned int) *(ptr+1);
+	    size -= 2;
+	    offset += 2;
+	}
+
+	if (reclen > size)
+	    break;	/* should not happen, bad NVRAM */
+
+	switch (rectype) {
+	    case ENV_TLV_TYPE_ENV:
+		/* Read the TLV data */
+		if (_nvram_read(nv_buf, ptr,offset,reclen) != reclen)
+		    goto error;
+		flg = *ptr++;
+		envval = (unsigned char *) _strnchr(ptr,'=',(reclen-1));
+		if (envval) {
+		    *envval++ = '\0';
+		    memcpy(_valuestr,envval,(reclen-1)-(envval-ptr));
+		    _valuestr[(reclen-1)-(envval-ptr)] = '\0';
+#if 0			
+		    printk(KERN_INFO "NVRAM:%s=%s\n", ptr, _valuestr);
+#endif
+		    if(!strcmp(ptr, name)){
+			return _valuestr;
+		    }
+		    if((strlen(ptr) > 1) && !strcmp(&ptr[1], name))
+			return _valuestr;
+		}
+		break;
+		
+	    default: 
+		/* Unknown TLV type, skip it. */
+		break;
+	    }
+
+	/*
+	 * Advance to next TLV 
+	 */
+		
+	size -= (int)reclen;
+	offset += reclen;
+
+	/* Read the next record type */
+	ptr = buffer;
+	if (_nvram_read(nv_buf, ptr,offset,1) != 1)
+	    goto error;
+	}
+
+error:
+    return NULL;
+
+}
+
diff -Nru linux-2.6.30.5/arch/mips/bcm47xx/include/nvram.h linux-2.6.30.5-wrt/arch/mips/bcm47xx/include/nvram.h
--- linux-2.6.30.5/arch/mips/bcm47xx/include/nvram.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/arch/mips/bcm47xx/include/nvram.h	2009-09-06 18:48:09.942698957 +0200
@@ -0,0 +1,37 @@
+/*
+ *  Copyright (C) 2006 Felix Fietkau <nbd@openwrt.org>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ */
+
+#ifndef __NVRAM_H
+#define __NVRAM_H
+
+struct nvram_header {
+	u32 magic;
+	u32 len;
+	u32 crc_ver_init;	/* 0:7 crc, 8:15 ver, 16:31 sdram_init */
+	u32 config_refresh;	/* 0:15 sdram_config, 16:31 sdram_refresh */
+	u32 config_ncdl;	/* ncdl values for memc */
+};
+
+struct nvram_tuple {
+	char *name;
+	char *value;
+	struct nvram_tuple *next;
+};
+
+#define NVRAM_HEADER		0x48534C46	/* 'FLSH' */
+#define NVRAM_VERSION		1
+#define NVRAM_HEADER_SIZE	20
+#define NVRAM_SPACE		0x8000
+
+#define NVRAM_MAX_VALUE_LEN 255
+#define NVRAM_MAX_PARAM_LEN 64
+
+char *nvram_get(const char *name);
+
+#endif
diff -Nru linux-2.6.30.5/arch/mips/bcm47xx/irq.c linux-2.6.30.5-wrt/arch/mips/bcm47xx/irq.c
--- linux-2.6.30.5/arch/mips/bcm47xx/irq.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/mips/bcm47xx/irq.c	2009-09-06 18:47:53.807167203 +0200
@@ -1,5 +1,6 @@
 /*
  *  Copyright (C) 2004 Florian Schirmer <jolt@tuxbox.org>
+ *  Copyright (C) 2008 Michael Buesch <mb@bu3sch.de>
  *
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
@@ -23,10 +24,19 @@
  */
 
 #include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/irq.h>
+#include <linux/pci.h>
+#include <linux/ssb/ssb.h>
+
 #include <asm/irq_cpu.h>
 
+
+extern struct ssb_bus ssb_bcm47xx;
+
+
 void plat_irq_dispatch(void)
 {
 	u32 cause;
diff -Nru linux-2.6.30.5/arch/mips/bcm47xx/nvram.c linux-2.6.30.5-wrt/arch/mips/bcm47xx/nvram.c
--- linux-2.6.30.5/arch/mips/bcm47xx/nvram.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/arch/mips/bcm47xx/nvram.c	2009-09-06 18:48:23.498667592 +0200
@@ -0,0 +1,125 @@
+/*
+ * BCM947xx nvram variable access
+ *
+ * Copyright 2005, Broadcom Corporation
+ * Copyright 2006, Felix Fietkau <nbd@openwrt.org>
+ * 
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/ssb/ssb.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <asm/byteorder.h>
+#include <asm/bootinfo.h>
+#include <asm/addrspace.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include "include/nvram.h"
+
+#define MB * 1048576
+extern struct ssb_bus ssb_bcm47xx;
+
+static char nvram_buf[NVRAM_SPACE];
+static int cfe_env;
+extern char *cfe_env_get(char *nv_buf, const char *name);
+		
+/* Probe for NVRAM header */
+static void __init early_nvram_init(void)
+{
+	struct ssb_mipscore *mcore = &ssb_bcm47xx.mipscore;
+	struct nvram_header *header;
+	int i;
+	u32 base, lim, off;
+	u32 *src, *dst;
+	
+	base = mcore->flash_window;
+	lim = mcore->flash_window_size;
+	cfe_env = 0;
+
+	
+	/* XXX: hack for supporting the CFE environment stuff on WGT634U */
+	if (lim >= 8 MB) {
+		src = (u32 *) KSEG1ADDR(base + 8 MB - 0x2000);
+		dst = (u32 *) nvram_buf;
+
+		if ((*src & 0xff00ff) == 0x000001) {
+			printk("early_nvram_init: WGT634U NVRAM found.\n");
+
+			for (i = 0; i < 0x1ff0; i++) {
+				if (*src == 0xFFFFFFFF)
+					break;
+				*dst++ = *src++;
+			}
+			cfe_env = 1;
+			return;
+		}
+	}
+
+	off = 0x20000;
+	while (off <= lim) {
+		/* Windowed flash access */
+		header = (struct nvram_header *) KSEG1ADDR(base + off - NVRAM_SPACE);
+		if (header->magic == NVRAM_HEADER)
+			goto found;
+		off <<= 1;
+	}
+
+	/* Try embedded NVRAM at 4 KB and 1 KB as last resorts */
+	header = (struct nvram_header *) KSEG1ADDR(base + 4096);
+	if (header->magic == NVRAM_HEADER)
+		goto found;
+	
+	header = (struct nvram_header *) KSEG1ADDR(base + 1024);
+	if (header->magic == NVRAM_HEADER)
+		goto found;
+	
+	return;
+
+found:
+	src = (u32 *) header;
+	dst = (u32 *) nvram_buf;
+	for (i = 0; i < sizeof(struct nvram_header); i += 4)
+		*dst++ = *src++;
+	for (; i < header->len && i < NVRAM_SPACE; i += 4)
+		*dst++ = le32_to_cpu(*src++);
+}
+
+char *nvram_get(const char *name)
+{
+	char *var, *value, *end, *eq;
+
+	if (!name)
+		return NULL;
+
+	if (!nvram_buf[0])
+		early_nvram_init();
+
+	if (cfe_env)
+		return cfe_env_get(nvram_buf, name);
+
+	/* Look for name=value and return value */
+	var = &nvram_buf[sizeof(struct nvram_header)];
+	end = nvram_buf + sizeof(nvram_buf) - 2;
+	end[0] = end[1] = '\0';
+	for (; *var; var = value + strlen(value) + 1) {
+		if (!(eq = strchr(var, '=')))
+			break;
+		value = eq + 1;
+		if ((eq - var) == strlen(name) && strncmp(var, name, (eq - var)) == 0)
+			return value;
+	}
+
+	return NULL;
+}
+
+EXPORT_SYMBOL(nvram_get);
diff -Nru linux-2.6.30.5/arch/mips/bcm47xx/prom.c linux-2.6.30.5-wrt/arch/mips/bcm47xx/prom.c
--- linux-2.6.30.5/arch/mips/bcm47xx/prom.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/mips/bcm47xx/prom.c	2009-09-06 20:05:16.723666769 +0200
@@ -32,6 +32,7 @@
 #include <asm/fw/cfe/cfe_error.h>
 
 static int cfe_cons_handle;
+static void (* __prom_putchar)(char c);
 
 const char *get_system_type(void)
 {
@@ -40,65 +41,40 @@
 
 void prom_putchar(char c)
 {
+	if (__prom_putchar)
+		__prom_putchar(c);
+}
+
+void prom_putchar_cfe(char c)
+{
 	while (cfe_write(cfe_cons_handle, &c, 1) == 0)
 		;
 }
 
-static __init void prom_init_cfe(void)
+static __init int prom_init_cfe(void)
 {
 	uint32_t cfe_ept;
 	uint32_t cfe_handle;
 	uint32_t cfe_eptseal;
-	int argc = fw_arg0;
-	char **envp = (char **) fw_arg2;
-	int *prom_vec = (int *) fw_arg3;
-
-	/*
-	 * Check if a loader was used; if NOT, the 4 arguments are
-	 * what CFE gives us (handle, 0, EPT and EPTSEAL)
-	 */
-	if (argc < 0) {
-		cfe_handle = (uint32_t)argc;
-		cfe_ept = (uint32_t)envp;
-		cfe_eptseal = (uint32_t)prom_vec;
-	} else {
-		if ((int)prom_vec < 0) {
-			/*
-			 * Old loader; all it gives us is the handle,
-			 * so use the "known" entrypoint and assume
-			 * the seal.
-			 */
-			cfe_handle = (uint32_t)prom_vec;
-			cfe_ept = 0xBFC00500;
-			cfe_eptseal = CFE_EPTSEAL;
-		} else {
-			/*
-			 * Newer loaders bundle the handle/ept/eptseal
-			 * Note: prom_vec is in the loader's useg
-			 * which is still alive in the TLB.
-			 */
-			cfe_handle = prom_vec[0];
-			cfe_ept = prom_vec[2];
-			cfe_eptseal = prom_vec[3];
-		}
-	}
 
-	if (cfe_eptseal != CFE_EPTSEAL) {
-		/* too early for panic to do any good */
-		printk(KERN_ERR "CFE's entrypoint seal doesn't match.");
-		while (1) ;
-	}
+	cfe_eptseal = (uint32_t) fw_arg3;
+	cfe_handle = (uint32_t) fw_arg0;
+	cfe_ept = (uint32_t) fw_arg2;
+
+	if (cfe_eptseal != CFE_EPTSEAL)
+		return -1;
 
 	cfe_init(cfe_handle, cfe_ept);
+	return 0;
 }
 
-static __init void prom_init_console(void)
+static __init void prom_init_console_cfe(void)
 {
 	/* Initialize CFE console */
 	cfe_cons_handle = cfe_getstdhandle(CFE_STDHANDLE_CONSOLE);
 }
 
-static __init void prom_init_cmdline(void)
+static __init void prom_init_cmdline_cfe(void)
 {
 	char buf[CL_SIZE];
 
@@ -146,9 +122,12 @@
 
 void __init prom_init(void)
 {
-	prom_init_cfe();
-	prom_init_console();
-	prom_init_cmdline();
+	if (prom_init_cfe() == 0) {
+//		prom_init_console_cfe();
+//		prom_init_cmdline_cfe();
+		__prom_putchar = prom_putchar_cfe;
+	}
+
 	prom_init_mem();
 }
 
diff -Nru linux-2.6.30.5/arch/mips/bcm47xx/setup.c linux-2.6.30.5-wrt/arch/mips/bcm47xx/setup.c
--- linux-2.6.30.5/arch/mips/bcm47xx/setup.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/mips/bcm47xx/setup.c	2009-09-06 18:48:23.498667592 +0200
@@ -2,7 +2,7 @@
  *  Copyright (C) 2004 Florian Schirmer <jolt@tuxbox.org>
  *  Copyright (C) 2005 Waldemar Brodkorb <wbx@openwrt.org>
  *  Copyright (C) 2006 Felix Fietkau <nbd@openwrt.org>
- *  Copyright (C) 2006 Michael Buesch <mb@bu3sch.de>
+ *  Copyright (C) 2006-2008 Michael Buesch <mb@bu3sch.de>
  *
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
@@ -25,18 +25,28 @@
  *  675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
+#include <linux/init.h>
 #include <linux/types.h>
 #include <linux/ssb/ssb.h>
 #include <linux/ssb/ssb_embedded.h>
+#include <linux/tty.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/serial_reg.h>
+#include <linux/serial_8250.h>
 #include <asm/bootinfo.h>
 #include <asm/reboot.h>
 #include <asm/time.h>
-#include <bcm47xx.h>
 #include <asm/fw/cfe/cfe_api.h>
+#include <linux/pm.h>
+
+#include "include/nvram.h"
 
 struct ssb_bus ssb_bcm47xx;
 EXPORT_SYMBOL(ssb_bcm47xx);
 
+extern void bcm47xx_pci_init(void);
+
 static void bcm47xx_machine_restart(char *command)
 {
 	printk(KERN_ALERT "Please stand by while rebooting the system...\n");
@@ -56,7 +66,7 @@
 		cpu_relax();
 }
 
-static void str2eaddr(char *str, char *dest)
+static void e_aton(char *str, char *dest)
 {
 	int i = 0;
 
@@ -73,52 +83,142 @@
 	}
 }
 
-static int bcm47xx_get_invariants(struct ssb_bus *bus,
-				   struct ssb_init_invariants *iv)
+static void bcm47xx_fill_sprom(struct ssb_sprom *sprom)
 {
-	char buf[100];
+	char *s;
 
-	/* Fill boardinfo structure */
-	memset(&(iv->boardinfo), 0 , sizeof(struct ssb_boardinfo));
+	memset(sprom, 0xFF, sizeof(struct ssb_sprom));
 
-	if (cfe_getenv("boardvendor", buf, sizeof(buf)) >= 0)
-		iv->boardinfo.type = (u16)simple_strtoul(buf, NULL, 0);
-	if (cfe_getenv("boardtype", buf, sizeof(buf)) >= 0)
-		iv->boardinfo.type = (u16)simple_strtoul(buf, NULL, 0);
-	if (cfe_getenv("boardrev", buf, sizeof(buf)) >= 0)
-		iv->boardinfo.rev = (u16)simple_strtoul(buf, NULL, 0);
-
-	/* Fill sprom structure */
-	memset(&(iv->sprom), 0, sizeof(struct ssb_sprom));
-	iv->sprom.revision = 3;
-
-	if (cfe_getenv("et0macaddr", buf, sizeof(buf)) >= 0)
-		str2eaddr(buf, iv->sprom.et0mac);
-	if (cfe_getenv("et1macaddr", buf, sizeof(buf)) >= 0)
-		str2eaddr(buf, iv->sprom.et1mac);
-	if (cfe_getenv("et0phyaddr", buf, sizeof(buf)) >= 0)
-		iv->sprom.et0phyaddr = simple_strtoul(buf, NULL, 10);
-	if (cfe_getenv("et1phyaddr", buf, sizeof(buf)) >= 0)
-		iv->sprom.et1phyaddr = simple_strtoul(buf, NULL, 10);
-	if (cfe_getenv("et0mdcport", buf, sizeof(buf)) >= 0)
-		iv->sprom.et0mdcport = simple_strtoul(buf, NULL, 10);
-	if (cfe_getenv("et1mdcport", buf, sizeof(buf)) >= 0)
-		iv->sprom.et1mdcport = simple_strtoul(buf, NULL, 10);
+	sprom->revision = 1;
+	if ((s = nvram_get("il0macaddr")))
+		e_aton(s, sprom->il0mac);
+	if ((s = nvram_get("et0macaddr")))
+		e_aton(s, sprom->et0mac);
+	if ((s = nvram_get("et1macaddr")))
+		e_aton(s, sprom->et1mac);
+	if ((s = nvram_get("et0phyaddr")))
+		sprom->et0phyaddr = simple_strtoul(s, NULL, 0);
+	if ((s = nvram_get("et1phyaddr")))
+		sprom->et1phyaddr = simple_strtoul(s, NULL, 0);
+	if ((s = nvram_get("et0mdcport")))
+		sprom->et0mdcport = !!simple_strtoul(s, NULL, 10);
+	if ((s = nvram_get("et1mdcport")))
+		sprom->et1mdcport = !!simple_strtoul(s, NULL, 10);
+	if ((s = nvram_get("pa0b0")))
+		sprom->pa0b0 = simple_strtoul(s, NULL, 0);
+	if ((s = nvram_get("pa0b1")))
+		sprom->pa0b1 = simple_strtoul(s, NULL, 0);
+	if ((s = nvram_get("pa0b2")))
+		sprom->pa0b2 = simple_strtoul(s, NULL, 0);
+	if ((s = nvram_get("pa1b0")))
+		sprom->pa1b0 = simple_strtoul(s, NULL, 0);
+	if ((s = nvram_get("pa1b1")))
+		sprom->pa1b1 = simple_strtoul(s, NULL, 0);
+	if ((s = nvram_get("pa1b2")))
+		sprom->pa1b2 = simple_strtoul(s, NULL, 0);
+	if ((s = nvram_get("wl0gpio0")))
+		sprom->gpio0 = simple_strtoul(s, NULL, 0);
+	if ((s = nvram_get("wl0gpio1")))
+		sprom->gpio1 = simple_strtoul(s, NULL, 0);
+	if ((s = nvram_get("wl0gpio2")))
+		sprom->gpio2 = simple_strtoul(s, NULL, 0);
+	if ((s = nvram_get("wl0gpio3")))
+		sprom->gpio3 = simple_strtoul(s, NULL, 0);
+	if ((s = nvram_get("pa0maxpwr")))
+		sprom->maxpwr_bg = simple_strtoul(s, NULL, 0);
+	if ((s = nvram_get("pa1maxpwr")))
+		sprom->maxpwr_a = simple_strtoul(s, NULL, 0);
+	if ((s = nvram_get("pa0itssit")))
+		sprom->itssi_bg = simple_strtoul(s, NULL, 0);
+	if ((s = nvram_get("pa1itssit")))
+		sprom->itssi_a = simple_strtoul(s, NULL, 0);
+	sprom->boardflags_lo = 0;
+	if ((s = nvram_get("boardflags")))
+		sprom->boardflags_lo = simple_strtoul(s, NULL, 0);
+	sprom->boardflags_hi = 0;
+	if ((s = nvram_get("boardflags2")))
+		sprom->boardflags_hi = simple_strtoul(s, NULL, 0);
+}
+
+static int bcm47xx_get_invariants(struct ssb_bus *bus, struct ssb_init_invariants *iv)
+{
+	char *s;
+
+	iv->boardinfo.vendor = SSB_BOARDVENDOR_BCM;
+	if ((s = nvram_get("boardtype")))
+		iv->boardinfo.type = (u16)simple_strtoul(s, NULL, 0);
+	if ((s = nvram_get("boardrev")))
+		iv->boardinfo.rev = (u16)simple_strtoul(s, NULL, 0);
+
+	bcm47xx_fill_sprom(&iv->sprom);
+
+	if ((s = nvram_get("cardbus")))
+		iv->has_cardbus_slot = !!simple_strtoul(s, NULL, 10);
 
 	return 0;
 }
 
 void __init plat_mem_setup(void)
 {
-	int err;
+	int i, err;
+	char *s;
+	struct ssb_mipscore *mcore;
+
+	err = ssb_bus_ssbbus_register(&ssb_bcm47xx, SSB_ENUM_BASE, bcm47xx_get_invariants);
+	if (err) {
+		const char *msg = "Failed to initialize SSB bus (err %d)\n";
+		printk(msg, err); /* Make sure the message gets out of the box. */
+		panic(msg, err);
+	}
+	mcore = &ssb_bcm47xx.mipscore;
 
-	err = ssb_bus_ssbbus_register(&ssb_bcm47xx, SSB_ENUM_BASE,
-				      bcm47xx_get_invariants);
-	if (err)
-		panic("Failed to initialize SSB bus (err %d)\n", err);
+	s = nvram_get("kernel_args");
+	if (s && !strncmp(s, "console=ttyS1", 13)) {
+		struct ssb_serial_port port;
+
+		printk("Swapping serial ports!\n");
+		/* swap serial ports */
+		memcpy(&port, &mcore->serial_ports[0], sizeof(port));
+		memcpy(&mcore->serial_ports[0], &mcore->serial_ports[1], sizeof(port));
+		memcpy(&mcore->serial_ports[1], &port, sizeof(port));
+	}
+
+	for (i = 0; i < mcore->nr_serial_ports; i++) {
+		struct ssb_serial_port *port = &(mcore->serial_ports[i]);
+		struct uart_port s;
+
+		memset(&s, 0, sizeof(s));
+		s.line = i;
+		s.mapbase = (unsigned int) port->regs;
+		s.membase = port->regs;
+		s.irq = port->irq + 2;
+		s.uartclk = port->baud_base;
+		s.flags = UPF_BOOT_AUTOCONF | UPF_SHARE_IRQ;
+		s.iotype = SERIAL_IO_MEM;
+		s.regshift = port->reg_shift;
+
+		early_serial_setup(&s);
+	}
+	printk("Serial init done.\n");
 
 	_machine_restart = bcm47xx_machine_restart;
 	_machine_halt = bcm47xx_machine_halt;
 	pm_power_off = bcm47xx_machine_halt;
 }
 
+static int __init bcm47xx_register_gpiodev(void)
+{
+	static struct resource res = {
+		.start = 0xFFFFFFFF,
+	};
+	struct platform_device *pdev;
+
+	pdev = platform_device_register_simple("GPIODEV", 0, &res, 1);
+	if (!pdev) {
+		printk(KERN_ERR "bcm47xx: GPIODEV init failed\n");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+device_initcall(bcm47xx_register_gpiodev);
diff -Nru linux-2.6.30.5/arch/mips/bcm47xx/time.c linux-2.6.30.5-wrt/arch/mips/bcm47xx/time.c
--- linux-2.6.30.5/arch/mips/bcm47xx/time.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/mips/bcm47xx/time.c	2009-09-06 18:48:23.498667592 +0200
@@ -22,11 +22,17 @@
  *  675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-
 #include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/serial_reg.h>
+#include <linux/interrupt.h>
 #include <linux/ssb/ssb.h>
+#include <asm/addrspace.h>
+#include <asm/io.h>
 #include <asm/time.h>
-#include <bcm47xx.h>
+
+extern struct ssb_bus ssb_bcm47xx;
 
 void __init plat_time_init(void)
 {
diff -Nru linux-2.6.30.5/arch/mips/bcm47xx/wgt634u.c linux-2.6.30.5-wrt/arch/mips/bcm47xx/wgt634u.c
--- linux-2.6.30.5/arch/mips/bcm47xx/wgt634u.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/mips/bcm47xx/wgt634u.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,167 +0,0 @@
-/*
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * Copyright (C) 2007 Aurelien Jarno <aurelien@aurel32.net>
- */
-
-#include <linux/platform_device.h>
-#include <linux/module.h>
-#include <linux/leds.h>
-#include <linux/mtd/physmap.h>
-#include <linux/ssb/ssb.h>
-#include <linux/interrupt.h>
-#include <linux/reboot.h>
-#include <linux/gpio.h>
-#include <asm/mach-bcm47xx/bcm47xx.h>
-
-/* GPIO definitions for the WGT634U */
-#define WGT634U_GPIO_LED	3
-#define WGT634U_GPIO_RESET	2
-#define WGT634U_GPIO_TP1	7
-#define WGT634U_GPIO_TP2	6
-#define WGT634U_GPIO_TP3	5
-#define WGT634U_GPIO_TP4	4
-#define WGT634U_GPIO_TP5	1
-
-static struct gpio_led wgt634u_leds[] = {
-	{
-		.name = "power",
-		.gpio = WGT634U_GPIO_LED,
-		.active_low = 1,
-		.default_trigger = "heartbeat",
-	},
-};
-
-static struct gpio_led_platform_data wgt634u_led_data = {
-	.num_leds =     ARRAY_SIZE(wgt634u_leds),
-	.leds =         wgt634u_leds,
-};
-
-static struct platform_device wgt634u_gpio_leds = {
-	.name =         "leds-gpio",
-	.id =           -1,
-	.dev = {
-		.platform_data = &wgt634u_led_data,
-	}
-};
-
-
-/* 8MiB flash. The struct mtd_partition matches original Netgear WGT634U
-   firmware. */
-static struct mtd_partition wgt634u_partitions[] = {
-	{
-		.name       = "cfe",
-		.offset     = 0,
-		.size       = 0x60000,		/* 384k */
-		.mask_flags = MTD_WRITEABLE 	/* force read-only */
-	},
-	{
-		.name   = "config",
-		.offset = 0x60000,
-		.size   = 0x20000		/* 128k */
-	},
-	{
-		.name   = "linux",
-		.offset = 0x80000,
-		.size   = 0x140000 		/* 1280k */
-	},
-	{
-		.name   = "jffs",
-		.offset = 0x1c0000,
-		.size   = 0x620000 		/* 6272k */
-	},
-	{
-		.name   = "nvram",
-		.offset = 0x7e0000,
-		.size   = 0x20000		/* 128k */
-	},
-};
-
-static struct physmap_flash_data wgt634u_flash_data = {
-	.parts    = wgt634u_partitions,
-	.nr_parts = ARRAY_SIZE(wgt634u_partitions)
-};
-
-static struct resource wgt634u_flash_resource = {
-	.flags = IORESOURCE_MEM,
-};
-
-static struct platform_device wgt634u_flash = {
-	.name          = "physmap-flash",
-	.id            = 0,
-	.dev           = { .platform_data = &wgt634u_flash_data, },
-	.resource      = &wgt634u_flash_resource,
-	.num_resources = 1,
-};
-
-/* Platform devices */
-static struct platform_device *wgt634u_devices[] __initdata = {
-	&wgt634u_flash,
-	&wgt634u_gpio_leds,
-};
-
-static irqreturn_t gpio_interrupt(int irq, void *ignored)
-{
-	int state;
-
-	/* Interrupts are shared, check if the current one is
-	   a GPIO interrupt. */
-	if (!ssb_chipco_irq_status(&ssb_bcm47xx.chipco,
-				   SSB_CHIPCO_IRQ_GPIO))
-		return IRQ_NONE;
-
-	state = gpio_get_value(WGT634U_GPIO_RESET);
-
-	/* Interrupt are level triggered, revert the interrupt polarity
-	   to clear the interrupt. */
-	gpio_polarity(WGT634U_GPIO_RESET, state);
-
-	if (!state) {
-		printk(KERN_INFO "Reset button pressed");
-		ctrl_alt_del();
-	}
-
-	return IRQ_HANDLED;
-}
-
-static int __init wgt634u_init(void)
-{
-	/* There is no easy way to detect that we are running on a WGT634U
-	 * machine. Use the MAC address as an heuristic. Netgear Inc. has
-	 * been allocated ranges 00:09:5b:xx:xx:xx and 00:0f:b5:xx:xx:xx.
-	 */
-
-	u8 *et0mac = ssb_bcm47xx.sprom.et0mac;
-
-	if (et0mac[0] == 0x00 &&
-	    ((et0mac[1] == 0x09 && et0mac[2] == 0x5b) ||
-	     (et0mac[1] == 0x0f && et0mac[2] == 0xb5))) {
-		struct ssb_mipscore *mcore = &ssb_bcm47xx.mipscore;
-
-		printk(KERN_INFO "WGT634U machine detected.\n");
-
-		if (!request_irq(gpio_to_irq(WGT634U_GPIO_RESET),
-				 gpio_interrupt, IRQF_SHARED,
-				 "WGT634U GPIO", &ssb_bcm47xx.chipco)) {
-			gpio_direction_input(WGT634U_GPIO_RESET);
-			gpio_intmask(WGT634U_GPIO_RESET, 1);
-			ssb_chipco_irq_mask(&ssb_bcm47xx.chipco,
-					    SSB_CHIPCO_IRQ_GPIO,
-					    SSB_CHIPCO_IRQ_GPIO);
-		}
-
-		wgt634u_flash_data.width = mcore->flash_buswidth;
-		wgt634u_flash_resource.start = mcore->flash_window;
-		wgt634u_flash_resource.end = mcore->flash_window
-					   + mcore->flash_window_size
-					   - 1;
-		return platform_add_devices(wgt634u_devices,
-					    ARRAY_SIZE(wgt634u_devices));
-	} else
-		return -ENODEV;
-}
-
-module_init(wgt634u_init);
-
Binary files linux-2.6.30.5/arch/mips/boot/vmlinux.bin and linux-2.6.30.5-wrt/arch/mips/boot/vmlinux.bin differ
diff -Nru linux-2.6.30.5/arch/mips/include/asm/bootinfo.h linux-2.6.30.5-wrt/arch/mips/include/asm/bootinfo.h
--- linux-2.6.30.5/arch/mips/include/asm/bootinfo.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/mips/include/asm/bootinfo.h	2009-09-06 18:47:53.763209309 +0200
@@ -57,6 +57,12 @@
 #define	MACH_MIKROTIK_RB532	0	/* Mikrotik RouterBoard 532 	*/
 #define MACH_MIKROTIK_RB532A	1	/* Mikrotik RouterBoard 532A 	*/
 
+/*
+ * Valid machtype for group Broadcom
+ */
+#define MACH_GROUP_BRCM		23	/* Broadcom			*/
+#define MACH_BCM47XX		1	/* Broadcom BCM47xx		*/
+
 #define CL_SIZE			COMMAND_LINE_SIZE
 
 extern char *system_type;
diff -Nru linux-2.6.30.5/arch/mips/include/asm/cacheflush.h linux-2.6.30.5-wrt/arch/mips/include/asm/cacheflush.h
--- linux-2.6.30.5/arch/mips/include/asm/cacheflush.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/mips/include/asm/cacheflush.h	2009-09-06 18:47:53.795177672 +0200
@@ -32,7 +32,7 @@
 extern void (*flush_cache_all)(void);
 extern void (*__flush_cache_all)(void);
 extern void (*flush_cache_mm)(struct mm_struct *mm);
-#define flush_cache_dup_mm(mm)	do { (void) (mm); } while (0)
+#define flush_cache_dup_mm(mm) flush_cache_mm(mm)
 extern void (*flush_cache_range)(struct vm_area_struct *vma,
 	unsigned long start, unsigned long end);
 extern void (*flush_cache_page)(struct vm_area_struct *vma, unsigned long page, unsigned long pfn);
diff -Nru linux-2.6.30.5/arch/mips/include/asm/cpu-features.h linux-2.6.30.5-wrt/arch/mips/include/asm/cpu-features.h
--- linux-2.6.30.5/arch/mips/include/asm/cpu-features.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/mips/include/asm/cpu-features.h	2009-09-06 18:47:53.779200423 +0200
@@ -104,6 +104,9 @@
 #ifndef cpu_has_pindexed_dcache
 #define cpu_has_pindexed_dcache	(cpu_data[0].dcache.flags & MIPS_CACHE_PINDEX)
 #endif
+#ifndef cpu_use_kmap_coherent
+#define cpu_use_kmap_coherent 1
+#endif
 
 /*
  * I-Cache snoops remote store.  This only matters on SMP.  Some multiprocessors
diff -Nru linux-2.6.30.5/arch/mips/include/asm/mach-bcm47xx/cpu-feature-overrides.h linux-2.6.30.5-wrt/arch/mips/include/asm/mach-bcm47xx/cpu-feature-overrides.h
--- linux-2.6.30.5/arch/mips/include/asm/mach-bcm47xx/cpu-feature-overrides.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/arch/mips/include/asm/mach-bcm47xx/cpu-feature-overrides.h	2009-09-06 18:47:53.783167392 +0200
@@ -0,0 +1,13 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
+ */
+#ifndef __ASM_MACH_BCM47XX_CPU_FEATURE_OVERRIDES_H
+#define __ASM_MACH_BCM47XX_CPU_FEATURE_OVERRIDES_H
+
+#define cpu_use_kmap_coherent	0
+
+#endif /* __ASM_MACH_BCM47XX_CPU_FEATURE_OVERRIDES_H */
diff -Nru linux-2.6.30.5/arch/mips/include/asm/mach-bcm47xx/kernel-entry-init.h linux-2.6.30.5-wrt/arch/mips/include/asm/mach-bcm47xx/kernel-entry-init.h
--- linux-2.6.30.5/arch/mips/include/asm/mach-bcm47xx/kernel-entry-init.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/arch/mips/include/asm/mach-bcm47xx/kernel-entry-init.h	2009-09-06 18:48:09.942698957 +0200
@@ -0,0 +1,26 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2005 Embedded Alley Solutions, Inc
+ * Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
+ * Copyright (C) 2006 Michael Buesch
+ */
+#ifndef __ASM_MACH_GENERIC_KERNEL_ENTRY_H
+#define __ASM_MACH_GENERIC_KERNEL_ENTRY_H
+
+/* Intentionally empty macro, used in head.S. Override in
+ * arch/mips/mach-xxx/kernel-entry-init.h when necessary.
+ */
+	.macro	kernel_entry_setup
+	.endm
+
+/*
+ * Do SMP slave processor setup necessary before we can savely execute C code.
+ */
+	.macro	smp_slave_setup
+	.endm
+
+
+#endif /* __ASM_MACH_GENERIC_KERNEL_ENTRY_H */
diff -Nru linux-2.6.30.5/arch/mips/include/asm/module.h linux-2.6.30.5-wrt/arch/mips/include/asm/module.h
--- linux-2.6.30.5/arch/mips/include/asm/module.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/mips/include/asm/module.h	2009-09-06 18:43:48.330678898 +0200
@@ -9,6 +9,11 @@
 	struct list_head dbe_list;
 	const struct exception_table_entry *dbe_start;
 	const struct exception_table_entry *dbe_end;
+
+	void *plt_tbl;
+	unsigned int core_plt_offset;
+	unsigned int core_plt_size;
+	unsigned int init_plt_offset;
 };
 
 typedef uint8_t Elf64_Byte;		/* Type for a 8-bit quantity.  */
diff -Nru linux-2.6.30.5/arch/mips/include/asm/page.h linux-2.6.30.5-wrt/arch/mips/include/asm/page.h
--- linux-2.6.30.5/arch/mips/include/asm/page.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/mips/include/asm/page.h	2009-09-06 18:47:53.803168255 +0200
@@ -35,6 +35,7 @@
 #ifndef __ASSEMBLY__
 
 #include <linux/pfn.h>
+#include <asm/cpu-features.h>
 #include <asm/io.h>
 
 extern void build_clear_page(void);
@@ -70,13 +71,16 @@
 		flush_data_cache_page((unsigned long)addr);
 }
 
-extern void copy_user_page(void *vto, void *vfrom, unsigned long vaddr,
-	struct page *to);
-struct vm_area_struct;
-extern void copy_user_highpage(struct page *to, struct page *from,
-	unsigned long vaddr, struct vm_area_struct *vma);
+static inline void copy_user_page(void *vto, void *vfrom, unsigned long vaddr,
+	struct page *to)
+{
+	extern void (*flush_data_cache_page)(unsigned long addr);
 
-#define __HAVE_ARCH_COPY_USER_HIGHPAGE
+	copy_page(vto, vfrom);
+	if (!cpu_has_ic_fills_f_dc ||
+	    pages_do_alias((unsigned long)vto, vaddr & PAGE_MASK))
+		flush_data_cache_page((unsigned long)vto);
+}
 
 /*
  * These are used to make use of C type-checking..
diff -Nru linux-2.6.30.5/arch/mips/include/asm/r4kcache.h linux-2.6.30.5-wrt/arch/mips/include/asm/r4kcache.h
--- linux-2.6.30.5/arch/mips/include/asm/r4kcache.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/mips/include/asm/r4kcache.h	2009-09-06 18:48:23.530699264 +0200
@@ -17,6 +17,35 @@
 #include <asm/cpu-features.h>
 #include <asm/mipsmtregs.h>
 
+#ifdef CONFIG_BCM47XX
+#include <asm/paccess.h>
+#include <linux/ssb/ssb.h>
+#define BCM4710_DUMMY_RREG() bcm4710_dummy_rreg()
+
+static inline unsigned long bcm4710_dummy_rreg(void) {
+      return (*(volatile unsigned long *)(KSEG1ADDR(SSB_ENUM_BASE + SSB_IMSTATE)));
+}
+
+#define BCM4710_FILL_TLB(addr) bcm4710_fill_tlb((void*)(addr))
+
+static inline unsigned long bcm4710_fill_tlb(void *addr) {
+      return (*(unsigned long *)addr);
+}
+
+#define BCM4710_PROTECTED_FILL_TLB(addr) bcm4710_protected_fill_tlb((void*)(addr))
+
+static inline void bcm4710_protected_fill_tlb(void *addr) {
+      unsigned long x;
+      get_dbe(x, (unsigned long *)addr);;
+}
+
+#else
+#define BCM4710_DUMMY_RREG()
+
+#define BCM4710_FILL_TLB(addr)
+#define BCM4710_PROTECTED_FILL_TLB(addr)
+#endif
+
 /*
  * This macro return a properly sign-extended address suitable as base address
  * for indexed cache operations.  Two issues here:
@@ -150,6 +179,7 @@
 static inline void flush_dcache_line_indexed(unsigned long addr)
 {
 	__dflush_prologue
+	BCM4710_DUMMY_RREG();
 	cache_op(Index_Writeback_Inv_D, addr);
 	__dflush_epilogue
 }
@@ -169,6 +199,7 @@
 static inline void flush_dcache_line(unsigned long addr)
 {
 	__dflush_prologue
+	BCM4710_DUMMY_RREG();
 	cache_op(Hit_Writeback_Inv_D, addr);
 	__dflush_epilogue
 }
@@ -176,6 +207,7 @@
 static inline void invalidate_dcache_line(unsigned long addr)
 {
 	__dflush_prologue
+	BCM4710_DUMMY_RREG();
 	cache_op(Hit_Invalidate_D, addr);
 	__dflush_epilogue
 }
@@ -208,6 +240,7 @@
  */
 static inline void protected_flush_icache_line(unsigned long addr)
 {
+	BCM4710_DUMMY_RREG();
 	protected_cache_op(Hit_Invalidate_I, addr);
 }
 
@@ -219,6 +252,7 @@
  */
 static inline void protected_writeback_dcache_line(unsigned long addr)
 {
+	BCM4710_DUMMY_RREG();
 	protected_cache_op(Hit_Writeback_Inv_D, addr);
 }
 
@@ -339,8 +373,52 @@
 		: "r" (base),						\
 		  "i" (op));
 
+static inline void blast_dcache(void)
+{
+	unsigned long start = KSEG0;
+	unsigned long dcache_size = current_cpu_data.dcache.waysize * current_cpu_data.dcache.ways;
+	unsigned long end = (start + dcache_size);
+
+	do {
+		BCM4710_DUMMY_RREG();
+		cache_op(Index_Writeback_Inv_D, start);
+		start += current_cpu_data.dcache.linesz;
+	} while(start < end);
+}
+
+static inline void blast_dcache_page(unsigned long page)
+{
+	unsigned long start = page;
+	unsigned long end = start + PAGE_SIZE;
+
+	BCM4710_FILL_TLB(start);
+	do {
+		BCM4710_DUMMY_RREG();
+		cache_op(Hit_Writeback_Inv_D, start);
+		start += current_cpu_data.dcache.linesz;
+	} while(start < end);
+}
+
+static inline void blast_dcache_page_indexed(unsigned long page)
+{
+	unsigned long start = page;
+	unsigned long end = start + PAGE_SIZE;
+	unsigned long ws_inc = 1UL << current_cpu_data.dcache.waybit;
+	unsigned long ws_end = current_cpu_data.dcache.ways <<
+	                       current_cpu_data.dcache.waybit;
+	unsigned long ws, addr;
+	for (ws = 0; ws < ws_end; ws += ws_inc) {
+		start = page + ws;
+		for (addr = start; addr < end; addr += current_cpu_data.dcache.linesz) {
+			BCM4710_DUMMY_RREG();
+			cache_op(Index_Writeback_Inv_D, addr);
+		}
+	}
+}
+
+
 /* build blast_xxx, blast_xxx_page, blast_xxx_page_indexed */
-#define __BUILD_BLAST_CACHE(pfx, desc, indexop, hitop, lsize) \
+#define __BUILD_BLAST_CACHE(pfx, desc, indexop, hitop, lsize, war) \
 static inline void blast_##pfx##cache##lsize(void)			\
 {									\
 	unsigned long start = INDEX_BASE;				\
@@ -352,6 +430,7 @@
 									\
 	__##pfx##flush_prologue						\
 									\
+	war								\
 	for (ws = 0; ws < ws_end; ws += ws_inc)				\
 		for (addr = start; addr < end; addr += lsize * 32)	\
 			cache##lsize##_unroll32(addr|ws, indexop);	\
@@ -366,6 +445,7 @@
 									\
 	__##pfx##flush_prologue						\
 									\
+	war								\
 	do {								\
 		cache##lsize##_unroll32(start, hitop);			\
 		start += lsize * 32;					\
@@ -384,6 +464,8 @@
 	                       current_cpu_data.desc.waybit;		\
 	unsigned long ws, addr;						\
 									\
+	war								\
+									\
 	__##pfx##flush_prologue						\
 									\
 	for (ws = 0; ws < ws_end; ws += ws_inc)				\
@@ -393,35 +475,37 @@
 	__##pfx##flush_epilogue						\
 }
 
-__BUILD_BLAST_CACHE(d, dcache, Index_Writeback_Inv_D, Hit_Writeback_Inv_D, 16)
-__BUILD_BLAST_CACHE(i, icache, Index_Invalidate_I, Hit_Invalidate_I, 16)
-__BUILD_BLAST_CACHE(s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 16)
-__BUILD_BLAST_CACHE(d, dcache, Index_Writeback_Inv_D, Hit_Writeback_Inv_D, 32)
-__BUILD_BLAST_CACHE(i, icache, Index_Invalidate_I, Hit_Invalidate_I, 32)
-__BUILD_BLAST_CACHE(s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 32)
-__BUILD_BLAST_CACHE(i, icache, Index_Invalidate_I, Hit_Invalidate_I, 64)
-__BUILD_BLAST_CACHE(s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 64)
-__BUILD_BLAST_CACHE(s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 128)
-
-__BUILD_BLAST_CACHE(inv_d, dcache, Index_Writeback_Inv_D, Hit_Invalidate_D, 16)
-__BUILD_BLAST_CACHE(inv_d, dcache, Index_Writeback_Inv_D, Hit_Invalidate_D, 32)
-__BUILD_BLAST_CACHE(inv_s, scache, Index_Writeback_Inv_SD, Hit_Invalidate_SD, 16)
-__BUILD_BLAST_CACHE(inv_s, scache, Index_Writeback_Inv_SD, Hit_Invalidate_SD, 32)
-__BUILD_BLAST_CACHE(inv_s, scache, Index_Writeback_Inv_SD, Hit_Invalidate_SD, 64)
-__BUILD_BLAST_CACHE(inv_s, scache, Index_Writeback_Inv_SD, Hit_Invalidate_SD, 128)
+__BUILD_BLAST_CACHE(d, dcache, Index_Writeback_Inv_D, Hit_Writeback_Inv_D, 16, )
+__BUILD_BLAST_CACHE(i, icache, Index_Invalidate_I, Hit_Invalidate_I, 16, BCM4710_FILL_TLB(start);)
+__BUILD_BLAST_CACHE(s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 16, )
+__BUILD_BLAST_CACHE(d, dcache, Index_Writeback_Inv_D, Hit_Writeback_Inv_D, 32, )
+__BUILD_BLAST_CACHE(i, icache, Index_Invalidate_I, Hit_Invalidate_I, 32, BCM4710_FILL_TLB(start);)
+__BUILD_BLAST_CACHE(s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 32, )
+__BUILD_BLAST_CACHE(i, icache, Index_Invalidate_I, Hit_Invalidate_I, 64, BCM4710_FILL_TLB(start);)
+__BUILD_BLAST_CACHE(s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 64, )
+__BUILD_BLAST_CACHE(s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 128, )
+
+__BUILD_BLAST_CACHE(inv_d, dcache, Index_Writeback_Inv_D, Hit_Invalidate_D, 16, )
+__BUILD_BLAST_CACHE(inv_d, dcache, Index_Writeback_Inv_D, Hit_Invalidate_D, 32, )
+__BUILD_BLAST_CACHE(inv_s, scache, Index_Writeback_Inv_SD, Hit_Invalidate_SD, 16, )
+__BUILD_BLAST_CACHE(inv_s, scache, Index_Writeback_Inv_SD, Hit_Invalidate_SD, 32, )
+__BUILD_BLAST_CACHE(inv_s, scache, Index_Writeback_Inv_SD, Hit_Invalidate_SD, 64, )
+__BUILD_BLAST_CACHE(inv_s, scache, Index_Writeback_Inv_SD, Hit_Invalidate_SD, 128, )
 
 /* build blast_xxx_range, protected_blast_xxx_range */
-#define __BUILD_BLAST_CACHE_RANGE(pfx, desc, hitop, prot) \
+#define __BUILD_BLAST_CACHE_RANGE(pfx, desc, hitop, prot, war, war2) \
 static inline void prot##blast_##pfx##cache##_range(unsigned long start, \
 						    unsigned long end)	\
 {									\
 	unsigned long lsize = cpu_##desc##_line_size();			\
 	unsigned long addr = start & ~(lsize - 1);			\
 	unsigned long aend = (end - 1) & ~(lsize - 1);			\
+	war								\
 									\
 	__##pfx##flush_prologue						\
 									\
 	while (1) {							\
+		war2						\
 		prot##cache_op(hitop, addr);				\
 		if (addr == aend)					\
 			break;						\
@@ -431,13 +515,13 @@
 	__##pfx##flush_epilogue						\
 }
 
-__BUILD_BLAST_CACHE_RANGE(d, dcache, Hit_Writeback_Inv_D, protected_)
-__BUILD_BLAST_CACHE_RANGE(s, scache, Hit_Writeback_Inv_SD, protected_)
-__BUILD_BLAST_CACHE_RANGE(i, icache, Hit_Invalidate_I, protected_)
-__BUILD_BLAST_CACHE_RANGE(d, dcache, Hit_Writeback_Inv_D, )
-__BUILD_BLAST_CACHE_RANGE(s, scache, Hit_Writeback_Inv_SD, )
+__BUILD_BLAST_CACHE_RANGE(d, dcache, Hit_Writeback_Inv_D, protected_, BCM4710_PROTECTED_FILL_TLB(addr); BCM4710_PROTECTED_FILL_TLB(aend);, BCM4710_DUMMY_RREG();)
+__BUILD_BLAST_CACHE_RANGE(s, scache, Hit_Writeback_Inv_SD, protected_,, )
+__BUILD_BLAST_CACHE_RANGE(i, icache, Hit_Invalidate_I, protected_,, )
+__BUILD_BLAST_CACHE_RANGE(d, dcache, Hit_Writeback_Inv_D,, BCM4710_FILL_TLB(addr); BCM4710_FILL_TLB(aend);, BCM4710_DUMMY_RREG();)
+__BUILD_BLAST_CACHE_RANGE(s, scache, Hit_Writeback_Inv_SD,,, )
 /* blast_inv_dcache_range */
-__BUILD_BLAST_CACHE_RANGE(inv_d, dcache, Hit_Invalidate_D, )
-__BUILD_BLAST_CACHE_RANGE(inv_s, scache, Hit_Invalidate_SD, )
+__BUILD_BLAST_CACHE_RANGE(inv_d, dcache, Hit_Invalidate_D,,,BCM4710_DUMMY_RREG();)
+__BUILD_BLAST_CACHE_RANGE(inv_s, scache, Hit_Invalidate_SD,,, )
 
 #endif /* _ASM_R4KCACHE_H */
diff -Nru linux-2.6.30.5/arch/mips/include/asm/stackframe.h linux-2.6.30.5-wrt/arch/mips/include/asm/stackframe.h
--- linux-2.6.30.5/arch/mips/include/asm/stackframe.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/mips/include/asm/stackframe.h	2009-09-06 18:47:53.779200423 +0200
@@ -426,6 +426,10 @@
 		.macro	RESTORE_SP_AND_RET
 		LONG_L	sp, PT_R29(sp)
 		.set	mips3
+#ifdef CONFIG_BCM47XX
+		nop
+		nop
+#endif
 		eret
 		.set	mips0
 		.endm
diff -Nru linux-2.6.30.5/arch/mips/include/asm/system.h linux-2.6.30.5-wrt/arch/mips/include/asm/system.h
--- linux-2.6.30.5/arch/mips/include/asm/system.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/mips/include/asm/system.h	2009-09-06 18:43:48.314668017 +0200
@@ -187,7 +187,7 @@
    if something tries to do an invalid xchg().  */
 extern void __xchg_called_with_bad_pointer(void);
 
-static inline unsigned long __xchg(unsigned long x, volatile void * ptr, int size)
+static __always_inline unsigned long __xchg(unsigned long x, volatile void * ptr, int size)
 {
 	switch (size) {
 	case 4:
diff -Nru linux-2.6.30.5/arch/mips/kernel/Makefile linux-2.6.30.5-wrt/arch/mips/kernel/Makefile
--- linux-2.6.30.5/arch/mips/kernel/Makefile	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/mips/kernel/Makefile	2009-09-06 18:43:48.322739724 +0200
@@ -85,6 +85,7 @@
 
 obj-$(CONFIG_KEXEC)		+= machine_kexec.o relocate_kernel.o
 obj-$(CONFIG_EARLY_PRINTK)	+= early_printk.o
+obj-$(CONFIG_MIPS_MACHINE)	+= mips_machine.o
 
 CFLAGS_cpu-bugs64.o	= $(shell if $(CC) $(KBUILD_CFLAGS) -Wa,-mdaddi -c -o /dev/null -xc /dev/null >/dev/null 2>&1; then echo "-DHAVE_AS_SET_DADDI"; fi)
 
diff -Nru linux-2.6.30.5/arch/mips/kernel/cpu-probe.c linux-2.6.30.5-wrt/arch/mips/kernel/cpu-probe.c
--- linux-2.6.30.5/arch/mips/kernel/cpu-probe.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/mips/kernel/cpu-probe.c	2009-09-06 18:47:53.775177530 +0200
@@ -753,6 +753,8 @@
 	case PRID_IMP_25KF:
 		c->cputype = CPU_25KF;
 		__cpu_name[cpu] = "MIPS 25Kc";
+		/* Probe for L2 cache */
+		c->scache.flags &= ~MIPS_CACHE_NOT_PRESENT;
 		break;
 	case PRID_IMP_34K:
 		c->cputype = CPU_34K;
diff -Nru linux-2.6.30.5/arch/mips/kernel/genex.S linux-2.6.30.5-wrt/arch/mips/kernel/genex.S
--- linux-2.6.30.5/arch/mips/kernel/genex.S	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/mips/kernel/genex.S	2009-09-06 18:48:23.530699264 +0200
@@ -22,6 +22,19 @@
 #include <asm/page.h>
 #include <asm/thread_info.h>
 
+#ifdef CONFIG_BCM47XX
+# ifdef eret
+#  undef eret
+# endif
+# define eret 					\
+	.set push;				\
+	.set noreorder;				\
+	 nop; 					\
+	 nop;					\
+	 eret;					\
+	.set pop;
+#endif
+
 #define PANIC_PIC(msg)					\
 		.set push;				\
 		.set	reorder;			\
@@ -52,6 +65,9 @@
 NESTED(except_vec3_generic, 0, sp)
 	.set	push
 	.set	noat
+#ifdef CONFIG_BCM47XX
+	nop
+#endif
 #if R5432_CP0_INTERRUPT_WAR
 	mfc0	k0, CP0_INDEX
 #endif
@@ -75,6 +91,9 @@
 	.set	push
 	.set	mips3
 	.set	noat
+#ifdef CONFIG_BCM47XX
+	nop
+#endif
 	mfc0	k1, CP0_CAUSE
 	li	k0, 31<<2
 	andi	k1, k1, 0x7c
diff -Nru linux-2.6.30.5/arch/mips/kernel/head.S linux-2.6.30.5-wrt/arch/mips/kernel/head.S
--- linux-2.6.30.5/arch/mips/kernel/head.S	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/mips/kernel/head.S	2009-09-06 18:43:48.326698829 +0200
@@ -121,6 +121,8 @@
 #endif
 	.endm
 
+	j kernel_entry
+	nop
 #ifndef CONFIG_NO_EXCEPT_FILL
 	/*
 	 * Reserved space for exception handlers.
@@ -141,6 +143,15 @@
 	j	kernel_entry
 #endif
 
+#ifdef CONFIG_PROM_EMU
+EXPORT(prom_emu_argv)
+	.word	0
+	.word	prom_emu_cmdline
+	.ascii	"CMDLINE:"
+EXPORT(prom_emu_cmdline)
+	.fill	0x400
+#endif
+
 	__REF
 
 NESTED(kernel_entry, 16, sp)			# kernel entry point
@@ -181,6 +192,19 @@
 	LONG_S		zero, (t0)
 	bne		t0, t1, 1b
 
+#ifdef CONFIG_PROM_EMU
+	PTR_LA		t0, prom_emu_cmdline
+	LONG_L		t1, 0(t0)
+	beqz		t1, 1f
+
+	li		a0, 2
+	PTR_LA		a1, prom_emu_argv
+	move		a2, zero
+	move		a3, zero
+
+1:
+#endif /* CONFIG_PROM_EMU */
+
 	LONG_S		a0, fw_arg0		# firmware arguments
 	LONG_S		a1, fw_arg1
 	LONG_S		a2, fw_arg2
diff -Nru linux-2.6.30.5/arch/mips/kernel/mips_machine.c linux-2.6.30.5-wrt/arch/mips/kernel/mips_machine.c
--- linux-2.6.30.5/arch/mips/kernel/mips_machine.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/arch/mips/kernel/mips_machine.c	2009-09-06 18:43:48.322739724 +0200
@@ -0,0 +1,70 @@
+/*
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ */
+#include <linux/mm.h>
+
+#include <asm/mips_machine.h>
+#include <asm/bootinfo.h>
+
+static struct list_head mips_machines __initdata =
+		LIST_HEAD_INIT(mips_machines);
+
+char *mips_machine_name = "Unknown";
+
+static struct mips_machine * __init mips_machine_find(unsigned long machtype)
+{
+	struct list_head *this;
+
+	list_for_each(this, &mips_machines) {
+		struct mips_machine *mach;
+
+		mach = list_entry(this, struct mips_machine, list);
+		if (mach->mach_type == machtype)
+			return mach;
+	}
+
+	return NULL;
+}
+
+void __init mips_machine_register(struct mips_machine *mach)
+{
+	list_add_tail(&mach->list, &mips_machines);
+}
+
+void __init mips_machine_setup(unsigned long machtype)
+{
+	struct mips_machine *mach;
+
+	mach = mips_machine_find(machtype);
+	if (!mach) {
+		printk(KERN_ALERT "MIPS: no machine registered for "
+			"machtype %lu\n", machtype);
+		return;
+	}
+
+	if (mach->mach_name) {
+		char *name;
+		unsigned int len;
+
+		len = strlen(mach->mach_name);
+		name = kmalloc(len + 1, GFP_KERNEL);
+		if (name) {
+			strncpy(name, mach->mach_name,len);
+			name[len] = '\0';
+			mips_machine_name = name;
+		} else {
+			printk(KERN_WARNING "MIPS: no memory for machine_name\n");
+		}
+	}
+
+	printk(KERN_INFO "MIPS: machine is %s\n", mips_machine_name);
+
+	if (mach->mach_setup)
+		mach->mach_setup();
+}
+
diff -Nru linux-2.6.30.5/arch/mips/kernel/module.c linux-2.6.30.5-wrt/arch/mips/kernel/module.c
--- linux-2.6.30.5/arch/mips/kernel/module.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/mips/kernel/module.c	2009-09-06 18:43:48.330678898 +0200
@@ -43,6 +43,116 @@
 static LIST_HEAD(dbe_list);
 static DEFINE_SPINLOCK(dbe_lock);
 
+/*
+ * Get the potential max trampolines size required of the init and
+ * non-init sections. Only used if we cannot find enough contiguous
+ * physically mapped memory to put the module into.
+ */
+static unsigned int
+get_plt_size(const Elf_Ehdr *hdr, const Elf_Shdr *sechdrs,
+             const char *secstrings, unsigned int symindex, bool is_init)
+{
+	unsigned long ret = 0;
+	unsigned int i, j;
+	Elf_Sym *syms;
+
+	/* Everything marked ALLOC (this includes the exported symbols) */
+	for (i = 1; i < hdr->e_shnum; ++i) {
+		unsigned int info = sechdrs[i].sh_info;
+
+		if (sechdrs[i].sh_type != SHT_REL
+		    && sechdrs[i].sh_type != SHT_RELA)
+			continue;
+
+		/* Not a valid relocation section? */
+		if (info >= hdr->e_shnum)
+			continue;
+
+		/* Don't bother with non-allocated sections */
+		if (!(sechdrs[info].sh_flags & SHF_ALLOC))
+			continue;
+
+		/* If it's called *.init*, and we're not init, we're
+                   not interested */
+		if ((strstr(secstrings + sechdrs[i].sh_name, ".init") != 0)
+		    != is_init)
+			continue;
+
+		syms = (Elf_Sym *) sechdrs[symindex].sh_addr;
+		if (sechdrs[i].sh_type == SHT_REL) {
+			Elf_Mips_Rel *rel = (void *) sechdrs[i].sh_addr;
+			unsigned int size = sechdrs[i].sh_size / sizeof(*rel);
+
+			for (j = 0; j < size; ++j) {
+				Elf_Sym *sym;
+
+				if (ELF_MIPS_R_TYPE(rel[j]) != R_MIPS_26)
+					continue;
+
+				sym = syms + ELF_MIPS_R_SYM(rel[j]);
+				if (!is_init && sym->st_shndx != SHN_UNDEF)
+					continue;
+
+				ret += 4 * sizeof(int);
+			}
+		} else {
+			Elf_Mips_Rela *rela = (void *) sechdrs[i].sh_addr;
+			unsigned int size = sechdrs[i].sh_size / sizeof(*rela);
+
+			for (j = 0; j < size; ++j) {
+				Elf_Sym *sym;
+
+				if (ELF_MIPS_R_TYPE(rela[j]) != R_MIPS_26)
+					continue;
+
+				sym = syms + ELF_MIPS_R_SYM(rela[j]);
+				if (!is_init && sym->st_shndx != SHN_UNDEF)
+					continue;
+
+				ret += 4 * sizeof(int);
+			}
+		}
+	}
+
+	return ret;
+}
+
+#ifndef MODULE_START
+static void *alloc_phys(unsigned long size)
+{
+	unsigned order;
+	struct page *page;
+	struct page *p;
+
+	size = PAGE_ALIGN(size);
+	order = get_order(size);
+
+	page = alloc_pages(GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN |
+			__GFP_THISNODE, order);
+	if (!page)
+		return NULL;
+
+	split_page(page, order);
+
+	for (p = page + (size >> PAGE_SHIFT); p < page + (1 << order); ++p)
+		__free_page(p);
+
+	return page_address(page);
+}
+#endif
+
+static void free_phys(void *ptr, unsigned long size)
+{
+	struct page *page;
+	struct page *end;
+
+	page = virt_to_page(ptr);
+	end = page + (PAGE_ALIGN(size) >> PAGE_SHIFT);
+
+	for (; page < end; ++page)
+		__free_page(page);
+}
+
 void *module_alloc(unsigned long size)
 {
 #ifdef MODULE_START
@@ -58,16 +168,45 @@
 
 	return __vmalloc_area(area, GFP_KERNEL, PAGE_KERNEL);
 #else
+	void *ptr;
+
 	if (size == 0)
 		return NULL;
-	return vmalloc(size);
+
+	ptr = alloc_phys(size);
+
+	/* If we failed to allocate physically contiguous memory,
+	 * fall back to regular vmalloc. The module loader code will
+	 * create jump tables to handle long jumps */
+	if (!ptr)
+		return vmalloc(size);
+
+	return ptr;
+#endif
+}
+
+static inline bool is_phys_addr(void *ptr)
+{
+#ifdef CONFIG_64BIT
+	return (KSEGX((unsigned long)ptr) == CKSEG0);
+#else
+	return (KSEGX(ptr) == KSEG0);
 #endif
 }
 
 /* Free memory returned from module_alloc */
 void module_free(struct module *mod, void *module_region)
 {
-	vfree(module_region);
+	if (is_phys_addr(module_region)) {
+		if (mod->module_init == module_region)
+			free_phys(module_region, mod->init_size);
+		else if (mod->module_core == module_region)
+			free_phys(module_region, mod->core_size);
+		else
+			BUG();
+	} else {
+		vfree(module_region);
+	}
 	/* FIXME: If module_region == mod->init_region, trim exception
            table entries. */
 }
@@ -75,6 +214,24 @@
 int module_frob_arch_sections(Elf_Ehdr *hdr, Elf_Shdr *sechdrs,
 			      char *secstrings, struct module *mod)
 {
+	unsigned int symindex = 0;
+	unsigned int core_size, init_size;
+	int i;
+
+	for (i = 1; i < hdr->e_shnum; i++)
+		if (sechdrs[i].sh_type == SHT_SYMTAB)
+			symindex = i;
+
+	core_size = get_plt_size(hdr, sechdrs, secstrings, symindex, false);
+	init_size = get_plt_size(hdr, sechdrs, secstrings, symindex, true);
+
+	mod->arch.core_plt_offset = 0;
+	mod->arch.core_plt_size = core_size;
+	mod->arch.init_plt_offset = core_size;
+	mod->arch.plt_tbl = kmalloc(core_size + init_size, GFP_KERNEL);
+	if (!mod->arch.plt_tbl)
+		return -ENOMEM;
+
 	return 0;
 }
 
@@ -97,27 +254,41 @@
 	return 0;
 }
 
-static int apply_r_mips_26_rel(struct module *me, u32 *location, Elf_Addr v)
+static Elf_Addr add_plt_entry_to(unsigned *plt_offset,
+				 void *start, Elf_Addr v)
 {
-	if (v % 4) {
-		printk(KERN_ERR "module %s: dangerous relocation\n", me->name);
-		return -ENOEXEC;
-	}
+	unsigned *tramp = start + *plt_offset;
 
-	if ((v & 0xf0000000) != (((unsigned long)location + 4) & 0xf0000000)) {
-		printk(KERN_ERR
-		       "module %s: relocation overflow\n",
-		       me->name);
-		return -ENOEXEC;
-	}
+	*plt_offset += 4 * sizeof(int);
+
+	/* adjust carry for addiu */
+	if (v & 0x00008000)
+		v += 0x10000;
+
+	tramp[0] = 0x3c190000 | (v >> 16);      /* lui t9, hi16 */
+	tramp[1] = 0x27390000 | (v & 0xffff);   /* addiu t9, t9, lo16 */
+	tramp[2] = 0x03200008;                  /* jr t9 */
+	tramp[3] = 0x00000000;                  /* nop */
 
-	*location = (*location & ~0x03ffffff) |
-	            ((*location + (v >> 2)) & 0x03ffffff);
+	return (Elf_Addr) tramp;
+}
+
+static Elf_Addr add_plt_entry(struct module *me, void *location, Elf_Addr v)
+{
+	if (location >= me->module_core &&
+	    location < me->module_core + me->core_size)
+		return add_plt_entry_to(&me->arch.core_plt_offset,
+				me->arch.plt_tbl, v);
+
+	if (location >= me->module_init &&
+	    location < me->module_init + me->init_size)
+		return add_plt_entry_to(&me->arch.init_plt_offset,
+				me->arch.plt_tbl, v);
 
 	return 0;
 }
 
-static int apply_r_mips_26_rela(struct module *me, u32 *location, Elf_Addr v)
+static int set_r_mips_26(struct module *me, u32 *location, u32 ofs, Elf_Addr v)
 {
 	if (v % 4) {
 		printk(KERN_ERR "module %s: dangerous relocation\n", me->name);
@@ -125,17 +296,31 @@
 	}
 
 	if ((v & 0xf0000000) != (((unsigned long)location + 4) & 0xf0000000)) {
-		printk(KERN_ERR
+	    v = add_plt_entry(me, location, v + (ofs << 2));
+		if (!v) {
+			printk(KERN_ERR
 		       "module %s: relocation overflow\n",
 		       me->name);
-		return -ENOEXEC;
+			return -ENOEXEC;
+		}
+		ofs = 0;
 	}
 
-	*location = (*location & ~0x03ffffff) | ((v >> 2) & 0x03ffffff);
+	*location = (*location & ~0x03ffffff) | ((ofs + (v >> 2)) & 0x03ffffff);
 
 	return 0;
 }
 
+static int apply_r_mips_26_rel(struct module *me, u32 *location, Elf_Addr v)
+{
+	return set_r_mips_26(me, location, *location & 0x03ffffff, v);
+}
+
+static int apply_r_mips_26_rela(struct module *me, u32 *location, Elf_Addr v)
+{
+	return set_r_mips_26(me, location, 0, v);
+}
+
 static int apply_r_mips_hi16_rel(struct module *me, u32 *location, Elf_Addr v)
 {
 	struct mips_hi16 *n;
@@ -303,7 +488,7 @@
 		/* This is the symbol it is referring to */
 		sym = (Elf_Sym *)sechdrs[symindex].sh_addr
 			+ ELF_MIPS_R_SYM(rel[i]);
-		if (!sym->st_value) {
+		if (IS_ERR_VALUE(sym->st_value)) {
 			/* Ignore unresolved weak symbol */
 			if (ELF_ST_BIND(sym->st_info) == STB_WEAK)
 				continue;
@@ -343,7 +528,7 @@
 		/* This is the symbol it is referring to */
 		sym = (Elf_Sym *)sechdrs[symindex].sh_addr
 			+ ELF_MIPS_R_SYM(rel[i]);
-		if (!sym->st_value) {
+		if (IS_ERR_VALUE(sym->st_value)) {
 			/* Ignore unresolved weak symbol */
 			if (ELF_ST_BIND(sym->st_info) == STB_WEAK)
 				continue;
@@ -400,11 +585,23 @@
 		list_add(&me->arch.dbe_list, &dbe_list);
 		spin_unlock_irq(&dbe_lock);
 	}
+
+	/* Get rid of the fixup trampoline if we're running the module
+	 * from physically mapped address space */
+	if (me->arch.core_plt_offset == 0 &&
+	    me->arch.init_plt_offset == me->arch.core_plt_size &&
+	    is_phys_addr(me->module_core)) {
+		kfree(me->arch.plt_tbl);
+		me->arch.plt_tbl = NULL;
+	}
+
 	return 0;
 }
 
 void module_arch_cleanup(struct module *mod)
 {
+	if (mod->arch.plt_tbl)
+		kfree(mod->arch.plt_tbl);
 	spin_lock_irq(&dbe_lock);
 	list_del(&mod->arch.dbe_list);
 	spin_unlock_irq(&dbe_lock);
diff -Nru linux-2.6.30.5/arch/mips/kernel/proc.c linux-2.6.30.5-wrt/arch/mips/kernel/proc.c
--- linux-2.6.30.5/arch/mips/kernel/proc.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/mips/kernel/proc.c	2009-09-06 18:43:48.322739724 +0200
@@ -14,6 +14,7 @@
 #include <asm/cpu-features.h>
 #include <asm/mipsregs.h>
 #include <asm/processor.h>
+#include <asm/mips_machine.h>
 
 unsigned int vced_count, vcei_count;
 
@@ -33,8 +34,12 @@
 	/*
 	 * For the first processor also print the system type
 	 */
-	if (n == 0)
+	if (n == 0) {
 		seq_printf(m, "system type\t\t: %s\n", get_system_type());
+#ifdef CONFIG_MIPS_MACHINE
+		seq_printf(m, "machine\t\t\t: %s\n", mips_machine_name);
+#endif
+	}
 
 	seq_printf(m, "processor\t\t: %ld\n", n);
 	sprintf(fmt, "cpu model\t\t: %%s V%%d.%%d%s\n",
diff -Nru linux-2.6.30.5/arch/mips/kernel/vmlinux.lds linux-2.6.30.5-wrt/arch/mips/kernel/vmlinux.lds
--- linux-2.6.30.5/arch/mips/kernel/vmlinux.lds	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/arch/mips/kernel/vmlinux.lds	2009-09-06 19:40:31.916193953 +0200
@@ -0,0 +1,240 @@
+
+
+/*
+ * Automatically generated C config: don't edit
+ * Linux kernel version: 2.6.30.5
+ * Sun Sep  6 19:40:22 2009
+ */
+/*
+ * DO NOT MODIFY.
+ *
+ * This file was generated by Kbuild
+ *
+ */
+/* MIPS pt_regs offsets. */
+/* MIPS task_struct offsets. */
+/* MIPS thread_info offsets. */
+/* MIPS specific thread_struct offsets. */
+/* Size of struct page */
+/* Linux mm_struct offsets. */
+/* Linux sigcontext offsets. */
+/* Linux signal numbers. */
+/* Linux irq_cpustat_t offsets. */
+/* Align . to a 8 byte boundary equals to maximum function alignment. */
+/* The actual configuration determine if the init/exit sections
+ * are handled as text/data or they can be discarded (which
+ * often happens at runtime)
+ */
+/* .data section */
+/* RODATA provided for backward compatibility.
+ * All archs are supposed to use RO_DATA() */
+/* .text section. Map to function alignment to avoid address changes
+ * during second ld run in second ld pass when generating System.map */
+/* sched.text is aling to function alignment to secure we have same
+ * address even at second ld pass when generating System.map */
+/* spinlock.text is aling to function alignment to secure we have same
+ * address even at second ld pass when generating System.map */
+/* Section used for early init (in .S files) */
+/* init and exit section handling */
+  /* DWARF debug sections.
+		Symbols in the DWARF debugging sections are relative to
+		the beginning of the section so we begin them at 0.  */
+  /* Stabs debugging sections.  */
+/**
+ * PERCPU_VADDR - define output section for percpu area
+ * @vaddr: explicit base address (optional)
+ * @phdr: destination PHDR (optional)
+ *
+ * Macro which expands to output section for percpu area.  If @vaddr
+ * is not blank, it specifies explicit base address and all percpu
+ * symbols will be offset from the given address.  If blank, @vaddr
+ * always equals @laddr + LOAD_OFFSET.
+ *
+ * @phdr defines the output PHDR to use if not blank.  Be warned that
+ * output PHDR is sticky.  If @phdr is specified, the next output
+ * section in the linker script will go there too.  @phdr should have
+ * a leading colon.
+ *
+ * Note that this macros defines __per_cpu_load as an absolute symbol.
+ * If there is no need to put the percpu section at a predetermined
+ * address, use PERCPU().
+ */
+/**
+ * PERCPU - define output section for percpu area, simple version
+ * @align: required alignment
+ *
+ * Align to @align and outputs output section for percpu area.  This
+ * macro doesn't maniuplate @vaddr or @phdr and __per_cpu_load and
+ * __per_cpu_start will be identical.
+ *
+ * This macro is equivalent to ALIGN(align); PERCPU_VADDR( , ) except
+ * that __per_cpu_load is defined as a relative symbol against
+ * .data.percpu which is required for relocatable x86_32
+ * configuration.
+ */
+OUTPUT_ARCH(mips)
+ENTRY(kernel_entry)
+PHDRS {
+ text PT_LOAD FLAGS(7); /* RWX */
+ note PT_NOTE FLAGS(4); /* R__ */
+}
+jiffies = jiffies_64;
+SECTIONS
+{
+ . = 0xffffffff80001000;
+ /* read-only */
+ _text = .; /* Text and read-only data */
+ .text : {
+  . = ALIGN(8); *(.text.hot) *(.text) *(.ref.text) *(.devinit.text) *(.devexit.text) *(.text.unlikely)
+  . = ALIGN(8); __sched_text_start = .; *(.sched.text) __sched_text_end = .;
+  . = ALIGN(8); __lock_text_start = .; *(.spinlock.text) __lock_text_end = .;
+  . = ALIGN(8); __kprobes_text_start = .; *(.kprobes.text) __kprobes_text_end = .;
+  *(.text.*)
+  *(.fixup)
+  *(.gnu.warning)
+ } :text = 0
+ _etext = .; /* End of text section */
+ /* Exception table */
+ . = ALIGN(16);
+ __ex_table : {
+  __start___ex_table = .;
+  *(__ex_table)
+  __stop___ex_table = .;
+ }
+ /* Exception table for data bus errors */
+ __dbe_table : {
+  __start___dbe_table = .;
+  *(__dbe_table)
+  __stop___dbe_table = .;
+ }
+ .notes : AT(ADDR(.notes) - 0) { __start_notes = .; *(.note.*) __stop_notes = .; } :text :note
+ .dummy : { *(.dummy) } :text
+ . = ALIGN((4096)); .rodata : AT(ADDR(.rodata) - 0) { __start_rodata = .; *(.rodata) *(.rodata.*) *(__vermagic) *(__markers_strings) *(__tracepoints_strings) } .rodata1 : AT(ADDR(.rodata1) - 0) { *(.rodata1) } .pci_fixup : AT(ADDR(.pci_fixup) - 0) { __start_pci_fixups_early = .; *(.pci_fixup_early) __end_pci_fixups_early = .; __start_pci_fixups_header = .; *(.pci_fixup_header) __end_pci_fixups_header = .; __start_pci_fixups_final = .; *(.pci_fixup_final) __end_pci_fixups_final = .; __start_pci_fixups_enable = .; *(.pci_fixup_enable) __end_pci_fixups_enable = .; __start_pci_fixups_resume = .; *(.pci_fixup_resume) __end_pci_fixups_resume = .; __start_pci_fixups_resume_early = .; *(.pci_fixup_resume_early) __end_pci_fixups_resume_early = .; __start_pci_fixups_suspend = .; *(.pci_fixup_suspend) __end_pci_fixups_suspend = .; } .builtin_fw : AT(ADDR(.builtin_fw) - 0) { __start_builtin_fw = .; *(.builtin_fw) __end_builtin_fw = .; } .rio_route : AT(ADDR(.rio_route) - 0) { __start_rio_route_ops = .; *(.rio_route_ops) __end_rio_route_ops = .; } __ksymtab : AT(ADDR(__ksymtab) - 0) { __start___ksymtab = .; *(__ksymtab.*) __stop___ksymtab = .; } __ksymtab_gpl : AT(ADDR(__ksymtab_gpl) - 0) { __start___ksymtab_gpl = .; *(__ksymtab_gpl.*) __stop___ksymtab_gpl = .; } __ksymtab_unused : AT(ADDR(__ksymtab_unused) - 0) { __start___ksymtab_unused = .; *(__ksymtab_unused.*) __stop___ksymtab_unused = .; } __ksymtab_unused_gpl : AT(ADDR(__ksymtab_unused_gpl) - 0) { __start___ksymtab_unused_gpl = .; *(__ksymtab_unused_gpl.*) __stop___ksymtab_unused_gpl = .; } __ksymtab_gpl_future : AT(ADDR(__ksymtab_gpl_future) - 0) { __start___ksymtab_gpl_future = .; *(__ksymtab_gpl_future.*) __stop___ksymtab_gpl_future = .; } __kcrctab : AT(ADDR(__kcrctab) - 0) { __start___kcrctab = .; *(__kcrctab) __stop___kcrctab = .; } __kcrctab_gpl : AT(ADDR(__kcrctab_gpl) - 0) { __start___kcrctab_gpl = .; *(__kcrctab_gpl) __stop___kcrctab_gpl = .; } __kcrctab_unused : AT(ADDR(__kcrctab_unused) - 0) { __start___kcrctab_unused = .; *(__kcrctab_unused) __stop___kcrctab_unused = .; } __kcrctab_unused_gpl : AT(ADDR(__kcrctab_unused_gpl) - 0) { __start___kcrctab_unused_gpl = .; *(__kcrctab_unused_gpl) __stop___kcrctab_unused_gpl = .; } __kcrctab_gpl_future : AT(ADDR(__kcrctab_gpl_future) - 0) { __start___kcrctab_gpl_future = .; *(__kcrctab_gpl_future) __stop___kcrctab_gpl_future = .; } __ksymtab_strings : AT(ADDR(__ksymtab_strings) - 0) { *(__ksymtab_strings.*) } /DISCARD/ : { } __init_rodata : AT(ADDR(__init_rodata) - 0) { *(.ref.rodata) *(.devinit.rodata) *(.devexit.rodata) } __param : AT(ADDR(__param) - 0) { __start___param = .; *(__param) __stop___param = .; . = ALIGN((4096)); __end_rodata = .; } . = ALIGN((4096));
+ /* writeable */
+ .data : { /* Data */
+  . = . + 0; /* for CONFIG_MAPPED_KERNEL */
+  /*
+		 * This ALIGN is needed as a workaround for a bug a
+		 * gcc bug upto 4.1 which limits the maximum alignment
+		 * to at most 32kB and results in the following
+		 * warning:
+		 *
+		 *  CC      arch/mips/kernel/init_task.o
+		 * arch/mips/kernel/init_task.c:30: warning: alignment
+		 * of ‘init_thread_union’ is greater than maximum
+		 * object file alignment.  Using 32768
+		 */
+  . = ALIGN(4096);
+  *(.data.init_task)
+  *(.data) *(.ref.data) *(.devinit.data) *(.devexit.data) . = ALIGN(8); __start___markers = .; *(__markers) __stop___markers = .; . = ALIGN(32); __start___tracepoints = .; *(__tracepoints) __stop___tracepoints = .; . = ALIGN(8); __start___verbose = .; *(__verbose) __stop___verbose = .;
+  CONSTRUCTORS
+ }
+ _gp = . + 0x8000;
+ .lit8 : {
+  *(.lit8)
+ }
+ .lit4 : {
+  *(.lit4)
+ }
+ /* We want the small data sections together, so single-instruction offsets
+	   can access them all, and initialized data all before uninitialized, so
+	   we can shorten the on-disk segment size.  */
+ .sdata : {
+  *(.sdata)
+ }
+ . = ALIGN(4096);
+ .data_nosave : {
+  __nosave_begin = .;
+  *(.data.nosave)
+ }
+ . = ALIGN(4096);
+ __nosave_end = .;
+ . = ALIGN(1 << 5);
+ .data.cacheline_aligned : {
+  *(.data.cacheline_aligned)
+ }
+ _edata = .; /* End of data section */
+ /* will be freed after init */
+ . = ALIGN(4096); /* Init code and data */
+ __init_begin = .;
+ .init.text : {
+  _sinittext = .;
+  *(.init.text) *(.cpuinit.text) *(.meminit.text)
+  _einittext = .;
+ }
+ .init.data : {
+  *(.init.data) *(.cpuinit.data) *(.cpuinit.rodata) *(.meminit.data) *(.meminit.rodata)
+ }
+ . = ALIGN(16);
+ .init.setup : {
+  __setup_start = .;
+  *(.init.setup)
+  __setup_end = .;
+ }
+ .initcall.init : {
+  __initcall_start = .;
+  *(.initcallearly.init) __early_initcall_end = .; *(.initcall0.init) *(.initcall0s.init) *(.initcall1.init) *(.initcall1s.init) *(.initcall2.init) *(.initcall2s.init) *(.initcall3.init) *(.initcall3s.init) *(.initcall4.init) *(.initcall4s.init) *(.initcall5.init) *(.initcall5s.init) *(.initcallrootfs.init) *(.initcall6.init) *(.initcall6s.init) *(.initcall7.init) *(.initcall7s.init)
+  __initcall_end = .;
+ }
+ .con_initcall.init : {
+  __con_initcall_start = .;
+  *(.con_initcall.init)
+  __con_initcall_end = .;
+ }
+ .security_initcall.init : AT(ADDR(.security_initcall.init) - 0) { __security_initcall_start = .; *(.security_initcall.init) __security_initcall_end = .; }
+ /* .exit.text is discarded at runtime, not link time, to deal with
+	 * references from .rodata
+	 */
+ .exit.text : {
+  *(.exit.text) *(.cpuexit.text) *(.memexit.text)
+ }
+ .exit.data : {
+  *(.exit.data) *(.cpuexit.data) *(.cpuexit.rodata) *(.memexit.data) *(.memexit.rodata)
+ }
+ . = ALIGN(4096); .data.percpu : AT(ADDR(.data.percpu) - 0) { __per_cpu_load = .; __per_cpu_start = .; *(.data.percpu.first) *(.data.percpu.page_aligned) *(.data.percpu) *(.data.percpu.shared_aligned) __per_cpu_end = .; }
+ . = ALIGN(4096);
+ __init_end = .;
+ /* freed after init ends here */
+ __bss_start = .; /* BSS */
+ .sbss : {
+  *(.sbss)
+  *(.scommon)
+ }
+ .bss : {
+  *(.bss)
+  *(COMMON)
+ }
+ __bss_stop = .;
+ _end = . ;
+ /* Sections to be discarded */
+ /DISCARD/ : {
+  *(.exitcall.exit)
+  /* ABI crap starts here */
+  *(.MIPS.options)
+  *(.options)
+  *(.pdr)
+  *(.reginfo)
+ }
+ /* These mark the ABI of the kernel for debuggers.  */
+ .mdebug.abi32 : {
+  KEEP(*(.mdebug.abi32))
+ }
+ .mdebug.abi64 : {
+  KEEP(*(.mdebug.abi64))
+ }
+ /* This is the MIPS specific mdebug section.  */
+ .mdebug : {
+  *(.mdebug)
+ }
+ .stab 0 : { *(.stab) } .stabstr 0 : { *(.stabstr) } .stab.excl 0 : { *(.stab.excl) } .stab.exclstr 0 : { *(.stab.exclstr) } .stab.index 0 : { *(.stab.index) } .stab.indexstr 0 : { *(.stab.indexstr) } .comment 0 : { *(.comment) }
+ .debug 0 : { *(.debug) } .line 0 : { *(.line) } .debug_srcinfo 0 : { *(.debug_srcinfo) } .debug_sfnames 0 : { *(.debug_sfnames) } .debug_aranges 0 : { *(.debug_aranges) } .debug_pubnames 0 : { *(.debug_pubnames) } .debug_info 0 : { *(.debug_info .gnu.linkonce.wi.*) } .debug_abbrev 0 : { *(.debug_abbrev) } .debug_line 0 : { *(.debug_line) } .debug_frame 0 : { *(.debug_frame) } .debug_str 0 : { *(.debug_str) } .debug_loc 0 : { *(.debug_loc) } .debug_macinfo 0 : { *(.debug_macinfo) } .debug_weaknames 0 : { *(.debug_weaknames) } .debug_funcnames 0 : { *(.debug_funcnames) } .debug_typenames 0 : { *(.debug_typenames) } .debug_varnames 0 : { *(.debug_varnames) }
+ /* These must appear regardless of  .  */
+ .gptab.sdata : {
+  *(.gptab.data)
+  *(.gptab.sdata)
+ }
+ .gptab.sbss : {
+  *(.gptab.bss)
+  *(.gptab.sbss)
+ }
+}
diff -Nru linux-2.6.30.5/arch/mips/lib/delay.c linux-2.6.30.5-wrt/arch/mips/lib/delay.c
--- linux-2.6.30.5/arch/mips/lib/delay.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/mips/lib/delay.c	2009-09-06 18:43:48.326698829 +0200
@@ -43,7 +43,7 @@
 {
 	unsigned int lpj = current_cpu_data.udelay_val;
 
-	__delay((us * 0x000010c7 * HZ * lpj) >> 32);
+	__delay((us * 0x000010c7ull * HZ * lpj) >> 32);
 }
 EXPORT_SYMBOL(__udelay);
 
@@ -51,6 +51,6 @@
 {
 	unsigned int lpj = current_cpu_data.udelay_val;
 
-	__delay((us * 0x00000005 * HZ * lpj) >> 32);
+	__delay((ns * 0x00000005ull * HZ * lpj) >> 32);
 }
 EXPORT_SYMBOL(__ndelay);
diff -Nru linux-2.6.30.5/arch/mips/math-emu/Makefile linux-2.6.30.5-wrt/arch/mips/math-emu/Makefile
--- linux-2.6.30.5/arch/mips/math-emu/Makefile	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/mips/math-emu/Makefile	2009-09-06 18:43:48.326698829 +0200
@@ -2,12 +2,14 @@
 # Makefile for the Linux/MIPS kernel FPU emulation.
 #
 
-obj-y	:= cp1emu.o ieee754m.o ieee754d.o ieee754dp.o ieee754sp.o ieee754.o \
+obj-y	:=	kernel_linkage.o dsemul.o cp1emu.o
+
+obj-$(CONFIG_MIPS_FPU_EMU)	+= ieee754m.o ieee754d.o ieee754dp.o ieee754sp.o ieee754.o \
 	   ieee754xcpt.o dp_frexp.o dp_modf.o dp_div.o dp_mul.o dp_sub.o \
 	   dp_add.o dp_fsp.o dp_cmp.o dp_logb.o dp_scalb.o dp_simple.o \
 	   dp_tint.o dp_fint.o dp_tlong.o dp_flong.o sp_frexp.o sp_modf.o \
 	   sp_div.o sp_mul.o sp_sub.o sp_add.o sp_fdp.o sp_cmp.o sp_logb.o \
 	   sp_scalb.o sp_simple.o sp_tint.o sp_fint.o sp_tlong.o sp_flong.o \
-	   dp_sqrt.o sp_sqrt.o kernel_linkage.o dsemul.o
+	   dp_sqrt.o sp_sqrt.o
 
 EXTRA_CFLAGS += -Werror
diff -Nru linux-2.6.30.5/arch/mips/math-emu/cp1emu.c linux-2.6.30.5-wrt/arch/mips/math-emu/cp1emu.c
--- linux-2.6.30.5/arch/mips/math-emu/cp1emu.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/mips/math-emu/cp1emu.c	2009-09-06 18:43:48.330678898 +0200
@@ -56,6 +56,12 @@
 #endif
 #define __mips 4
 
+/* Further private data for which no space exists in mips_fpu_struct */
+
+struct mips_fpu_emulator_stats fpuemustats;
+
+#ifdef CONFIG_MIPS_FPU_EMU
+
 /* Function which emulates a floating point instruction. */
 
 static int fpu_emu(struct pt_regs *, struct mips_fpu_struct *,
@@ -66,10 +72,6 @@
 	struct mips_fpu_struct *, mips_instruction);
 #endif
 
-/* Further private data for which no space exists in mips_fpu_struct */
-
-struct mips_fpu_emulator_stats fpuemustats;
-
 /* Control registers */
 
 #define FPCREG_RID	0	/* $0  = revision id */
@@ -1273,6 +1275,13 @@
 
 	return sig;
 }
+#else
+int fpu_emulator_cop1Handler(struct pt_regs *xcp, struct mips_fpu_struct *ctx,
+        int has_fpu)
+{
+	return 0;
+}
+#endif /* CONFIG_MIPS_FPU_EMU */
 
 #ifdef CONFIG_DEBUG_FS
 extern struct dentry *mips_debugfs_dir;
diff -Nru linux-2.6.30.5/arch/mips/math-emu/dsemul.c linux-2.6.30.5-wrt/arch/mips/math-emu/dsemul.c
--- linux-2.6.30.5/arch/mips/math-emu/dsemul.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/mips/math-emu/dsemul.c	2009-09-06 18:43:48.330678898 +0200
@@ -109,6 +109,7 @@
 	return SIGILL;		/* force out of emulation loop */
 }
 
+#ifdef CONFIG_MIPS_FPU_EMU
 int do_dsemulret(struct pt_regs *xcp)
 {
 	struct emuframe __user *fr;
@@ -165,3 +166,9 @@
 
 	return 1;
 }
+#else
+int do_dsemulret(struct pt_regs *xcp)
+{
+	return 0;
+}
+#endif /* CONFIG_MIPS_FPU_EMU */
diff -Nru linux-2.6.30.5/arch/mips/math-emu/kernel_linkage.c linux-2.6.30.5-wrt/arch/mips/math-emu/kernel_linkage.c
--- linux-2.6.30.5/arch/mips/math-emu/kernel_linkage.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/mips/math-emu/kernel_linkage.c	2009-09-06 18:43:48.330678898 +0200
@@ -29,6 +29,7 @@
 
 #define SIGNALLING_NAN 0x7ff800007ff80000LL
 
+#ifdef CONFIG_MIPS_FPU_EMU
 void fpu_emulator_init_fpu(void)
 {
 	static int first = 1;
@@ -112,4 +113,34 @@
 
 	return err;
 }
-#endif
+#endif	/* CONFIG_64BIT */
+#else
+
+void fpu_emulator_init_fpu(void)
+{
+	return;
+}
+
+int fpu_emulator_save_context(struct sigcontext __user *sc)
+{
+	return 0;
+}
+
+int fpu_emulator_restore_context(struct sigcontext __user *sc)
+{
+	return 0;
+}
+
+int fpu_emulator_save_context32(struct sigcontext32 __user *sc)
+{
+	return 0;
+}
+
+int fpu_emulator_restore_context32(struct sigcontext32 __user *sc)
+{
+	return 0;
+}
+
+#ifdef CONFIG_64BIT
+#endif	/* CONFIG_64BIT */
+#endif /* CONFIG_MIPS_FPU_EMU */
diff -Nru linux-2.6.30.5/arch/mips/mm/Makefile linux-2.6.30.5-wrt/arch/mips/mm/Makefile
--- linux-2.6.30.5/arch/mips/mm/Makefile	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/mips/mm/Makefile	2009-09-06 18:47:53.775177530 +0200
@@ -32,6 +32,5 @@
 obj-$(CONFIG_IP22_CPU_SCACHE)	+= sc-ip22.o
 obj-$(CONFIG_R5000_CPU_SCACHE)  += sc-r5k.o
 obj-$(CONFIG_RM7000_CPU_SCACHE)	+= sc-rm7k.o
-obj-$(CONFIG_MIPS_CPU_SCACHE)	+= sc-mips.o
 
 EXTRA_CFLAGS += -Werror
diff -Nru linux-2.6.30.5/arch/mips/mm/c-r4k.c linux-2.6.30.5-wrt/arch/mips/mm/c-r4k.c
--- linux-2.6.30.5/arch/mips/mm/c-r4k.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/mips/mm/c-r4k.c	2009-09-06 18:47:53.799166514 +0200
@@ -34,6 +34,9 @@
 #include <asm/cacheflush.h> /* for run_uncached() */
 
 
+/* For enabling BCM4710 cache workarounds */
+int bcm4710 = 0;
+
 /*
  * Special Variant of smp_call_function for use by cache functions:
  *
@@ -104,6 +107,9 @@
 {
 	unsigned long  dc_lsize = cpu_dcache_line_size();
 
+	if (bcm4710)
+		r4k_blast_dcache_page = blast_dcache_page;
+	else
 	if (dc_lsize == 0)
 		r4k_blast_dcache_page = (void *)cache_noop;
 	else if (dc_lsize == 16)
@@ -118,6 +124,9 @@
 {
 	unsigned long dc_lsize = cpu_dcache_line_size();
 
+	if (bcm4710)
+		r4k_blast_dcache_page_indexed = blast_dcache_page_indexed;
+	else
 	if (dc_lsize == 0)
 		r4k_blast_dcache_page_indexed = (void *)cache_noop;
 	else if (dc_lsize == 16)
@@ -132,6 +141,9 @@
 {
 	unsigned long dc_lsize = cpu_dcache_line_size();
 
+	if (bcm4710)
+		r4k_blast_dcache = blast_dcache;
+	else
 	if (dc_lsize == 0)
 		r4k_blast_dcache = (void *)cache_noop;
 	else if (dc_lsize == 16)
@@ -348,7 +360,7 @@
 	}
 }
 
-static void r4k___flush_cache_all(void)
+void r4k___flush_cache_all(void)
 {
 	r4k_on_each_cpu(local_r4k___flush_cache_all, NULL, 1);
 }
@@ -482,7 +494,7 @@
 		 */
 		map_coherent = (cpu_has_dc_aliases &&
 				page_mapped(page) && !Page_dcache_dirty(page));
-		if (map_coherent)
+		if (map_coherent && cpu_use_kmap_coherent)
 			vaddr = kmap_coherent(page, addr);
 		else
 			vaddr = kmap_atomic(page, KM_USER0);
@@ -505,14 +517,14 @@
 	}
 
 	if (vaddr) {
-		if (map_coherent)
+		if (map_coherent && cpu_use_kmap_coherent)
 			kunmap_coherent();
 		else
 			kunmap_atomic(vaddr, KM_USER0);
 	}
 }
 
-static void r4k_flush_cache_page(struct vm_area_struct *vma,
+void r4k_flush_cache_page(struct vm_area_struct *vma,
 	unsigned long addr, unsigned long pfn)
 {
 	struct flush_cache_page_args args;
@@ -667,6 +679,8 @@
 	unsigned long addr = (unsigned long) arg;
 
 	R4600_HIT_CACHEOP_WAR_IMPL;
+	BCM4710_PROTECTED_FILL_TLB(addr);
+	BCM4710_PROTECTED_FILL_TLB(addr + 4);
 	if (dc_lsize)
 		protected_writeback_dcache_line(addr & ~(dc_lsize - 1));
 	if (!cpu_icache_snoops_remote_store && scache_size)
@@ -1135,7 +1149,6 @@
 
 extern int r5k_sc_init(void);
 extern int rm7k_sc_init(void);
-extern int mips_sc_init(void);
 
 static void __cpuinit setup_scache(void)
 {
@@ -1189,29 +1202,17 @@
 #endif
 
 	default:
-		if (c->isa_level == MIPS_CPU_ISA_M32R1 ||
-		    c->isa_level == MIPS_CPU_ISA_M32R2 ||
-		    c->isa_level == MIPS_CPU_ISA_M64R1 ||
-		    c->isa_level == MIPS_CPU_ISA_M64R2) {
-#ifdef CONFIG_MIPS_CPU_SCACHE
-			if (mips_sc_init ()) {
-				scache_size = c->scache.ways * c->scache.sets * c->scache.linesz;
-				printk("MIPS secondary cache %ldkB, %s, linesize %d bytes.\n",
-				       scache_size >> 10,
-				       way_string[c->scache.ways], c->scache.linesz);
-			}
-#else
-			if (!(c->scache.flags & MIPS_CACHE_NOT_PRESENT))
-				panic("Dunno how to handle MIPS32 / MIPS64 second level cache");
-#endif
-			return;
-		}
 		sc_present = 0;
 	}
 
 	if (!sc_present)
 		return;
 
+	if ((c->isa_level == MIPS_CPU_ISA_M32R1 ||
+	     c->isa_level == MIPS_CPU_ISA_M64R1) &&
+	    !(c->scache.flags & MIPS_CACHE_NOT_PRESENT))
+		panic("Dunno how to handle MIPS32 / MIPS64 second level cache");
+
 	/* compute a couple of other cache variables */
 	c->scache.waysize = scache_size / c->scache.ways;
 
@@ -1298,6 +1299,17 @@
 	 * silly idea of putting something else there ...
 	 */
 	switch (current_cpu_type()) {
+	case CPU_BCM3302:
+		{
+			u32 cm;
+			cm = read_c0_diag();
+			/* Enable icache */
+			cm |= (1 << 31);
+			/* Enable dcache */
+			cm |= (1 << 30);
+			write_c0_diag(cm);
+		}
+		break;
 	case CPU_R4000PC:
 	case CPU_R4000SC:
 	case CPU_R4000MC:
@@ -1354,6 +1366,15 @@
 		break;
 	}
 
+	/* Check if special workarounds are required */
+#ifdef CONFIG_BCM47XX
+	if (current_cpu_data.cputype == CPU_BCM4710 && (current_cpu_data.processor_id & 0xff) == 0) {
+		printk("Enabling BCM4710A0 cache workarounds.\n");
+		bcm4710 = 1;
+	} else
+#endif
+		bcm4710 = 0;
+
 	probe_pcache();
 	setup_scache();
 
@@ -1412,5 +1433,20 @@
 #if !defined(CONFIG_MIPS_CMP)
 	local_r4k___flush_cache_all(NULL);
 #endif
+#ifdef CONFIG_BCM47XX
+	{
+		static void (*_coherency_setup)(void);
+		_coherency_setup = (void (*)(void)) KSEG1ADDR(coherency_setup);
+		_coherency_setup();
+	}
+#else
 	coherency_setup();
+#endif
 }
+
+// fuse package DCACHE BUG patch exports
+void (*fuse_flush_cache_all)(void) = r4k___flush_cache_all;
+void (*fuse_flush_cache_page)(struct vm_area_struct *vma, unsigned long page,
+        unsigned long pfn) = r4k_flush_cache_page;
+EXPORT_SYMBOL(fuse_flush_cache_page);
+EXPORT_SYMBOL(fuse_flush_cache_all);
diff -Nru linux-2.6.30.5/arch/mips/mm/init.c linux-2.6.30.5-wrt/arch/mips/mm/init.c
--- linux-2.6.30.5/arch/mips/mm/init.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/mips/mm/init.c	2009-09-06 18:48:23.480167069 +0200
@@ -198,35 +198,11 @@
 	preempt_check_resched();
 }
 
-void copy_user_highpage(struct page *to, struct page *from,
-	unsigned long vaddr, struct vm_area_struct *vma)
-{
-	void *vfrom, *vto;
-
-	vto = kmap_atomic(to, KM_USER1);
-	if (cpu_has_dc_aliases &&
-	    page_mapped(from) && !Page_dcache_dirty(from)) {
-		vfrom = kmap_coherent(from, vaddr);
-		copy_page(vto, vfrom);
-		kunmap_coherent();
-	} else {
-		vfrom = kmap_atomic(from, KM_USER0);
-		copy_page(vto, vfrom);
-		kunmap_atomic(vfrom, KM_USER0);
-	}
-	if ((!cpu_has_ic_fills_f_dc) ||
-	    pages_do_alias((unsigned long)vto, vaddr & PAGE_MASK))
-		flush_data_cache_page((unsigned long)vto);
-	kunmap_atomic(vto, KM_USER1);
-	/* Make sure this page is cleared on other CPU's too before using it */
-	smp_wmb();
-}
-
 void copy_to_user_page(struct vm_area_struct *vma,
 	struct page *page, unsigned long vaddr, void *dst, const void *src,
 	unsigned long len)
 {
-	if (cpu_has_dc_aliases &&
+	if (cpu_has_dc_aliases && cpu_use_kmap_coherent &&
 	    page_mapped(page) && !Page_dcache_dirty(page)) {
 		void *vto = kmap_coherent(page, vaddr) + (vaddr & ~PAGE_MASK);
 		memcpy(vto, src, len);
@@ -244,7 +220,7 @@
 	struct page *page, unsigned long vaddr, void *dst, const void *src,
 	unsigned long len)
 {
-	if (cpu_has_dc_aliases &&
+	if (cpu_has_dc_aliases && cpu_use_kmap_coherent &&
 	    page_mapped(page) && !Page_dcache_dirty(page)) {
 		void *vfrom = kmap_coherent(page, vaddr) + (vaddr & ~PAGE_MASK);
 		memcpy(dst, vfrom, len);
diff -Nru linux-2.6.30.5/arch/mips/mm/init.c.orig linux-2.6.30.5-wrt/arch/mips/mm/init.c.orig
--- linux-2.6.30.5/arch/mips/mm/init.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/arch/mips/mm/init.c.orig	2009-09-06 18:47:53.803168255 +0200
@@ -0,0 +1,458 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1994 - 2000 Ralf Baechle
+ * Copyright (C) 1999, 2000 Silicon Graphics, Inc.
+ * Kevin D. Kissell, kevink@mips.com and Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
+ */
+#include <linux/bug.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/pagemap.h>
+#include <linux/ptrace.h>
+#include <linux/mman.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+#include <linux/highmem.h>
+#include <linux/swap.h>
+#include <linux/proc_fs.h>
+#include <linux/pfn.h>
+
+#include <asm/asm-offsets.h>
+#include <asm/bootinfo.h>
+#include <asm/cachectl.h>
+#include <asm/cpu.h>
+#include <asm/dma.h>
+#include <asm/kmap_types.h>
+#include <asm/mmu_context.h>
+#include <asm/sections.h>
+#include <asm/pgtable.h>
+#include <asm/pgalloc.h>
+#include <asm/tlb.h>
+#include <asm/fixmap.h>
+
+/* Atomicity and interruptability */
+#ifdef CONFIG_MIPS_MT_SMTC
+
+#include <asm/mipsmtregs.h>
+
+#define ENTER_CRITICAL(flags) \
+	{ \
+	unsigned int mvpflags; \
+	local_irq_save(flags);\
+	mvpflags = dvpe()
+#define EXIT_CRITICAL(flags) \
+	evpe(mvpflags); \
+	local_irq_restore(flags); \
+	}
+#else
+
+#define ENTER_CRITICAL(flags) local_irq_save(flags)
+#define EXIT_CRITICAL(flags) local_irq_restore(flags)
+
+#endif /* CONFIG_MIPS_MT_SMTC */
+
+DEFINE_PER_CPU(struct mmu_gather, mmu_gathers);
+
+/*
+ * We have up to 8 empty zeroed pages so we can map one of the right colour
+ * when needed.  This is necessary only on R4000 / R4400 SC and MC versions
+ * where we have to avoid VCED / VECI exceptions for good performance at
+ * any price.  Since page is never written to after the initialization we
+ * don't have to care about aliases on other CPUs.
+ */
+unsigned long empty_zero_page, zero_page_mask;
+EXPORT_SYMBOL_GPL(empty_zero_page);
+
+/*
+ * Not static inline because used by IP27 special magic initialization code
+ */
+unsigned long setup_zero_pages(void)
+{
+	unsigned int order;
+	unsigned long size;
+	struct page *page;
+
+	if (cpu_has_vce)
+		order = 3;
+	else
+		order = 0;
+
+	empty_zero_page = __get_free_pages(GFP_KERNEL | __GFP_ZERO, order);
+	if (!empty_zero_page)
+		panic("Oh boy, that early out of memory?");
+
+	page = virt_to_page((void *)empty_zero_page);
+	split_page(page, order);
+	while (page < virt_to_page((void *)(empty_zero_page + (PAGE_SIZE << order)))) {
+		SetPageReserved(page);
+		page++;
+	}
+
+	size = PAGE_SIZE << order;
+	zero_page_mask = (size - 1) & PAGE_MASK;
+
+	return 1UL << order;
+}
+
+#ifdef CONFIG_MIPS_MT_SMTC
+static pte_t *kmap_coherent_pte;
+static void __init kmap_coherent_init(void)
+{
+	unsigned long vaddr;
+
+	/* cache the first coherent kmap pte */
+	vaddr = __fix_to_virt(FIX_CMAP_BEGIN);
+	kmap_coherent_pte = kmap_get_fixmap_pte(vaddr);
+}
+#else
+static inline void kmap_coherent_init(void) {}
+#endif
+
+void *kmap_coherent(struct page *page, unsigned long addr)
+{
+	enum fixed_addresses idx;
+	unsigned long vaddr, flags, entrylo;
+	unsigned long old_ctx;
+	pte_t pte;
+	int tlbidx;
+
+	BUG_ON(Page_dcache_dirty(page));
+
+	inc_preempt_count();
+	idx = (addr >> PAGE_SHIFT) & (FIX_N_COLOURS - 1);
+#ifdef CONFIG_MIPS_MT_SMTC
+	idx += FIX_N_COLOURS * smp_processor_id();
+#endif
+	vaddr = __fix_to_virt(FIX_CMAP_END - idx);
+	pte = mk_pte(page, PAGE_KERNEL);
+#if defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_CPU_MIPS32)
+	entrylo = pte.pte_high;
+#else
+	entrylo = pte_val(pte) >> 6;
+#endif
+
+	ENTER_CRITICAL(flags);
+	old_ctx = read_c0_entryhi();
+	write_c0_entryhi(vaddr & (PAGE_MASK << 1));
+	write_c0_entrylo0(entrylo);
+	write_c0_entrylo1(entrylo);
+#ifdef CONFIG_MIPS_MT_SMTC
+	set_pte(kmap_coherent_pte - (FIX_CMAP_END - idx), pte);
+	/* preload TLB instead of local_flush_tlb_one() */
+	mtc0_tlbw_hazard();
+	tlb_probe();
+	tlb_probe_hazard();
+	tlbidx = read_c0_index();
+	mtc0_tlbw_hazard();
+	if (tlbidx < 0)
+		tlb_write_random();
+	else
+		tlb_write_indexed();
+#else
+	tlbidx = read_c0_wired();
+	write_c0_wired(tlbidx + 1);
+	write_c0_index(tlbidx);
+	mtc0_tlbw_hazard();
+	tlb_write_indexed();
+#endif
+	tlbw_use_hazard();
+	write_c0_entryhi(old_ctx);
+	EXIT_CRITICAL(flags);
+
+	return (void*) vaddr;
+}
+
+#define UNIQUE_ENTRYHI(idx) (CKSEG0 + ((idx) << (PAGE_SHIFT + 1)))
+
+void kunmap_coherent(void)
+{
+#ifndef CONFIG_MIPS_MT_SMTC
+	unsigned int wired;
+	unsigned long flags, old_ctx;
+
+	ENTER_CRITICAL(flags);
+	old_ctx = read_c0_entryhi();
+	wired = read_c0_wired() - 1;
+	write_c0_wired(wired);
+	write_c0_index(wired);
+	write_c0_entryhi(UNIQUE_ENTRYHI(wired));
+	write_c0_entrylo0(0);
+	write_c0_entrylo1(0);
+	mtc0_tlbw_hazard();
+	tlb_write_indexed();
+	tlbw_use_hazard();
+	write_c0_entryhi(old_ctx);
+	EXIT_CRITICAL(flags);
+#endif
+	dec_preempt_count();
+	preempt_check_resched();
+}
+
+void copy_to_user_page(struct vm_area_struct *vma,
+	struct page *page, unsigned long vaddr, void *dst, const void *src,
+	unsigned long len)
+{
+	if (cpu_has_dc_aliases && cpu_use_kmap_coherent &&
+	    page_mapped(page) && !Page_dcache_dirty(page)) {
+		void *vto = kmap_coherent(page, vaddr) + (vaddr & ~PAGE_MASK);
+		memcpy(vto, src, len);
+		kunmap_coherent();
+	} else {
+		memcpy(dst, src, len);
+		if (cpu_has_dc_aliases)
+			SetPageDcacheDirty(page);
+	}
+	if ((vma->vm_flags & VM_EXEC) && !cpu_has_ic_fills_f_dc)
+		flush_cache_page(vma, vaddr, page_to_pfn(page));
+}
+
+void copy_from_user_page(struct vm_area_struct *vma,
+	struct page *page, unsigned long vaddr, void *dst, const void *src,
+	unsigned long len)
+{
+	if (cpu_has_dc_aliases && cpu_use_kmap_coherent &&
+	    page_mapped(page) && !Page_dcache_dirty(page)) {
+		void *vfrom = kmap_coherent(page, vaddr) + (vaddr & ~PAGE_MASK);
+		memcpy(dst, vfrom, len);
+		kunmap_coherent();
+	} else {
+		memcpy(dst, src, len);
+		if (cpu_has_dc_aliases)
+			SetPageDcacheDirty(page);
+	}
+}
+
+void __init fixrange_init(unsigned long start, unsigned long end,
+	pgd_t *pgd_base)
+{
+#if defined(CONFIG_HIGHMEM) || defined(CONFIG_MIPS_MT_SMTC)
+	pgd_t *pgd;
+	pud_t *pud;
+	pmd_t *pmd;
+	pte_t *pte;
+	int i, j, k;
+	unsigned long vaddr;
+
+	vaddr = start;
+	i = __pgd_offset(vaddr);
+	j = __pud_offset(vaddr);
+	k = __pmd_offset(vaddr);
+	pgd = pgd_base + i;
+
+	for ( ; (i < PTRS_PER_PGD) && (vaddr != end); pgd++, i++) {
+		pud = (pud_t *)pgd;
+		for ( ; (j < PTRS_PER_PUD) && (vaddr != end); pud++, j++) {
+			pmd = (pmd_t *)pud;
+			for (; (k < PTRS_PER_PMD) && (vaddr != end); pmd++, k++) {
+				if (pmd_none(*pmd)) {
+					pte = (pte_t *) alloc_bootmem_low_pages(PAGE_SIZE);
+					set_pmd(pmd, __pmd((unsigned long)pte));
+					BUG_ON(pte != pte_offset_kernel(pmd, 0));
+				}
+				vaddr += PMD_SIZE;
+			}
+			k = 0;
+		}
+		j = 0;
+	}
+#endif
+}
+
+#ifndef CONFIG_NEED_MULTIPLE_NODES
+static int __init page_is_ram(unsigned long pagenr)
+{
+	int i;
+
+	for (i = 0; i < boot_mem_map.nr_map; i++) {
+		unsigned long addr, end;
+
+		if (boot_mem_map.map[i].type != BOOT_MEM_RAM)
+			/* not usable memory */
+			continue;
+
+		addr = PFN_UP(boot_mem_map.map[i].addr);
+		end = PFN_DOWN(boot_mem_map.map[i].addr +
+			       boot_mem_map.map[i].size);
+
+		if (pagenr >= addr && pagenr < end)
+			return 1;
+	}
+
+	return 0;
+}
+
+void __init paging_init(void)
+{
+	unsigned long max_zone_pfns[MAX_NR_ZONES];
+	unsigned long lastpfn;
+
+	pagetable_init();
+
+#ifdef CONFIG_HIGHMEM
+	kmap_init();
+#endif
+	kmap_coherent_init();
+
+#ifdef CONFIG_ZONE_DMA
+	max_zone_pfns[ZONE_DMA] = MAX_DMA_PFN;
+#endif
+#ifdef CONFIG_ZONE_DMA32
+	max_zone_pfns[ZONE_DMA32] = MAX_DMA32_PFN;
+#endif
+	max_zone_pfns[ZONE_NORMAL] = max_low_pfn;
+	lastpfn = max_low_pfn;
+#ifdef CONFIG_HIGHMEM
+	max_zone_pfns[ZONE_HIGHMEM] = highend_pfn;
+	lastpfn = highend_pfn;
+
+	if (cpu_has_dc_aliases && max_low_pfn != highend_pfn) {
+		printk(KERN_WARNING "This processor doesn't support highmem."
+		       " %ldk highmem ignored\n",
+		       (highend_pfn - max_low_pfn) << (PAGE_SHIFT - 10));
+		max_zone_pfns[ZONE_HIGHMEM] = max_low_pfn;
+		lastpfn = max_low_pfn;
+	}
+#endif
+
+	free_area_init_nodes(max_zone_pfns);
+}
+
+static struct kcore_list kcore_mem, kcore_vmalloc;
+#ifdef CONFIG_64BIT
+static struct kcore_list kcore_kseg0;
+#endif
+
+void __init mem_init(void)
+{
+	unsigned long codesize, reservedpages, datasize, initsize;
+	unsigned long tmp, ram;
+
+#ifdef CONFIG_HIGHMEM
+#ifdef CONFIG_DISCONTIGMEM
+#error "CONFIG_HIGHMEM and CONFIG_DISCONTIGMEM dont work together yet"
+#endif
+	max_mapnr = highend_pfn;
+#else
+	max_mapnr = max_low_pfn;
+#endif
+	high_memory = (void *) __va(max_low_pfn << PAGE_SHIFT);
+
+	totalram_pages += free_all_bootmem();
+	totalram_pages -= setup_zero_pages();	/* Setup zeroed pages.  */
+
+	reservedpages = ram = 0;
+	for (tmp = 0; tmp < max_low_pfn; tmp++)
+		if (page_is_ram(tmp)) {
+			ram++;
+			if (PageReserved(pfn_to_page(tmp)))
+				reservedpages++;
+		}
+	num_physpages = ram;
+
+#ifdef CONFIG_HIGHMEM
+	for (tmp = highstart_pfn; tmp < highend_pfn; tmp++) {
+		struct page *page = pfn_to_page(tmp);
+
+		if (!page_is_ram(tmp)) {
+			SetPageReserved(page);
+			continue;
+		}
+		ClearPageReserved(page);
+		init_page_count(page);
+		__free_page(page);
+		totalhigh_pages++;
+	}
+	totalram_pages += totalhigh_pages;
+	num_physpages += totalhigh_pages;
+#endif
+
+	codesize =  (unsigned long) &_etext - (unsigned long) &_text;
+	datasize =  (unsigned long) &_edata - (unsigned long) &_etext;
+	initsize =  (unsigned long) &__init_end - (unsigned long) &__init_begin;
+
+#ifdef CONFIG_64BIT
+	if ((unsigned long) &_text > (unsigned long) CKSEG0)
+		/* The -4 is a hack so that user tools don't have to handle
+		   the overflow.  */
+		kclist_add(&kcore_kseg0, (void *) CKSEG0, 0x80000000 - 4);
+#endif
+	kclist_add(&kcore_mem, __va(0), max_low_pfn << PAGE_SHIFT);
+	kclist_add(&kcore_vmalloc, (void *)VMALLOC_START,
+		   VMALLOC_END-VMALLOC_START);
+
+	printk(KERN_INFO "Memory: %luk/%luk available (%ldk kernel code, "
+	       "%ldk reserved, %ldk data, %ldk init, %ldk highmem)\n",
+	       (unsigned long) nr_free_pages() << (PAGE_SHIFT-10),
+	       ram << (PAGE_SHIFT-10),
+	       codesize >> 10,
+	       reservedpages << (PAGE_SHIFT-10),
+	       datasize >> 10,
+	       initsize >> 10,
+	       (unsigned long) (totalhigh_pages << (PAGE_SHIFT-10)));
+}
+#endif /* !CONFIG_NEED_MULTIPLE_NODES */
+
+void free_init_pages(const char *what, unsigned long begin, unsigned long end)
+{
+	unsigned long pfn;
+
+	for (pfn = PFN_UP(begin); pfn < PFN_DOWN(end); pfn++) {
+		struct page *page = pfn_to_page(pfn);
+		void *addr = phys_to_virt(PFN_PHYS(pfn));
+
+		ClearPageReserved(page);
+		init_page_count(page);
+		memset(addr, POISON_FREE_INITMEM, PAGE_SIZE);
+		__free_page(page);
+		totalram_pages++;
+	}
+	printk(KERN_INFO "Freeing %s: %ldk freed\n", what, (end - begin) >> 10);
+}
+
+#ifdef CONFIG_BLK_DEV_INITRD
+void free_initrd_mem(unsigned long start, unsigned long end)
+{
+	free_init_pages("initrd memory",
+			virt_to_phys((void *)start),
+			virt_to_phys((void *)end));
+}
+#endif
+
+void __init_refok free_initmem(void)
+{
+	prom_free_prom_memory();
+	free_init_pages("unused kernel memory",
+			__pa_symbol(&__init_begin),
+			__pa_symbol(&__init_end));
+}
+
+unsigned long pgd_current[NR_CPUS];
+/*
+ * On 64-bit we've got three-level pagetables with a slightly
+ * different layout ...
+ */
+#define __page_aligned(order) __attribute__((__aligned__(PAGE_SIZE<<order)))
+
+/*
+ * gcc 3.3 and older have trouble determining that PTRS_PER_PGD and PGD_ORDER
+ * are constants.  So we use the variants from asm-offset.h until that gcc
+ * will officially be retired.
+ */
+pgd_t swapper_pg_dir[_PTRS_PER_PGD] __page_aligned(_PGD_ORDER);
+#ifdef CONFIG_64BIT
+#ifdef MODULE_START
+pgd_t module_pg_dir[PTRS_PER_PGD] __page_aligned(PGD_ORDER);
+#endif
+pmd_t invalid_pmd_table[PTRS_PER_PMD] __page_aligned(PMD_ORDER);
+#endif
+pte_t invalid_pte_table[PTRS_PER_PTE] __page_aligned(PTE_ORDER);
diff -Nru linux-2.6.30.5/arch/mips/mm/tlbex.c linux-2.6.30.5-wrt/arch/mips/mm/tlbex.c
--- linux-2.6.30.5/arch/mips/mm/tlbex.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/mips/mm/tlbex.c	2009-09-06 18:48:23.530699264 +0200
@@ -544,6 +544,9 @@
 #endif
 	uasm_i_addu(p, ptr, tmp, ptr);
 #else
+#ifdef CONFIG_BCM47XX
+	uasm_i_nop(p);
+#endif
 	UASM_i_LA_mostly(p, ptr, pgdc);
 #endif
 	uasm_i_mfc0(p, tmp, C0_BADVADDR); /* get faulting address */
@@ -677,6 +680,9 @@
 #ifdef CONFIG_64BIT
 	build_get_pmde64(&p, &l, &r, K0, K1); /* get pmd in K1 */
 #else
+# ifdef CONFIG_BCM47XX
+	uasm_i_nop(&p);
+# endif
 	build_get_pgde32(&p, K0, K1); /* get pgd in K1 */
 #endif
 
@@ -684,6 +690,9 @@
 	build_update_entries(&p, K0, K1);
 	build_tlb_write_entry(&p, &l, &r, tlb_random);
 	uasm_l_leave(&l, p);
+#ifdef CONFIG_BCM47XX
+	uasm_i_nop(&p);
+#endif
 	uasm_i_eret(&p); /* return from trap */
 
 #ifdef CONFIG_64BIT
@@ -1084,6 +1093,9 @@
 #ifdef CONFIG_64BIT
 	build_get_pmde64(p, l, r, pte, ptr); /* get pmd in ptr */
 #else
+# ifdef CONFIG_BCM47XX
+	uasm_i_nop(p);
+# endif
 	build_get_pgde32(p, pte, ptr); /* get pgd in ptr */
 #endif
 
@@ -1111,6 +1123,9 @@
 	build_update_entries(p, tmp, ptr);
 	build_tlb_write_entry(p, l, r, tlb_indexed);
 	uasm_l_leave(l, *p);
+#ifdef CONFIG_BCM47XX
+	uasm_i_nop(p);
+#endif
 	uasm_i_eret(p); /* return from trap */
 
 #ifdef CONFIG_64BIT
diff -Nru linux-2.6.30.5/arch/mips/pci/pci.c linux-2.6.30.5-wrt/arch/mips/pci/pci.c
--- linux-2.6.30.5/arch/mips/pci/pci.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/mips/pci/pci.c	2009-09-06 18:48:23.502698535 +0200
@@ -185,12 +185,10 @@
 		if ((idx == PCI_ROM_RESOURCE) &&
 				(!(r->flags & IORESOURCE_ROM_ENABLE)))
 			continue;
-		if (!r->start && r->end) {
-			printk(KERN_ERR "PCI: Device %s not available "
-			       "because of resource collisions\n",
+		if (!r->start && r->end)
+			printk(KERN_WARNING "PCI: Device %s resource"
+			       "collisions detected. Ignoring...\n",
 			       pci_name(dev));
-			return -EINVAL;
-		}
 		if (r->flags & IORESOURCE_IO)
 			cmd |= PCI_COMMAND_IO;
 		if (r->flags & IORESOURCE_MEM)
diff -Nru linux-2.6.30.5/arch/powerpc/Makefile linux-2.6.30.5-wrt/arch/powerpc/Makefile
--- linux-2.6.30.5/arch/powerpc/Makefile	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/powerpc/Makefile	2009-09-06 18:44:12.071167890 +0200
@@ -92,8 +92,6 @@
 else
 	KBUILD_CFLAGS += $(call cc-option,-mtune=power4)
 endif
-else
-LDFLAGS_MODULE	+= arch/powerpc/lib/crtsavres.o
 endif
 
 ifeq ($(CONFIG_TUNE_CELL),y)
@@ -125,7 +123,8 @@
 KBUILD_CFLAGS		+= -mno-sched-epilog
 endif
 
-cpu-as-$(CONFIG_4xx)		+= -Wa,-m405
+cpu-as-$(CONFIG_40x)		+= -Wa,-m405
+cpu-as-$(CONFIG_44x)		+= -Wa,-m440
 cpu-as-$(CONFIG_6xx)		+= -Wa,-maltivec
 cpu-as-$(CONFIG_POWER4)		+= -Wa,-maltivec
 cpu-as-$(CONFIG_E500)		+= -Wa,-me500
diff -Nru linux-2.6.30.5/arch/powerpc/boot/Makefile linux-2.6.30.5-wrt/arch/powerpc/boot/Makefile
--- linux-2.6.30.5/arch/powerpc/boot/Makefile	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/powerpc/boot/Makefile	2009-09-06 18:44:12.071167890 +0200
@@ -38,9 +38,9 @@
 DTS_FLAGS	?= -p 1024
 
 $(obj)/4xx.o: BOOTCFLAGS += -mcpu=405
-$(obj)/ebony.o: BOOTCFLAGS += -mcpu=405
-$(obj)/cuboot-taishan.o: BOOTCFLAGS += -mcpu=405
-$(obj)/cuboot-katmai.o: BOOTCFLAGS += -mcpu=405
+$(obj)/ebony.o: BOOTCFLAGS += -mcpu=440
+$(obj)/cuboot-taishan.o: BOOTCFLAGS += -mcpu=440
+$(obj)/cuboot-katmai.o: BOOTCFLAGS += -mcpu=440
 $(obj)/cuboot-acadia.o: BOOTCFLAGS += -mcpu=405
 $(obj)/treeboot-walnut.o: BOOTCFLAGS += -mcpu=405
 $(obj)/virtex405-head.o: BOOTAFLAGS += -mcpu=405
@@ -59,7 +59,7 @@
 $(addprefix $(obj)/,$(libfdt) libfdt-wrapper.o simpleboot.o): \
 	$(addprefix $(obj)/,$(libfdtheader))
 
-src-wlib := string.S crt0.S crtsavres.S stdio.c main.c \
+src-wlib := string.S crt0.S stdio.c main.c \
 		$(libfdt) libfdt-wrapper.c \
 		ns16550.c serial.c simple_alloc.c div64.S util.S \
 		gunzip_util.c elf_util.c $(zlib) devtree.c oflib.c ofconsole.c \
diff -Nru linux-2.6.30.5/arch/powerpc/boot/crtsavres.S linux-2.6.30.5-wrt/arch/powerpc/boot/crtsavres.S
--- linux-2.6.30.5/arch/powerpc/boot/crtsavres.S	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/powerpc/boot/crtsavres.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,233 +0,0 @@
-/*
- * Special support for eabi and SVR4
- *
- *   Copyright (C) 1995, 1996, 1998, 2000, 2001 Free Software Foundation, Inc.
- *   Copyright 2008 Freescale Semiconductor, Inc.
- *   Written By Michael Meissner
- *
- * Based on gcc/config/rs6000/crtsavres.asm from gcc
- *
- * This file is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2, or (at your option) any
- * later version.
- *
- * In addition to the permissions in the GNU General Public License, the
- * Free Software Foundation gives you unlimited permission to link the
- * compiled version of this file with other programs, and to distribute
- * those programs without any restriction coming from the use of this
- * file.  (The General Public License restrictions do apply in other
- * respects; for example, they cover modification of the file, and
- * distribution when not linked into another program.)
- *
- * This file is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; see the file COPYING.  If not, write to
- * the Free Software Foundation, 51 Franklin Street, Fifth Floor,
- * Boston, MA 02110-1301, USA.
- *
- *    As a special exception, if you link this library with files
- *    compiled with GCC to produce an executable, this does not cause
- *    the resulting executable to be covered by the GNU General Public License.
- *    This exception does not however invalidate any other reasons why
- *    the executable file might be covered by the GNU General Public License.
- */
-
-	.file	"crtsavres.S"
-	.section ".text"
-
-/* On PowerPC64 Linux, these functions are provided by the linker.  */
-#ifndef __powerpc64__
-
-#define _GLOBAL(name) \
-	.type name,@function; \
-	.globl name; \
-name:
-
-/* Routines for saving integer registers, called by the compiler.  */
-/* Called with r11 pointing to the stack header word of the caller of the */
-/* function, just beyond the end of the integer save area.  */
-
-_GLOBAL(_savegpr_14)
-_GLOBAL(_save32gpr_14)
-	stw	14,-72(11)	/* save gp registers */
-_GLOBAL(_savegpr_15)
-_GLOBAL(_save32gpr_15)
-	stw	15,-68(11)
-_GLOBAL(_savegpr_16)
-_GLOBAL(_save32gpr_16)
-	stw	16,-64(11)
-_GLOBAL(_savegpr_17)
-_GLOBAL(_save32gpr_17)
-	stw	17,-60(11)
-_GLOBAL(_savegpr_18)
-_GLOBAL(_save32gpr_18)
-	stw	18,-56(11)
-_GLOBAL(_savegpr_19)
-_GLOBAL(_save32gpr_19)
-	stw	19,-52(11)
-_GLOBAL(_savegpr_20)
-_GLOBAL(_save32gpr_20)
-	stw	20,-48(11)
-_GLOBAL(_savegpr_21)
-_GLOBAL(_save32gpr_21)
-	stw	21,-44(11)
-_GLOBAL(_savegpr_22)
-_GLOBAL(_save32gpr_22)
-	stw	22,-40(11)
-_GLOBAL(_savegpr_23)
-_GLOBAL(_save32gpr_23)
-	stw	23,-36(11)
-_GLOBAL(_savegpr_24)
-_GLOBAL(_save32gpr_24)
-	stw	24,-32(11)
-_GLOBAL(_savegpr_25)
-_GLOBAL(_save32gpr_25)
-	stw	25,-28(11)
-_GLOBAL(_savegpr_26)
-_GLOBAL(_save32gpr_26)
-	stw	26,-24(11)
-_GLOBAL(_savegpr_27)
-_GLOBAL(_save32gpr_27)
-	stw	27,-20(11)
-_GLOBAL(_savegpr_28)
-_GLOBAL(_save32gpr_28)
-	stw	28,-16(11)
-_GLOBAL(_savegpr_29)
-_GLOBAL(_save32gpr_29)
-	stw	29,-12(11)
-_GLOBAL(_savegpr_30)
-_GLOBAL(_save32gpr_30)
-	stw	30,-8(11)
-_GLOBAL(_savegpr_31)
-_GLOBAL(_save32gpr_31)
-	stw	31,-4(11)
-	blr
-
-/* Routines for restoring integer registers, called by the compiler.  */
-/* Called with r11 pointing to the stack header word of the caller of the */
-/* function, just beyond the end of the integer restore area.  */
-
-_GLOBAL(_restgpr_14)
-_GLOBAL(_rest32gpr_14)
-	lwz	14,-72(11)	/* restore gp registers */
-_GLOBAL(_restgpr_15)
-_GLOBAL(_rest32gpr_15)
-	lwz	15,-68(11)
-_GLOBAL(_restgpr_16)
-_GLOBAL(_rest32gpr_16)
-	lwz	16,-64(11)
-_GLOBAL(_restgpr_17)
-_GLOBAL(_rest32gpr_17)
-	lwz	17,-60(11)
-_GLOBAL(_restgpr_18)
-_GLOBAL(_rest32gpr_18)
-	lwz	18,-56(11)
-_GLOBAL(_restgpr_19)
-_GLOBAL(_rest32gpr_19)
-	lwz	19,-52(11)
-_GLOBAL(_restgpr_20)
-_GLOBAL(_rest32gpr_20)
-	lwz	20,-48(11)
-_GLOBAL(_restgpr_21)
-_GLOBAL(_rest32gpr_21)
-	lwz	21,-44(11)
-_GLOBAL(_restgpr_22)
-_GLOBAL(_rest32gpr_22)
-	lwz	22,-40(11)
-_GLOBAL(_restgpr_23)
-_GLOBAL(_rest32gpr_23)
-	lwz	23,-36(11)
-_GLOBAL(_restgpr_24)
-_GLOBAL(_rest32gpr_24)
-	lwz	24,-32(11)
-_GLOBAL(_restgpr_25)
-_GLOBAL(_rest32gpr_25)
-	lwz	25,-28(11)
-_GLOBAL(_restgpr_26)
-_GLOBAL(_rest32gpr_26)
-	lwz	26,-24(11)
-_GLOBAL(_restgpr_27)
-_GLOBAL(_rest32gpr_27)
-	lwz	27,-20(11)
-_GLOBAL(_restgpr_28)
-_GLOBAL(_rest32gpr_28)
-	lwz	28,-16(11)
-_GLOBAL(_restgpr_29)
-_GLOBAL(_rest32gpr_29)
-	lwz	29,-12(11)
-_GLOBAL(_restgpr_30)
-_GLOBAL(_rest32gpr_30)
-	lwz	30,-8(11)
-_GLOBAL(_restgpr_31)
-_GLOBAL(_rest32gpr_31)
-	lwz	31,-4(11)
-	blr
-
-/* Routines for restoring integer registers, called by the compiler.  */
-/* Called with r11 pointing to the stack header word of the caller of the */
-/* function, just beyond the end of the integer restore area.  */
-
-_GLOBAL(_restgpr_14_x)
-_GLOBAL(_rest32gpr_14_x)
-	lwz	14,-72(11)	/* restore gp registers */
-_GLOBAL(_restgpr_15_x)
-_GLOBAL(_rest32gpr_15_x)
-	lwz	15,-68(11)
-_GLOBAL(_restgpr_16_x)
-_GLOBAL(_rest32gpr_16_x)
-	lwz	16,-64(11)
-_GLOBAL(_restgpr_17_x)
-_GLOBAL(_rest32gpr_17_x)
-	lwz	17,-60(11)
-_GLOBAL(_restgpr_18_x)
-_GLOBAL(_rest32gpr_18_x)
-	lwz	18,-56(11)
-_GLOBAL(_restgpr_19_x)
-_GLOBAL(_rest32gpr_19_x)
-	lwz	19,-52(11)
-_GLOBAL(_restgpr_20_x)
-_GLOBAL(_rest32gpr_20_x)
-	lwz	20,-48(11)
-_GLOBAL(_restgpr_21_x)
-_GLOBAL(_rest32gpr_21_x)
-	lwz	21,-44(11)
-_GLOBAL(_restgpr_22_x)
-_GLOBAL(_rest32gpr_22_x)
-	lwz	22,-40(11)
-_GLOBAL(_restgpr_23_x)
-_GLOBAL(_rest32gpr_23_x)
-	lwz	23,-36(11)
-_GLOBAL(_restgpr_24_x)
-_GLOBAL(_rest32gpr_24_x)
-	lwz	24,-32(11)
-_GLOBAL(_restgpr_25_x)
-_GLOBAL(_rest32gpr_25_x)
-	lwz	25,-28(11)
-_GLOBAL(_restgpr_26_x)
-_GLOBAL(_rest32gpr_26_x)
-	lwz	26,-24(11)
-_GLOBAL(_restgpr_27_x)
-_GLOBAL(_rest32gpr_27_x)
-	lwz	27,-20(11)
-_GLOBAL(_restgpr_28_x)
-_GLOBAL(_rest32gpr_28_x)
-	lwz	28,-16(11)
-_GLOBAL(_restgpr_29_x)
-_GLOBAL(_rest32gpr_29_x)
-	lwz	29,-12(11)
-_GLOBAL(_restgpr_30_x)
-_GLOBAL(_rest32gpr_30_x)
-	lwz	30,-8(11)
-_GLOBAL(_restgpr_31_x)
-_GLOBAL(_rest32gpr_31_x)
-	lwz	0,4(11)
-	lwz	31,-4(11)
-	mtlr	0
-	mr	1,11
-	blr
-#endif
diff -Nru linux-2.6.30.5/arch/powerpc/kernel/prom_init_check.sh linux-2.6.30.5-wrt/arch/powerpc/kernel/prom_init_check.sh
--- linux-2.6.30.5/arch/powerpc/kernel/prom_init_check.sh	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/powerpc/kernel/prom_init_check.sh	2009-09-06 18:44:06.827167026 +0200
@@ -48,20 +48,6 @@
 		fi
 	done
 
-	# ignore register save/restore funcitons
-	if [ "${UNDEF:0:9}" = "_restgpr_" ]; then
-		OK=1
-	fi
-	if [ "${UNDEF:0:11}" = "_rest32gpr_" ]; then
-		OK=1
-	fi
-	if [ "${UNDEF:0:9}" = "_savegpr_" ]; then
-		OK=1
-	fi
-	if [ "${UNDEF:0:11}" = "_save32gpr_" ]; then
-		OK=1
-	fi
-
 	if [ $OK -eq 0 ]; then
 		ERROR=1
 		echo "Error: External symbol '$UNDEF' referenced" \
diff -Nru linux-2.6.30.5/arch/powerpc/kernel/vmlinux.lds.S linux-2.6.30.5-wrt/arch/powerpc/kernel/vmlinux.lds.S
--- linux-2.6.30.5/arch/powerpc/kernel/vmlinux.lds.S	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/powerpc/kernel/vmlinux.lds.S	2009-09-06 18:43:48.334667043 +0200
@@ -37,12 +37,6 @@
 #endif
 SECTIONS
 {
-	/* Sections to be discarded. */
-	/DISCARD/ : {
-	*(.exitcall.exit)
-	EXIT_DATA
-	}
-
 	. = KERNELBASE;
 
 /*
@@ -295,6 +289,12 @@
 		__bss_stop = .;
 	}
 
+	/* Sections to be discarded. */
+	/DISCARD/ : {
+	*(.exitcall.exit)
+	EXIT_DATA
+	}
+
 	. = ALIGN(PAGE_SIZE);
 	_end = . ;
 	PROVIDE32 (end = .);
diff -Nru linux-2.6.30.5/arch/powerpc/lib/Makefile linux-2.6.30.5-wrt/arch/powerpc/lib/Makefile
--- linux-2.6.30.5/arch/powerpc/lib/Makefile	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/powerpc/lib/Makefile	2009-09-06 18:44:06.827167026 +0200
@@ -11,7 +11,7 @@
 
 obj-y			:= string.o alloc.o \
 			   checksum_$(CONFIG_WORD_SIZE).o
-obj-$(CONFIG_PPC32)	+= div64.o copy_32.o crtsavres.o
+obj-$(CONFIG_PPC32)	+= div64.o copy_32.o
 obj-$(CONFIG_HAS_IOMEM)	+= devres.o
 
 obj-$(CONFIG_PPC64)	+= copypage_64.o copyuser_64.o \
diff -Nru linux-2.6.30.5/arch/powerpc/lib/crtsavres.S linux-2.6.30.5-wrt/arch/powerpc/lib/crtsavres.S
--- linux-2.6.30.5/arch/powerpc/lib/crtsavres.S	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/powerpc/lib/crtsavres.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,229 +0,0 @@
-/*
- * Special support for eabi and SVR4
- *
- *   Copyright (C) 1995, 1996, 1998, 2000, 2001 Free Software Foundation, Inc.
- *   Copyright 2008 Freescale Semiconductor, Inc.
- *   Written By Michael Meissner
- *
- * Based on gcc/config/rs6000/crtsavres.asm from gcc
- *
- * This file is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2, or (at your option) any
- * later version.
- *
- * In addition to the permissions in the GNU General Public License, the
- * Free Software Foundation gives you unlimited permission to link the
- * compiled version of this file with other programs, and to distribute
- * those programs without any restriction coming from the use of this
- * file.  (The General Public License restrictions do apply in other
- * respects; for example, they cover modification of the file, and
- * distribution when not linked into another program.)
- *
- * This file is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; see the file COPYING.  If not, write to
- * the Free Software Foundation, 51 Franklin Street, Fifth Floor,
- * Boston, MA 02110-1301, USA.
- *
- *    As a special exception, if you link this library with files
- *    compiled with GCC to produce an executable, this does not cause
- *    the resulting executable to be covered by the GNU General Public License.
- *    This exception does not however invalidate any other reasons why
- *    the executable file might be covered by the GNU General Public License.
- */
-
-#include <asm/ppc_asm.h>
-
-	.file	"crtsavres.S"
-	.section ".text"
-
-#ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE
-
-/* Routines for saving integer registers, called by the compiler.  */
-/* Called with r11 pointing to the stack header word of the caller of the */
-/* function, just beyond the end of the integer save area.  */
-
-_GLOBAL(_savegpr_14)
-_GLOBAL(_save32gpr_14)
-	stw	14,-72(11)	/* save gp registers */
-_GLOBAL(_savegpr_15)
-_GLOBAL(_save32gpr_15)
-	stw	15,-68(11)
-_GLOBAL(_savegpr_16)
-_GLOBAL(_save32gpr_16)
-	stw	16,-64(11)
-_GLOBAL(_savegpr_17)
-_GLOBAL(_save32gpr_17)
-	stw	17,-60(11)
-_GLOBAL(_savegpr_18)
-_GLOBAL(_save32gpr_18)
-	stw	18,-56(11)
-_GLOBAL(_savegpr_19)
-_GLOBAL(_save32gpr_19)
-	stw	19,-52(11)
-_GLOBAL(_savegpr_20)
-_GLOBAL(_save32gpr_20)
-	stw	20,-48(11)
-_GLOBAL(_savegpr_21)
-_GLOBAL(_save32gpr_21)
-	stw	21,-44(11)
-_GLOBAL(_savegpr_22)
-_GLOBAL(_save32gpr_22)
-	stw	22,-40(11)
-_GLOBAL(_savegpr_23)
-_GLOBAL(_save32gpr_23)
-	stw	23,-36(11)
-_GLOBAL(_savegpr_24)
-_GLOBAL(_save32gpr_24)
-	stw	24,-32(11)
-_GLOBAL(_savegpr_25)
-_GLOBAL(_save32gpr_25)
-	stw	25,-28(11)
-_GLOBAL(_savegpr_26)
-_GLOBAL(_save32gpr_26)
-	stw	26,-24(11)
-_GLOBAL(_savegpr_27)
-_GLOBAL(_save32gpr_27)
-	stw	27,-20(11)
-_GLOBAL(_savegpr_28)
-_GLOBAL(_save32gpr_28)
-	stw	28,-16(11)
-_GLOBAL(_savegpr_29)
-_GLOBAL(_save32gpr_29)
-	stw	29,-12(11)
-_GLOBAL(_savegpr_30)
-_GLOBAL(_save32gpr_30)
-	stw	30,-8(11)
-_GLOBAL(_savegpr_31)
-_GLOBAL(_save32gpr_31)
-	stw	31,-4(11)
-	blr
-
-/* Routines for restoring integer registers, called by the compiler.  */
-/* Called with r11 pointing to the stack header word of the caller of the */
-/* function, just beyond the end of the integer restore area.  */
-
-_GLOBAL(_restgpr_14)
-_GLOBAL(_rest32gpr_14)
-	lwz	14,-72(11)	/* restore gp registers */
-_GLOBAL(_restgpr_15)
-_GLOBAL(_rest32gpr_15)
-	lwz	15,-68(11)
-_GLOBAL(_restgpr_16)
-_GLOBAL(_rest32gpr_16)
-	lwz	16,-64(11)
-_GLOBAL(_restgpr_17)
-_GLOBAL(_rest32gpr_17)
-	lwz	17,-60(11)
-_GLOBAL(_restgpr_18)
-_GLOBAL(_rest32gpr_18)
-	lwz	18,-56(11)
-_GLOBAL(_restgpr_19)
-_GLOBAL(_rest32gpr_19)
-	lwz	19,-52(11)
-_GLOBAL(_restgpr_20)
-_GLOBAL(_rest32gpr_20)
-	lwz	20,-48(11)
-_GLOBAL(_restgpr_21)
-_GLOBAL(_rest32gpr_21)
-	lwz	21,-44(11)
-_GLOBAL(_restgpr_22)
-_GLOBAL(_rest32gpr_22)
-	lwz	22,-40(11)
-_GLOBAL(_restgpr_23)
-_GLOBAL(_rest32gpr_23)
-	lwz	23,-36(11)
-_GLOBAL(_restgpr_24)
-_GLOBAL(_rest32gpr_24)
-	lwz	24,-32(11)
-_GLOBAL(_restgpr_25)
-_GLOBAL(_rest32gpr_25)
-	lwz	25,-28(11)
-_GLOBAL(_restgpr_26)
-_GLOBAL(_rest32gpr_26)
-	lwz	26,-24(11)
-_GLOBAL(_restgpr_27)
-_GLOBAL(_rest32gpr_27)
-	lwz	27,-20(11)
-_GLOBAL(_restgpr_28)
-_GLOBAL(_rest32gpr_28)
-	lwz	28,-16(11)
-_GLOBAL(_restgpr_29)
-_GLOBAL(_rest32gpr_29)
-	lwz	29,-12(11)
-_GLOBAL(_restgpr_30)
-_GLOBAL(_rest32gpr_30)
-	lwz	30,-8(11)
-_GLOBAL(_restgpr_31)
-_GLOBAL(_rest32gpr_31)
-	lwz	31,-4(11)
-	blr
-
-/* Routines for restoring integer registers, called by the compiler.  */
-/* Called with r11 pointing to the stack header word of the caller of the */
-/* function, just beyond the end of the integer restore area.  */
-
-_GLOBAL(_restgpr_14_x)
-_GLOBAL(_rest32gpr_14_x)
-	lwz	14,-72(11)	/* restore gp registers */
-_GLOBAL(_restgpr_15_x)
-_GLOBAL(_rest32gpr_15_x)
-	lwz	15,-68(11)
-_GLOBAL(_restgpr_16_x)
-_GLOBAL(_rest32gpr_16_x)
-	lwz	16,-64(11)
-_GLOBAL(_restgpr_17_x)
-_GLOBAL(_rest32gpr_17_x)
-	lwz	17,-60(11)
-_GLOBAL(_restgpr_18_x)
-_GLOBAL(_rest32gpr_18_x)
-	lwz	18,-56(11)
-_GLOBAL(_restgpr_19_x)
-_GLOBAL(_rest32gpr_19_x)
-	lwz	19,-52(11)
-_GLOBAL(_restgpr_20_x)
-_GLOBAL(_rest32gpr_20_x)
-	lwz	20,-48(11)
-_GLOBAL(_restgpr_21_x)
-_GLOBAL(_rest32gpr_21_x)
-	lwz	21,-44(11)
-_GLOBAL(_restgpr_22_x)
-_GLOBAL(_rest32gpr_22_x)
-	lwz	22,-40(11)
-_GLOBAL(_restgpr_23_x)
-_GLOBAL(_rest32gpr_23_x)
-	lwz	23,-36(11)
-_GLOBAL(_restgpr_24_x)
-_GLOBAL(_rest32gpr_24_x)
-	lwz	24,-32(11)
-_GLOBAL(_restgpr_25_x)
-_GLOBAL(_rest32gpr_25_x)
-	lwz	25,-28(11)
-_GLOBAL(_restgpr_26_x)
-_GLOBAL(_rest32gpr_26_x)
-	lwz	26,-24(11)
-_GLOBAL(_restgpr_27_x)
-_GLOBAL(_rest32gpr_27_x)
-	lwz	27,-20(11)
-_GLOBAL(_restgpr_28_x)
-_GLOBAL(_rest32gpr_28_x)
-	lwz	28,-16(11)
-_GLOBAL(_restgpr_29_x)
-_GLOBAL(_rest32gpr_29_x)
-	lwz	29,-12(11)
-_GLOBAL(_restgpr_30_x)
-_GLOBAL(_rest32gpr_30_x)
-	lwz	30,-8(11)
-_GLOBAL(_restgpr_31_x)
-_GLOBAL(_rest32gpr_31_x)
-	lwz	0,4(11)
-	lwz	31,-4(11)
-	mtlr	0
-	mr	1,11
-	blr
-#endif
diff -Nru linux-2.6.30.5/arch/x86/boot/tools/build.c linux-2.6.30.5-wrt/arch/x86/boot/tools/build.c
--- linux-2.6.30.5/arch/x86/boot/tools/build.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/arch/x86/boot/tools/build.c	2009-09-06 18:44:06.803167207 +0200
@@ -29,7 +29,6 @@
 #include <stdarg.h>
 #include <sys/types.h>
 #include <sys/stat.h>
-#include <sys/sysmacros.h>
 #include <unistd.h>
 #include <fcntl.h>
 #include <sys/mman.h>
diff -Nru linux-2.6.30.5/crypto/Kconfig linux-2.6.30.5-wrt/crypto/Kconfig
--- linux-2.6.30.5/crypto/Kconfig	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/crypto/Kconfig	2009-09-06 18:53:38.314677299 +0200
@@ -30,7 +30,7 @@
 	  this is.
 
 config CRYPTO_ALGAPI
-	tristate
+	tristate "ALGAPI"
 	select CRYPTO_ALGAPI2
 	help
 	  This option provides the API for cryptographic algorithms.
@@ -39,7 +39,7 @@
 	tristate
 
 config CRYPTO_AEAD
-	tristate
+	tristate "AEAD"
 	select CRYPTO_AEAD2
 	select CRYPTO_ALGAPI
 
@@ -48,7 +48,7 @@
 	select CRYPTO_ALGAPI2
 
 config CRYPTO_BLKCIPHER
-	tristate
+	tristate "BLKCIPHER"
 	select CRYPTO_BLKCIPHER2
 	select CRYPTO_ALGAPI
 
@@ -59,7 +59,7 @@
 	select CRYPTO_WORKQUEUE
 
 config CRYPTO_HASH
-	tristate
+	tristate "HASH"
 	select CRYPTO_HASH2
 	select CRYPTO_ALGAPI
 
@@ -68,7 +68,7 @@
 	select CRYPTO_ALGAPI2
 
 config CRYPTO_RNG
-	tristate
+	tristate "RNG"
 	select CRYPTO_RNG2
 	select CRYPTO_ALGAPI
 
@@ -758,6 +758,12 @@
 	help
 	  This is the zlib algorithm.
 
+config CRYPTO_UNLZMA
+	tristate "LZMA decompression"
+	select CRYPTO_PCOMP
+	help
+	  This is the lzma decompression module.
+
 config CRYPTO_LZO
 	tristate "LZO compression algorithm"
 	select CRYPTO_ALGAPI
diff -Nru linux-2.6.30.5/crypto/Makefile linux-2.6.30.5-wrt/crypto/Makefile
--- linux-2.6.30.5/crypto/Makefile	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/crypto/Makefile	2009-09-06 18:53:08.078828987 +0200
@@ -75,6 +75,7 @@
 obj-$(CONFIG_CRYPTO_SALSA20) += salsa20_generic.o
 obj-$(CONFIG_CRYPTO_DEFLATE) += deflate.o
 obj-$(CONFIG_CRYPTO_ZLIB) += zlib.o
+obj-$(CONFIG_CRYPTO_UNLZMA) += unlzma.o
 obj-$(CONFIG_CRYPTO_MICHAEL_MIC) += michael_mic.o
 obj-$(CONFIG_CRYPTO_CRC32C) += crc32c.o
 obj-$(CONFIG_CRYPTO_AUTHENC) += authenc.o
diff -Nru linux-2.6.30.5/crypto/testmgr.c linux-2.6.30.5-wrt/crypto/testmgr.c
--- linux-2.6.30.5/crypto/testmgr.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/crypto/testmgr.c	2009-09-06 18:43:48.338666730 +0200
@@ -914,24 +914,25 @@
 	const char *algo = crypto_tfm_alg_driver_name(crypto_pcomp_tfm(tfm));
 	unsigned int i;
 	char result[COMP_BUF_SIZE];
-	int error;
+	int res;
 
 	for (i = 0; i < ctcount; i++) {
 		struct comp_request req;
+		unsigned int produced = 0;
 
-		error = crypto_compress_setup(tfm, ctemplate[i].params,
-					      ctemplate[i].paramsize);
-		if (error) {
+		res = crypto_compress_setup(tfm, ctemplate[i].params,
+					    ctemplate[i].paramsize);
+		if (res) {
 			pr_err("alg: pcomp: compression setup failed on test "
-			       "%d for %s: error=%d\n", i + 1, algo, error);
-			return error;
+			       "%d for %s: error=%d\n", i + 1, algo, res);
+			return res;
 		}
 
-		error = crypto_compress_init(tfm);
-		if (error) {
+		res = crypto_compress_init(tfm);
+		if (res) {
 			pr_err("alg: pcomp: compression init failed on test "
-			       "%d for %s: error=%d\n", i + 1, algo, error);
-			return error;
+			       "%d for %s: error=%d\n", i + 1, algo, res);
+			return res;
 		}
 
 		memset(result, 0, sizeof(result));
@@ -941,32 +942,37 @@
 		req.next_out = result;
 		req.avail_out = ctemplate[i].outlen / 2;
 
-		error = crypto_compress_update(tfm, &req);
-		if (error && (error != -EAGAIN || req.avail_in)) {
+		res = crypto_compress_update(tfm, &req);
+		if (res < 0 && (res != -EAGAIN || req.avail_in)) {
 			pr_err("alg: pcomp: compression update failed on test "
-			       "%d for %s: error=%d\n", i + 1, algo, error);
-			return error;
+			       "%d for %s: error=%d\n", i + 1, algo, res);
+			return res;
 		}
+		if (res > 0)
+			produced += res;
 
 		/* Add remaining input data */
 		req.avail_in += (ctemplate[i].inlen + 1) / 2;
 
-		error = crypto_compress_update(tfm, &req);
-		if (error && (error != -EAGAIN || req.avail_in)) {
+		res = crypto_compress_update(tfm, &req);
+		if (res < 0 && (res != -EAGAIN || req.avail_in)) {
 			pr_err("alg: pcomp: compression update failed on test "
-			       "%d for %s: error=%d\n", i + 1, algo, error);
-			return error;
+			       "%d for %s: error=%d\n", i + 1, algo, res);
+			return res;
 		}
+		if (res > 0)
+			produced += res;
 
 		/* Provide remaining output space */
 		req.avail_out += COMP_BUF_SIZE - ctemplate[i].outlen / 2;
 
-		error = crypto_compress_final(tfm, &req);
-		if (error) {
+		res = crypto_compress_final(tfm, &req);
+		if (res < 0) {
 			pr_err("alg: pcomp: compression final failed on test "
-			       "%d for %s: error=%d\n", i + 1, algo, error);
-			return error;
+			       "%d for %s: error=%d\n", i + 1, algo, res);
+			return res;
 		}
+		produced += res;
 
 		if (COMP_BUF_SIZE - req.avail_out != ctemplate[i].outlen) {
 			pr_err("alg: comp: Compression test %d failed for %s: "
@@ -976,6 +982,13 @@
 			return -EINVAL;
 		}
 
+		if (produced != ctemplate[i].outlen) {
+			pr_err("alg: comp: Compression test %d failed for %s: "
+			       "returned len = %u (expected %d)\n", i + 1,
+			       algo, produced, ctemplate[i].outlen);
+			return -EINVAL;
+		}
+
 		if (memcmp(result, ctemplate[i].output, ctemplate[i].outlen)) {
 			pr_err("alg: pcomp: Compression test %d failed for "
 			       "%s\n", i + 1, algo);
@@ -986,21 +999,21 @@
 
 	for (i = 0; i < dtcount; i++) {
 		struct comp_request req;
+		unsigned int produced = 0;
 
-		error = crypto_decompress_setup(tfm, dtemplate[i].params,
-						dtemplate[i].paramsize);
-		if (error) {
+		res = crypto_decompress_setup(tfm, dtemplate[i].params,
+					      dtemplate[i].paramsize);
+		if (res) {
 			pr_err("alg: pcomp: decompression setup failed on "
-			       "test %d for %s: error=%d\n", i + 1, algo,
-			       error);
-			return error;
+			       "test %d for %s: error=%d\n", i + 1, algo, res);
+			return res;
 		}
 
-		error = crypto_decompress_init(tfm);
-		if (error) {
+		res = crypto_decompress_init(tfm);
+		if (res) {
 			pr_err("alg: pcomp: decompression init failed on test "
-			       "%d for %s: error=%d\n", i + 1, algo, error);
-			return error;
+			       "%d for %s: error=%d\n", i + 1, algo, res);
+			return res;
 		}
 
 		memset(result, 0, sizeof(result));
@@ -1010,35 +1023,38 @@
 		req.next_out = result;
 		req.avail_out = dtemplate[i].outlen / 2;
 
-		error = crypto_decompress_update(tfm, &req);
-		if (error  && (error != -EAGAIN || req.avail_in)) {
+		res = crypto_decompress_update(tfm, &req);
+		if (res < 0 && (res != -EAGAIN || req.avail_in)) {
 			pr_err("alg: pcomp: decompression update failed on "
-			       "test %d for %s: error=%d\n", i + 1, algo,
-			       error);
-			return error;
+			       "test %d for %s: error=%d\n", i + 1, algo, res);
+			return res;
 		}
+		if (res > 0)
+			produced += res;
 
 		/* Add remaining input data */
 		req.avail_in += (dtemplate[i].inlen + 1) / 2;
 
-		error = crypto_decompress_update(tfm, &req);
-		if (error  && (error != -EAGAIN || req.avail_in)) {
+		res = crypto_decompress_update(tfm, &req);
+		if (res < 0 && (res != -EAGAIN || req.avail_in)) {
 			pr_err("alg: pcomp: decompression update failed on "
-			       "test %d for %s: error=%d\n", i + 1, algo,
-			       error);
-			return error;
+			       "test %d for %s: error=%d\n", i + 1, algo, res);
+			return res;
 		}
+		if (res > 0)
+			produced += res;
 
 		/* Provide remaining output space */
 		req.avail_out += COMP_BUF_SIZE - dtemplate[i].outlen / 2;
 
-		error = crypto_decompress_final(tfm, &req);
-		if (error  && (error != -EAGAIN || req.avail_in)) {
+		res = crypto_decompress_final(tfm, &req);
+		if (res < 0 && (res != -EAGAIN || req.avail_in)) {
 			pr_err("alg: pcomp: decompression final failed on "
-			       "test %d for %s: error=%d\n", i + 1, algo,
-			       error);
-			return error;
+			       "test %d for %s: error=%d\n", i + 1, algo, res);
+			return res;
 		}
+		if (res > 0)
+			produced += res;
 
 		if (COMP_BUF_SIZE - req.avail_out != dtemplate[i].outlen) {
 			pr_err("alg: comp: Decompression test %d failed for "
@@ -1048,6 +1064,13 @@
 			return -EINVAL;
 		}
 
+		if (produced != dtemplate[i].outlen) {
+			pr_err("alg: comp: Decompression test %d failed for "
+			       "%s: returned len = %u (expected %d)\n", i + 1,
+			       algo, produced, dtemplate[i].outlen);
+			return -EINVAL;
+		}
+
 		if (memcmp(result, dtemplate[i].output, dtemplate[i].outlen)) {
 			pr_err("alg: pcomp: Decompression test %d failed for "
 			       "%s\n", i + 1, algo);
diff -Nru linux-2.6.30.5/crypto/unlzma.c linux-2.6.30.5-wrt/crypto/unlzma.c
--- linux-2.6.30.5/crypto/unlzma.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/crypto/unlzma.c	2009-09-06 18:43:48.342667486 +0200
@@ -0,0 +1,748 @@
+/*
+ * LZMA uncompresion module for pcomp
+ * Copyright (C) 2009  Felix Fietkau <nbd@openwrt.org>
+ *
+ * Based on:
+ *  Initial Linux kernel adaptation
+ *  Copyright (C) 2006  Alain < alain@knaff.lu >
+ *
+ *  Based on small lzma deflate implementation/Small range coder
+ *  implementation for lzma.
+ *  Copyright (C) 2006  Aurelien Jacobs < aurel@gnuage.org >
+ *
+ *  Based on LzmaDecode.c from the LZMA SDK 4.22 (http://www.7-zip.org/)
+ *  Copyright (C) 1999-2005  Igor Pavlov
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ * FIXME: the current implementation assumes that the caller will
+ * not free any output buffers until the whole decompression has been
+ * completed. This is necessary, because LZMA looks back at old output
+ * instead of doing a separate dictionary allocation, which saves RAM.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/vmalloc.h>
+#include <linux/interrupt.h>
+#include <linux/mm.h>
+#include <linux/net.h>
+#include <linux/slab.h>
+#include <linux/kthread.h>
+
+#include <crypto/internal/compress.h>
+#include <net/netlink.h>
+#include "unlzma.h"
+
+static int instance = 0;
+
+struct unlzma_buffer {
+	int offset;
+	int size;
+	u8 *ptr;
+};
+
+struct unlzma_ctx {
+	struct task_struct *thread;
+	wait_queue_head_t next_req;
+	struct mutex mutex;
+	bool active;
+	bool cancel;
+
+	const u8 *next_in;
+	int avail_in;
+
+	u8 *next_out;
+	int avail_out;
+
+	/* reader state */
+	u32 code;
+	u32 range;
+	u32 bound;
+
+	/* writer state */
+	u8 previous_byte;
+	ssize_t pos;
+	int buf_full;
+	int n_buffers;
+	int buffers_max;
+	struct unlzma_buffer *buffers;
+
+	/* cstate */
+	int state;
+	u32 rep0, rep1, rep2, rep3;
+
+	u32 dict_size;
+
+	void *workspace;
+	int workspace_size;
+};
+
+static inline bool
+unlzma_should_stop(struct unlzma_ctx *ctx)
+{
+	return unlikely(kthread_should_stop() || ctx->cancel);
+}
+
+static void
+get_buffer(struct unlzma_ctx *ctx)
+{
+	struct unlzma_buffer *bh;
+
+	BUG_ON(ctx->n_buffers >= ctx->buffers_max);
+	bh = &ctx->buffers[ctx->n_buffers++];
+	bh->ptr = ctx->next_out;
+	bh->offset = ctx->pos;
+	bh->size = ctx->avail_out;
+	ctx->buf_full = 0;
+}
+
+static void
+unlzma_request_buffer(struct unlzma_ctx *ctx, int *avail)
+{
+	do {
+		mutex_unlock(&ctx->mutex);
+		if (wait_event_interruptible(ctx->next_req,
+			unlzma_should_stop(ctx) || (*avail > 0)))
+			schedule();
+		mutex_lock(&ctx->mutex);
+	} while (*avail <= 0 && !unlzma_should_stop(ctx));
+
+	if (!unlzma_should_stop(ctx) && ctx->buf_full)
+		get_buffer(ctx);
+}
+
+static u8
+rc_read(struct unlzma_ctx *ctx)
+{
+	if (unlikely(ctx->avail_in <= 0))
+		unlzma_request_buffer(ctx, &ctx->avail_in);
+
+	if (unlzma_should_stop(ctx))
+		return 0;
+
+	ctx->avail_in--;
+	return *(ctx->next_in++);
+}
+
+
+static inline void
+rc_get_code(struct unlzma_ctx *ctx)
+{
+	ctx->code = (ctx->code << 8) | rc_read(ctx);
+}
+
+static void
+rc_normalize(struct unlzma_ctx *ctx)
+{
+	if (ctx->range < (1 << RC_TOP_BITS)) {
+		ctx->range <<= 8;
+		rc_get_code(ctx);
+	}
+}
+
+static int
+rc_is_bit_0(struct unlzma_ctx *ctx, u16 *p)
+{
+	rc_normalize(ctx);
+	ctx->bound = *p * (ctx->range >> RC_MODEL_TOTAL_BITS);
+	return ctx->code < ctx->bound;
+}
+
+static void
+rc_update_bit_0(struct unlzma_ctx *ctx, u16 *p)
+{
+	ctx->range = ctx->bound;
+	*p += ((1 << RC_MODEL_TOTAL_BITS) - *p) >> RC_MOVE_BITS;
+}
+
+static void
+rc_update_bit_1(struct unlzma_ctx *ctx, u16 *p)
+{
+	ctx->range -= ctx->bound;
+	ctx->code -= ctx->bound;
+	*p -= *p >> RC_MOVE_BITS;
+}
+
+static bool
+rc_get_bit(struct unlzma_ctx *ctx, u16 *p, int *symbol)
+{
+	if (rc_is_bit_0(ctx, p)) {
+		rc_update_bit_0(ctx, p);
+		*symbol *= 2;
+		return 0;
+	} else {
+		rc_update_bit_1(ctx, p);
+		*symbol = *symbol * 2 + 1;
+		return 1;
+	}
+}
+
+static int
+rc_direct_bit(struct unlzma_ctx *ctx)
+{
+	rc_normalize(ctx);
+	ctx->range >>= 1;
+	if (ctx->code >= ctx->range) {
+		ctx->code -= ctx->range;
+		return 1;
+	}
+	return 0;
+}
+
+static void
+rc_bit_tree_decode(struct unlzma_ctx *ctx, u16 *p, int num_levels, int *symbol)
+{
+	int i = num_levels;
+
+	*symbol = 1;
+	while (i--)
+		rc_get_bit(ctx, p + *symbol, symbol);
+	*symbol -= 1 << num_levels;
+}
+
+static u8
+peek_old_byte(struct unlzma_ctx *ctx, u32 offs)
+{
+	struct unlzma_buffer *bh = &ctx->buffers[ctx->n_buffers - 1];
+	int i = ctx->n_buffers;
+	u32 pos;
+
+	BUG_ON(!ctx->n_buffers);
+	pos = ctx->pos - offs;
+	if (pos >= ctx->dict_size) {
+		pos = (~pos % ctx->dict_size);
+	}
+
+	while (bh->offset > pos) {
+		bh--;
+		i--;
+		BUG_ON(!i);
+	}
+
+	pos -= bh->offset;
+	BUG_ON(pos >= bh->size);
+
+	return bh->ptr[pos];
+}
+
+static void
+write_byte(struct unlzma_ctx *ctx, u8 byte)
+{
+	if (unlikely(ctx->avail_out <= 0)) {
+		unlzma_request_buffer(ctx, &ctx->avail_out);
+	}
+
+	if (!ctx->avail_out)
+		return;
+
+	ctx->previous_byte = byte;
+	*(ctx->next_out++) = byte;
+	ctx->avail_out--;
+	if (ctx->avail_out == 0)
+		ctx->buf_full = 1;
+	ctx->pos++;
+}
+
+
+static inline void
+copy_byte(struct unlzma_ctx *ctx, u32 offs)
+{
+	write_byte(ctx, peek_old_byte(ctx, offs));
+}
+
+static void
+copy_bytes(struct unlzma_ctx *ctx, u32 rep0, int len)
+{
+	do {
+		copy_byte(ctx, rep0);
+		len--;
+		if (unlzma_should_stop(ctx))
+			break;
+	} while (len != 0);
+}
+
+static void
+process_bit0(struct unlzma_ctx *ctx, u16 *p, int pos_state, u16 *prob,
+             int lc, u32 literal_pos_mask)
+{
+	int mi = 1;
+	rc_update_bit_0(ctx, prob);
+	prob = (p + LZMA_LITERAL +
+		(LZMA_LIT_SIZE
+		 * (((ctx->pos & literal_pos_mask) << lc)
+		    + (ctx->previous_byte >> (8 - lc))))
+		);
+
+	if (ctx->state >= LZMA_NUM_LIT_STATES) {
+		int match_byte = peek_old_byte(ctx, ctx->rep0);
+		do {
+			u16 bit;
+			u16 *prob_lit;
+
+			match_byte <<= 1;
+			bit = match_byte & 0x100;
+			prob_lit = prob + 0x100 + bit + mi;
+			if (rc_get_bit(ctx, prob_lit, &mi) != !!bit)
+				break;
+		} while (mi < 0x100);
+	}
+	while (mi < 0x100) {
+		u16 *prob_lit = prob + mi;
+		rc_get_bit(ctx, prob_lit, &mi);
+	}
+	write_byte(ctx, mi);
+	if (ctx->state < 4)
+		ctx->state = 0;
+	else if (ctx->state < 10)
+		ctx->state -= 3;
+	else
+		ctx->state -= 6;
+}
+
+static void
+process_bit1(struct unlzma_ctx *ctx, u16 *p, int pos_state, u16 *prob)
+{
+	int offset;
+	u16 *prob_len;
+	int num_bits;
+	int len;
+
+	rc_update_bit_1(ctx, prob);
+	prob = p + LZMA_IS_REP + ctx->state;
+	if (rc_is_bit_0(ctx, prob)) {
+		rc_update_bit_0(ctx, prob);
+		ctx->rep3 = ctx->rep2;
+		ctx->rep2 = ctx->rep1;
+		ctx->rep1 = ctx->rep0;
+		ctx->state = ctx->state < LZMA_NUM_LIT_STATES ? 0 : 3;
+		prob = p + LZMA_LEN_CODER;
+	} else {
+		rc_update_bit_1(ctx, prob);
+		prob = p + LZMA_IS_REP_G0 + ctx->state;
+		if (rc_is_bit_0(ctx, prob)) {
+			rc_update_bit_0(ctx, prob);
+			prob = (p + LZMA_IS_REP_0_LONG
+				+ (ctx->state <<
+				   LZMA_NUM_POS_BITS_MAX) +
+				pos_state);
+			if (rc_is_bit_0(ctx, prob)) {
+				rc_update_bit_0(ctx, prob);
+
+				ctx->state = ctx->state < LZMA_NUM_LIT_STATES ?
+					9 : 11;
+				copy_byte(ctx, ctx->rep0);
+				return;
+			} else {
+				rc_update_bit_1(ctx, prob);
+			}
+		} else {
+			u32 distance;
+
+			rc_update_bit_1(ctx, prob);
+			prob = p + LZMA_IS_REP_G1 + ctx->state;
+			if (rc_is_bit_0(ctx, prob)) {
+				rc_update_bit_0(ctx, prob);
+				distance = ctx->rep1;
+			} else {
+				rc_update_bit_1(ctx, prob);
+				prob = p + LZMA_IS_REP_G2 + ctx->state;
+				if (rc_is_bit_0(ctx, prob)) {
+					rc_update_bit_0(ctx, prob);
+					distance = ctx->rep2;
+				} else {
+					rc_update_bit_1(ctx, prob);
+					distance = ctx->rep3;
+					ctx->rep3 = ctx->rep2;
+				}
+				ctx->rep2 = ctx->rep1;
+			}
+			ctx->rep1 = ctx->rep0;
+			ctx->rep0 = distance;
+		}
+		ctx->state = ctx->state < LZMA_NUM_LIT_STATES ? 8 : 11;
+		prob = p + LZMA_REP_LEN_CODER;
+	}
+
+	prob_len = prob + LZMA_LEN_CHOICE;
+	if (rc_is_bit_0(ctx, prob_len)) {
+		rc_update_bit_0(ctx, prob_len);
+		prob_len = (prob + LZMA_LEN_LOW
+			    + (pos_state <<
+			       LZMA_LEN_NUM_LOW_BITS));
+		offset = 0;
+		num_bits = LZMA_LEN_NUM_LOW_BITS;
+	} else {
+		rc_update_bit_1(ctx, prob_len);
+		prob_len = prob + LZMA_LEN_CHOICE_2;
+		if (rc_is_bit_0(ctx, prob_len)) {
+			rc_update_bit_0(ctx, prob_len);
+			prob_len = (prob + LZMA_LEN_MID
+				    + (pos_state <<
+				       LZMA_LEN_NUM_MID_BITS));
+			offset = 1 << LZMA_LEN_NUM_LOW_BITS;
+			num_bits = LZMA_LEN_NUM_MID_BITS;
+		} else {
+			rc_update_bit_1(ctx, prob_len);
+			prob_len = prob + LZMA_LEN_HIGH;
+			offset = ((1 << LZMA_LEN_NUM_LOW_BITS)
+				  + (1 << LZMA_LEN_NUM_MID_BITS));
+			num_bits = LZMA_LEN_NUM_HIGH_BITS;
+		}
+	}
+
+	rc_bit_tree_decode(ctx, prob_len, num_bits, &len);
+	len += offset;
+
+	if (ctx->state < 4) {
+		int pos_slot;
+
+		ctx->state += LZMA_NUM_LIT_STATES;
+		prob =
+			p + LZMA_POS_SLOT +
+			((len <
+			  LZMA_NUM_LEN_TO_POS_STATES ? len :
+			  LZMA_NUM_LEN_TO_POS_STATES - 1)
+			 << LZMA_NUM_POS_SLOT_BITS);
+		rc_bit_tree_decode(ctx, prob,
+				   LZMA_NUM_POS_SLOT_BITS,
+				   &pos_slot);
+		if (pos_slot >= LZMA_START_POS_MODEL_INDEX) {
+			int i, mi;
+			num_bits = (pos_slot >> 1) - 1;
+			ctx->rep0 = 2 | (pos_slot & 1);
+			if (pos_slot < LZMA_END_POS_MODEL_INDEX) {
+				ctx->rep0 <<= num_bits;
+				prob = p + LZMA_SPEC_POS +
+					ctx->rep0 - pos_slot - 1;
+			} else {
+				num_bits -= LZMA_NUM_ALIGN_BITS;
+				while (num_bits--)
+					ctx->rep0 = (ctx->rep0 << 1) |
+						rc_direct_bit(ctx);
+				prob = p + LZMA_ALIGN;
+				ctx->rep0 <<= LZMA_NUM_ALIGN_BITS;
+				num_bits = LZMA_NUM_ALIGN_BITS;
+			}
+			i = 1;
+			mi = 1;
+			while (num_bits--) {
+				if (rc_get_bit(ctx, prob + mi, &mi))
+					ctx->rep0 |= i;
+				i <<= 1;
+			}
+		} else
+			ctx->rep0 = pos_slot;
+		if (++(ctx->rep0) == 0)
+			return;
+	}
+
+	len += LZMA_MATCH_MIN_LEN;
+
+	copy_bytes(ctx, ctx->rep0, len);
+}
+
+
+static int
+do_unlzma(struct unlzma_ctx *ctx)
+{
+	u8 hdr_buf[sizeof(struct lzma_header)];
+	struct lzma_header *header = (struct lzma_header *)hdr_buf;
+	u32 pos_state_mask;
+	u32 literal_pos_mask;
+	int lc, pb, lp;
+	int num_probs;
+	int i, mi;
+	u16 *p;
+
+	for (i = 0; i < sizeof(struct lzma_header); i++) {
+		hdr_buf[i] = rc_read(ctx);
+	}
+
+	ctx->n_buffers = 0;
+	ctx->pos = 0;
+	get_buffer(ctx);
+	ctx->active = true;
+	ctx->state = 0;
+	ctx->rep0 = ctx->rep1 = ctx->rep2 = ctx->rep3 = 1;
+
+	ctx->previous_byte = 0;
+	ctx->code = 0;
+	ctx->range = 0xFFFFFFFF;
+
+	ctx->dict_size = le32_to_cpu(header->dict_size);
+
+	if (header->pos >= (9 * 5 * 5))
+		return -1;
+
+	mi = 0;
+	lc = header->pos;
+	while (lc >= 9) {
+		mi++;
+		lc -= 9;
+	}
+	pb = 0;
+	lp = mi;
+	while (lp >= 5) {
+		pb++;
+		lp -= 5;
+	}
+	pos_state_mask = (1 << pb) - 1;
+	literal_pos_mask = (1 << lp) - 1;
+
+	if (ctx->dict_size == 0)
+		ctx->dict_size = 1;
+
+	num_probs = LZMA_BASE_SIZE + (LZMA_LIT_SIZE << (lc + lp));
+	if (ctx->workspace_size < num_probs * sizeof(*p)) {
+		if (ctx->workspace)
+			vfree(ctx->workspace);
+		ctx->workspace_size = num_probs * sizeof(*p);
+		ctx->workspace = vmalloc(ctx->workspace_size);
+	}
+	p = (u16 *) ctx->workspace;
+	if (!p)
+		return -1;
+
+	num_probs = LZMA_LITERAL + (LZMA_LIT_SIZE << (lc + lp));
+	for (i = 0; i < num_probs; i++)
+		p[i] = (1 << RC_MODEL_TOTAL_BITS) >> 1;
+
+	for (i = 0; i < 5; i++)
+		rc_get_code(ctx);
+
+	while (1) {
+		int pos_state =	ctx->pos & pos_state_mask;
+		u16 *prob = p + LZMA_IS_MATCH +
+			(ctx->state << LZMA_NUM_POS_BITS_MAX) + pos_state;
+		if (rc_is_bit_0(ctx, prob))
+			process_bit0(ctx, p, pos_state, prob,
+				     lc, literal_pos_mask);
+		else {
+			process_bit1(ctx, p, pos_state, prob);
+			if (ctx->rep0 == 0)
+				break;
+		}
+		if (unlzma_should_stop(ctx))
+			break;
+	}
+	if (likely(!unlzma_should_stop(ctx)))
+		rc_normalize(ctx);
+
+	return ctx->pos;
+}
+
+
+static void
+unlzma_reset_buf(struct unlzma_ctx *ctx)
+{
+	ctx->avail_in = 0;
+	ctx->next_in = NULL;
+	ctx->avail_out = 0;
+	ctx->next_out = NULL;
+}
+
+static int
+unlzma_thread(void *data)
+{
+	struct unlzma_ctx *ctx = data;
+
+	mutex_lock(&ctx->mutex);
+	do {
+		if (do_unlzma(ctx) < 0)
+			ctx->pos = 0;
+		unlzma_reset_buf(ctx);
+		ctx->cancel = false;
+		ctx->active = false;
+	} while (!kthread_should_stop());
+	mutex_unlock(&ctx->mutex);
+	return 0;
+}
+
+
+static int
+unlzma_init(struct crypto_tfm *tfm)
+{
+	return 0;
+}
+
+static void
+unlzma_cancel(struct unlzma_ctx *ctx)
+{
+	unlzma_reset_buf(ctx);
+
+	if (!ctx->active)
+		return;
+
+	ctx->cancel = true;
+	do {
+		mutex_unlock(&ctx->mutex);
+		wake_up(&ctx->next_req);
+		schedule();
+		mutex_lock(&ctx->mutex);
+	} while (ctx->cancel);
+}
+
+
+static void
+unlzma_exit(struct crypto_tfm *tfm)
+{
+	struct unlzma_ctx *ctx = crypto_tfm_ctx(tfm);
+
+	if (ctx->thread) {
+		unlzma_cancel(ctx);
+		kthread_stop(ctx->thread);
+		ctx->thread = NULL;
+		if (ctx->buffers)
+			kfree(ctx->buffers);
+		ctx->buffers_max = 0;
+		ctx->buffers = NULL;
+	}
+}
+
+static int
+unlzma_decompress_setup(struct crypto_pcomp *tfm, void *p, unsigned int len)
+{
+	struct unlzma_ctx *ctx = crypto_tfm_ctx(crypto_pcomp_tfm(tfm));
+	struct nlattr *tb[UNLZMA_DECOMP_MAX + 1];
+	int ret = 0;
+
+	if (ctx->thread)
+		return -EINVAL;
+
+	if (!p)
+		return -EINVAL;
+
+	ret = nla_parse(tb, UNLZMA_DECOMP_MAX, p, len, NULL);
+	if (!tb[UNLZMA_DECOMP_OUT_BUFFERS])
+		return -EINVAL;
+
+	if (ctx->buffers_max && (ctx->buffers_max <
+	    nla_get_u32(tb[UNLZMA_DECOMP_OUT_BUFFERS]))) {
+		kfree(ctx->buffers);
+		ctx->buffers_max = 0;
+		ctx->buffers = NULL;
+	}
+	if (!ctx->buffers) {
+		ctx->buffers_max = nla_get_u32(tb[UNLZMA_DECOMP_OUT_BUFFERS]);
+		ctx->buffers = kzalloc(sizeof(struct unlzma_buffer) * ctx->buffers_max, GFP_KERNEL);
+	}
+	if (!ctx->buffers)
+		return -ENOMEM;
+
+	mutex_init(&ctx->mutex);
+	init_waitqueue_head(&ctx->next_req);
+	ctx->thread = kthread_run(unlzma_thread, ctx, "unlzma/%d", instance++);
+	if (IS_ERR(ctx->thread)) {
+		ret = PTR_ERR(ctx->thread);
+		ctx->thread = NULL;
+	}
+
+	return ret;
+}
+
+static int
+unlzma_decompress_init(struct crypto_pcomp *tfm)
+{
+	struct unlzma_ctx *ctx = crypto_tfm_ctx(crypto_pcomp_tfm(tfm));
+
+	ctx->pos = 0;
+	return 0;
+}
+
+static void
+unlzma_wait_complete(struct unlzma_ctx *ctx, bool finish)
+{
+	do {
+		mutex_unlock(&ctx->mutex);
+		wake_up(&ctx->next_req);
+		schedule();
+		mutex_lock(&ctx->mutex);
+	} while (ctx->active &&	(ctx->avail_in > 0) && (ctx->avail_out > 0));
+}
+
+static int
+unlzma_decompress_update(struct crypto_pcomp *tfm, struct comp_request *req)
+{
+	struct unlzma_ctx *ctx = crypto_tfm_ctx(crypto_pcomp_tfm(tfm));
+	size_t pos = 0;
+
+	mutex_lock(&ctx->mutex);
+	if (!ctx->active && !req->avail_in)
+		goto out;
+
+	pos = ctx->pos;
+	ctx->next_in = req->next_in;
+	ctx->avail_in = req->avail_in;
+	ctx->next_out = req->next_out;
+	ctx->avail_out = req->avail_out;
+
+	unlzma_wait_complete(ctx, false);
+
+	req->next_in = ctx->next_in;
+	req->avail_in = ctx->avail_in;
+	req->next_out = ctx->next_out;
+	req->avail_out = ctx->avail_out;
+	ctx->next_in = 0;
+	ctx->avail_in = 0;
+	pos = ctx->pos - pos;
+
+out:
+	mutex_unlock(&ctx->mutex);
+	return pos;
+}
+
+static int
+unlzma_decompress_final(struct crypto_pcomp *tfm, struct comp_request *req)
+{
+	struct unlzma_ctx *ctx = crypto_tfm_ctx(crypto_pcomp_tfm(tfm));
+	int ret = 0;
+
+	/* cancel pending operation */
+	mutex_lock(&ctx->mutex);
+	if (ctx->active) {
+		// ret = -EINVAL;
+		unlzma_cancel(ctx);
+	}
+	ctx->pos = 0;
+	mutex_unlock(&ctx->mutex);
+	return ret;
+}
+
+
+static struct pcomp_alg unlzma_alg = {
+	.decompress_setup	= unlzma_decompress_setup,
+	.decompress_init	= unlzma_decompress_init,
+	.decompress_update	= unlzma_decompress_update,
+	.decompress_final	= unlzma_decompress_final,
+
+	.base			= {
+		.cra_name	= "lzma",
+		.cra_flags	= CRYPTO_ALG_TYPE_PCOMPRESS,
+		.cra_ctxsize	= sizeof(struct unlzma_ctx),
+		.cra_module	= THIS_MODULE,
+		.cra_init	= unlzma_init,
+		.cra_exit	= unlzma_exit,
+	}
+};
+
+static int __init
+unlzma_mod_init(void)
+{
+	return crypto_register_pcomp(&unlzma_alg);
+}
+
+static void __exit
+unlzma_mod_exit(void)
+{
+	crypto_unregister_pcomp(&unlzma_alg);
+}
+
+module_init(unlzma_mod_init);
+module_exit(unlzma_mod_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("LZMA Decompression Algorithm");
+MODULE_AUTHOR("Felix Fietkau <nbd@openwrt.org>");
diff -Nru linux-2.6.30.5/crypto/unlzma.h linux-2.6.30.5-wrt/crypto/unlzma.h
--- linux-2.6.30.5/crypto/unlzma.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/crypto/unlzma.h	2009-09-06 18:43:48.342667486 +0200
@@ -0,0 +1,80 @@
+/* LZMA uncompresion module for pcomp
+ * Copyright (C) 2009  Felix Fietkau <nbd@openwrt.org>
+ *
+ * Based on:
+ *  Initial Linux kernel adaptation
+ *  Copyright (C) 2006  Alain < alain@knaff.lu >
+ *
+ *  Based on small lzma deflate implementation/Small range coder
+ *  implementation for lzma.
+ *  Copyright (C) 2006  Aurelien Jacobs < aurel@gnuage.org >
+ *
+ *  Based on LzmaDecode.c from the LZMA SDK 4.22 (http://www.7-zip.org/)
+ *  Copyright (C) 1999-2005  Igor Pavlov
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+#ifndef __UNLZMA_H
+#define __UNLZMA_H
+
+struct lzma_header {
+	__u8 pos;
+	__le32 dict_size;
+} __attribute__ ((packed)) ;
+
+
+#define RC_TOP_BITS 24
+#define RC_MOVE_BITS 5
+#define RC_MODEL_TOTAL_BITS 11
+
+#define LZMA_BASE_SIZE 1846
+#define LZMA_LIT_SIZE 768
+
+#define LZMA_NUM_POS_BITS_MAX 4
+
+#define LZMA_LEN_NUM_LOW_BITS 3
+#define LZMA_LEN_NUM_MID_BITS 3
+#define LZMA_LEN_NUM_HIGH_BITS 8
+
+#define LZMA_LEN_CHOICE 0
+#define LZMA_LEN_CHOICE_2 (LZMA_LEN_CHOICE + 1)
+#define LZMA_LEN_LOW (LZMA_LEN_CHOICE_2 + 1)
+#define LZMA_LEN_MID (LZMA_LEN_LOW \
+		      + (1 << (LZMA_NUM_POS_BITS_MAX + LZMA_LEN_NUM_LOW_BITS)))
+#define LZMA_LEN_HIGH (LZMA_LEN_MID \
+		       +(1 << (LZMA_NUM_POS_BITS_MAX + LZMA_LEN_NUM_MID_BITS)))
+#define LZMA_NUM_LEN_PROBS (LZMA_LEN_HIGH + (1 << LZMA_LEN_NUM_HIGH_BITS))
+
+#define LZMA_NUM_STATES 12
+#define LZMA_NUM_LIT_STATES 7
+
+#define LZMA_START_POS_MODEL_INDEX 4
+#define LZMA_END_POS_MODEL_INDEX 14
+#define LZMA_NUM_FULL_DISTANCES (1 << (LZMA_END_POS_MODEL_INDEX >> 1))
+
+#define LZMA_NUM_POS_SLOT_BITS 6
+#define LZMA_NUM_LEN_TO_POS_STATES 4
+
+#define LZMA_NUM_ALIGN_BITS 4
+
+#define LZMA_MATCH_MIN_LEN 2
+
+#define LZMA_IS_MATCH 0
+#define LZMA_IS_REP (LZMA_IS_MATCH + (LZMA_NUM_STATES << LZMA_NUM_POS_BITS_MAX))
+#define LZMA_IS_REP_G0 (LZMA_IS_REP + LZMA_NUM_STATES)
+#define LZMA_IS_REP_G1 (LZMA_IS_REP_G0 + LZMA_NUM_STATES)
+#define LZMA_IS_REP_G2 (LZMA_IS_REP_G1 + LZMA_NUM_STATES)
+#define LZMA_IS_REP_0_LONG (LZMA_IS_REP_G2 + LZMA_NUM_STATES)
+#define LZMA_POS_SLOT (LZMA_IS_REP_0_LONG \
+		       + (LZMA_NUM_STATES << LZMA_NUM_POS_BITS_MAX))
+#define LZMA_SPEC_POS (LZMA_POS_SLOT \
+		       +(LZMA_NUM_LEN_TO_POS_STATES << LZMA_NUM_POS_SLOT_BITS))
+#define LZMA_ALIGN (LZMA_SPEC_POS \
+		    + LZMA_NUM_FULL_DISTANCES - LZMA_END_POS_MODEL_INDEX)
+#define LZMA_LEN_CODER (LZMA_ALIGN + (1 << LZMA_NUM_ALIGN_BITS))
+#define LZMA_REP_LEN_CODER (LZMA_LEN_CODER + LZMA_NUM_LEN_PROBS)
+#define LZMA_LITERAL (LZMA_REP_LEN_CODER + LZMA_NUM_LEN_PROBS)
+
+#endif
diff -Nru linux-2.6.30.5/crypto/zlib.c linux-2.6.30.5-wrt/crypto/zlib.c
--- linux-2.6.30.5/crypto/zlib.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/crypto/zlib.c	2009-09-06 18:43:48.338666730 +0200
@@ -165,15 +165,15 @@
 		return -EINVAL;
 	}
 
+	ret = req->avail_out - stream->avail_out;
 	pr_debug("avail_in %u, avail_out %u (consumed %u, produced %u)\n",
 		 stream->avail_in, stream->avail_out,
-		 req->avail_in - stream->avail_in,
-		 req->avail_out - stream->avail_out);
+		 req->avail_in - stream->avail_in, ret);
 	req->next_in = stream->next_in;
 	req->avail_in = stream->avail_in;
 	req->next_out = stream->next_out;
 	req->avail_out = stream->avail_out;
-	return 0;
+	return ret;
 }
 
 static int zlib_compress_final(struct crypto_pcomp *tfm,
@@ -195,15 +195,15 @@
 		return -EINVAL;
 	}
 
+	ret = req->avail_out - stream->avail_out;
 	pr_debug("avail_in %u, avail_out %u (consumed %u, produced %u)\n",
 		 stream->avail_in, stream->avail_out,
-		 req->avail_in - stream->avail_in,
-		 req->avail_out - stream->avail_out);
+		 req->avail_in - stream->avail_in, ret);
 	req->next_in = stream->next_in;
 	req->avail_in = stream->avail_in;
 	req->next_out = stream->next_out;
 	req->avail_out = stream->avail_out;
-	return 0;
+	return ret;
 }
 
 
@@ -280,15 +280,15 @@
 		return -EINVAL;
 	}
 
+	ret = req->avail_out - stream->avail_out;
 	pr_debug("avail_in %u, avail_out %u (consumed %u, produced %u)\n",
 		 stream->avail_in, stream->avail_out,
-		 req->avail_in - stream->avail_in,
-		 req->avail_out - stream->avail_out);
+		 req->avail_in - stream->avail_in, ret);
 	req->next_in = stream->next_in;
 	req->avail_in = stream->avail_in;
 	req->next_out = stream->next_out;
 	req->avail_out = stream->avail_out;
-	return 0;
+	return ret;
 }
 
 static int zlib_decompress_final(struct crypto_pcomp *tfm,
@@ -328,15 +328,15 @@
 		return -EINVAL;
 	}
 
+	ret = req->avail_out - stream->avail_out;
 	pr_debug("avail_in %u, avail_out %u (consumed %u, produced %u)\n",
 		 stream->avail_in, stream->avail_out,
-		 req->avail_in - stream->avail_in,
-		 req->avail_out - stream->avail_out);
+		 req->avail_in - stream->avail_in, ret);
 	req->next_in = stream->next_in;
 	req->avail_in = stream->avail_in;
 	req->next_out = stream->next_out;
 	req->avail_out = stream->avail_out;
-	return 0;
+	return ret;
 }
 
 
diff -Nru linux-2.6.30.5/drivers/char/Kconfig linux-2.6.30.5-wrt/drivers/char/Kconfig
--- linux-2.6.30.5/drivers/char/Kconfig	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/char/Kconfig	2009-09-06 18:43:48.450668314 +0200
@@ -1016,6 +1016,13 @@
 
 	  If compiled as a module, it will be called cs5535_gpio.
 
+config GPIO_DEVICE
+	tristate "GPIO device support"
+	depends on GENERIC_GPIO
+	help
+	  Say Y to enable Linux GPIO device support.  This allows control of
+	  GPIO pins using a character device
+
 config GPIO_VR41XX
 	tristate "NEC VR4100 series General-purpose I/O Unit support"
 	depends on CPU_VR41XX
diff -Nru linux-2.6.30.5/drivers/char/Makefile linux-2.6.30.5-wrt/drivers/char/Makefile
--- linux-2.6.30.5/drivers/char/Makefile	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/char/Makefile	2009-09-06 18:43:48.450668314 +0200
@@ -94,6 +94,7 @@
 obj-$(CONFIG_PC8736x_GPIO)	+= pc8736x_gpio.o
 obj-$(CONFIG_NSC_GPIO)		+= nsc_gpio.o
 obj-$(CONFIG_CS5535_GPIO)	+= cs5535_gpio.o
+obj-$(CONFIG_GPIO_DEVICE)	+= gpio_dev.o
 obj-$(CONFIG_GPIO_VR41XX)	+= vr41xx_giu.o
 obj-$(CONFIG_GPIO_TB0219)	+= tb0219.o
 obj-$(CONFIG_TELCLOCK)		+= tlclk.o
diff -Nru linux-2.6.30.5/drivers/char/cs5535_gpio.c linux-2.6.30.5-wrt/drivers/char/cs5535_gpio.c
--- linux-2.6.30.5/drivers/char/cs5535_gpio.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/char/cs5535_gpio.c	2009-09-06 18:44:06.811167583 +0200
@@ -15,6 +15,7 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/cdev.h>
+#include <linux/device.h>
 #include <linux/ioport.h>
 #include <linux/pci.h>
 #include <linux/smp_lock.h>
@@ -48,6 +49,7 @@
 MODULE_DEVICE_TABLE(pci, divil_pci);
 
 static struct cdev cs5535_gpio_cdev;
+static struct class *cs5535_gpio_class;
 
 /* reserve 32 entries even though some aren't usable */
 #define CS5535_GPIO_COUNT	32
@@ -66,9 +68,14 @@
 	{ 0x30, 0x00, '1', '0' },	/* GPIOx_READ_BACK / GPIOx_OUT_VAL */
 	{ 0x20, 0x20, 'I', 'i' },	/* GPIOx_IN_EN */
 	{ 0x04, 0x04, 'O', 'o' },	/* GPIOx_OUT_EN */
+	{ 0x10, 0x10, 'A', 'a' },	/* GPIOx_OUT_AUX1_SEL */
+	{ 0x14, 0x14, 'B', 'b' },	/* GPIOx_OUT_AUX2_SEL */
 	{ 0x08, 0x08, 't', 'T' },	/* GPIOx_OUT_OD_EN */
 	{ 0x18, 0x18, 'P', 'p' },	/* GPIOx_OUT_PU_EN */
 	{ 0x1c, 0x1c, 'D', 'd' },	/* GPIOx_OUT_PD_EN */
+	{ 0x24, 0x24, 'N', 'n' },	/* GPIOx_IN_INV_EN */
+	{ 0x0c, 0x0c, 'X', 'x' },	/* GPIOx_OUT_INV_EN */
+	{ 0x00, 0x00, 'H', 'L' },	/* GPIOx_OUT_VAL */
 };
 
 
@@ -177,7 +184,7 @@
 {
 	dev_t	dev_id;
 	u32	low, hi;
-	int	retval;
+	int	retval, i;
 
 	if (pci_dev_present(divil_pci) == 0) {
 		printk(KERN_WARNING NAME ": DIVIL not found\n");
@@ -232,23 +239,54 @@
 		major = MAJOR(dev_id);
 	}
 
-	if (retval) {
-		release_region(gpio_base, CS5535_GPIO_SIZE);
-		return -1;
-	}
+	if (retval)
+		goto error;
 
 	printk(KERN_DEBUG NAME ": base=%#x mask=%#lx major=%d\n",
 	       gpio_base, mask, major);
 
 	cdev_init(&cs5535_gpio_cdev, &cs5535_gpio_fops);
-	cdev_add(&cs5535_gpio_cdev, dev_id, CS5535_GPIO_COUNT);
+	retval = cdev_add(&cs5535_gpio_cdev, dev_id, CS5535_GPIO_COUNT);
+	if (retval) {
+		kobject_put(&cs5535_gpio_cdev.kobj);
+		goto error_region;
+	}
+
+	cs5535_gpio_class = class_create(THIS_MODULE, "cs5535_gpio");
+	if (IS_ERR(cs5535_gpio_class)) {
+		printk(KERN_ERR "Error creating cs5535_gpio class\n");
+		cdev_del(&cs5535_gpio_cdev);
+		retval = PTR_ERR(cs5535_gpio_class);
+		goto error_region;
+	}
+
+	for (i = 0; i < CS5535_GPIO_COUNT; i++) {
+		if (mask & (1<<i)) {
+			device_create(cs5535_gpio_class, NULL, MKDEV(major, i), NULL, "cs5535_gpio%d", i);
+		}
+	}
 
 	return 0;
+
+error_region:
+	unregister_chrdev_region(dev_id, CS5535_GPIO_COUNT);
+error:
+	release_region(gpio_base, CS5535_GPIO_SIZE);
+	return retval;
 }
 
 static void __exit cs5535_gpio_cleanup(void)
 {
 	dev_t dev_id = MKDEV(major, 0);
+	int i;
+
+	for (i = 0; i < CS5535_GPIO_COUNT; i++) {
+		if (mask & (1<<i)) {
+			device_destroy(cs5535_gpio_class, MKDEV(major, i));
+		}
+	}
+
+	class_destroy(cs5535_gpio_class);
 
 	cdev_del(&cs5535_gpio_cdev);
 	unregister_chrdev_region(dev_id, CS5535_GPIO_COUNT);
diff -Nru linux-2.6.30.5/drivers/char/gpio_dev.c linux-2.6.30.5-wrt/drivers/char/gpio_dev.c
--- linux-2.6.30.5/drivers/char/gpio_dev.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/drivers/char/gpio_dev.c	2009-09-06 18:43:20.906698817 +0200
@@ -0,0 +1,201 @@
+/*
+ * character device wrapper for generic gpio layer
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA02111-1307USA
+ *
+ * Feedback, Bugs...  blogic@openwrt.org
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/gpio.h>
+#include <asm/atomic.h>
+#include <linux/init.h>
+#include <linux/genhd.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/gpio_dev.h>
+
+#define DRVNAME		"gpiodev"
+#define DEVNAME		"gpio"
+
+static int dev_major;
+static unsigned int gpio_access_mask;
+static struct class *gpiodev_class;
+
+/* Counter is 1, if the device is not opened and zero (or less) if opened. */
+static atomic_t gpio_open_cnt = ATOMIC_INIT(1);
+
+static int
+gpio_ioctl(struct inode * inode, struct file * file, unsigned int cmd, unsigned long arg)
+{
+	int retval = 0;
+
+	if (((1 << arg) & gpio_access_mask) != (1 << arg))
+	{
+		retval = -EINVAL;
+		goto out;
+	}
+
+	switch (cmd)
+	{
+	case GPIO_GET:
+		retval = gpio_get_value(arg);
+		break;
+
+	case GPIO_SET:
+		gpio_set_value(arg, 1);
+		break;
+
+	case GPIO_CLEAR:
+		gpio_set_value(arg, 0);
+		break;
+
+	case GPIO_DIR_IN:
+		gpio_direction_input(arg);
+		break;
+
+	case GPIO_DIR_OUT:
+		gpio_direction_output(arg, 0);
+		break;
+
+	default:
+		retval = -EINVAL;
+		break;
+	}
+
+out:
+	return retval;
+}
+
+static int
+gpio_open(struct inode *inode, struct file *file)
+{
+	int result = 0;
+	unsigned int dev_minor = MINOR(inode->i_rdev);
+
+	if (dev_minor != 0)
+	{
+		printk(KERN_ERR DRVNAME ": trying to access unknown minor device -> %d\n", dev_minor);
+		result = -ENODEV;
+		goto out;
+	}
+
+	/* FIXME: We should really allow multiple applications to open the device
+	 *        at the same time, as long as the apps access different IO pins.
+	 *        The generic gpio-registration functions can be used for that.
+	 *        Two new IOCTLs have to be introduced for that. Need to check userspace
+	 *        compatibility first. --mb */
+	if (!atomic_dec_and_test(&gpio_open_cnt)) {
+		atomic_inc(&gpio_open_cnt);
+		printk(KERN_ERR DRVNAME ": Device with minor ID %d already in use\n", dev_minor);
+		result = -EBUSY;
+		goto out;
+	}
+
+out:
+	return result;
+}
+
+static int
+gpio_close(struct inode * inode, struct file * file)
+{
+	smp_mb__before_atomic_inc();
+	atomic_inc(&gpio_open_cnt);
+
+	return 0;
+}
+
+struct file_operations gpio_fops = {
+	ioctl:		gpio_ioctl,
+	open:		gpio_open,
+	release:	gpio_close
+};
+
+static int
+gpio_probe(struct platform_device *dev)
+{
+	int result = 0;
+
+	dev_major = register_chrdev(0, DEVNAME, &gpio_fops);
+	if (!dev_major)
+	{
+		printk(KERN_ERR DRVNAME ": Error whilst opening %s \n", DEVNAME);
+		result = -ENODEV;
+		goto out;
+	}
+
+	gpiodev_class = class_create(THIS_MODULE, DRVNAME);
+	device_create(gpiodev_class, NULL, MKDEV(dev_major, 0), dev, DEVNAME);
+
+	printk(KERN_INFO DRVNAME ": gpio device registered with major %d\n", dev_major);
+
+	if (dev->num_resources != 1)
+	{
+		printk(KERN_ERR DRVNAME ": device may only have 1 resource\n");
+		result = -ENODEV;
+		goto out;
+	}
+
+	gpio_access_mask = dev->resource[0].start;
+
+	printk(KERN_INFO DRVNAME ": gpio platform device registered with access mask %08X\n", gpio_access_mask);
+out:
+	return result;
+}
+
+static int
+gpio_remove(struct platform_device *dev)
+{
+	unregister_chrdev(dev_major, DEVNAME);
+	return 0;
+}
+
+static struct
+platform_driver gpio_driver = {
+	.probe = gpio_probe,
+	.remove = gpio_remove,
+	.driver = {
+		.name = "GPIODEV",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init
+gpio_mod_init(void)
+{
+	int ret = platform_driver_register(&gpio_driver);
+	if (ret)
+		printk(KERN_INFO DRVNAME ": Error registering platfom driver!");
+
+	return ret;
+}
+
+static void __exit
+gpio_mod_exit(void)
+{
+	platform_driver_unregister(&gpio_driver);
+}
+
+module_init (gpio_mod_init);
+module_exit (gpio_mod_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("John Crispin / OpenWrt");
+MODULE_DESCRIPTION("Character device for for generic gpio api");
diff -Nru linux-2.6.30.5/drivers/char/random.c linux-2.6.30.5-wrt/drivers/char/random.c
--- linux-2.6.30.5/drivers/char/random.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/char/random.c	2009-09-06 18:44:06.835168037 +0200
@@ -129,6 +129,9 @@
  *                                unsigned int value);
  * 	void add_interrupt_randomness(int irq);
  *
+ *      void random_input_words(__u32 *buf, size_t wordcount, int ent_count)
+ *      int random_input_wait(void);
+ *
  * add_input_randomness() uses the input layer interrupt timing, as well as
  * the event type information from the hardware.
  *
@@ -140,6 +143,13 @@
  * a better measure, since the timing of the disk interrupts are more
  * unpredictable.
  *
+ * random_input_words() just provides a raw block of entropy to the input
+ * pool, such as from a hardware entropy generator.
+ *
+ * random_input_wait() suspends the caller until such time as the
+ * entropy pool falls below the write threshold, and returns a count of how
+ * much entropy (in bits) is needed to sustain the pool.
+ *
  * All of these routines try to estimate how many bits of randomness a
  * particular randomness source.  They do this by keeping track of the
  * first and second order deltas of the event timings.
@@ -712,6 +722,61 @@
 }
 #endif
 
+/*
+ * random_input_words - add bulk entropy to pool
+ *
+ * @buf: buffer to add
+ * @wordcount: number of __u32 words to add
+ * @ent_count: total amount of entropy (in bits) to credit
+ *
+ * this provides bulk input of entropy to the input pool
+ *
+ */
+void random_input_words(__u32 *buf, size_t wordcount, int ent_count)
+{
+	mix_pool_bytes(&input_pool, buf, wordcount*4);
+
+	credit_entropy_bits(&input_pool, ent_count);
+
+	DEBUG_ENT("crediting %d bits => %d\n",
+		  ent_count, input_pool.entropy_count);
+	/*
+	 * Wake up waiting processes if we have enough
+	 * entropy.
+	 */
+	if (input_pool.entropy_count >= random_read_wakeup_thresh)
+		wake_up_interruptible(&random_read_wait);
+}
+EXPORT_SYMBOL(random_input_words);
+
+/*
+ * random_input_wait - wait until random needs entropy
+ *
+ * this function sleeps until the /dev/random subsystem actually
+ * needs more entropy, and then return the amount of entropy
+ * that it would be nice to have added to the system.
+ */
+int random_input_wait(void)
+{
+	int count;
+
+	wait_event_interruptible(random_write_wait, 
+			 input_pool.entropy_count < random_write_wakeup_thresh);
+
+	count = random_write_wakeup_thresh - input_pool.entropy_count;
+
+        /* likely we got woken up due to a signal */
+	if (count <= 0) count = random_read_wakeup_thresh; 
+
+	DEBUG_ENT("requesting %d bits from input_wait()er %d<%d\n",
+		  count,
+		  input_pool.entropy_count, random_write_wakeup_thresh);
+
+	return count;
+}
+EXPORT_SYMBOL(random_input_wait);
+
+
 #define EXTRACT_SIZE 10
 
 /*********************************************************************
diff -Nru linux-2.6.30.5/drivers/i2c/busses/i2c-gpio.c linux-2.6.30.5-wrt/drivers/i2c/busses/i2c-gpio.c
--- linux-2.6.30.5/drivers/i2c/busses/i2c-gpio.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/i2c/busses/i2c-gpio.c	2009-09-06 18:44:06.815168492 +0200
@@ -210,7 +210,7 @@
 
 	return ret;
 }
-module_init(i2c_gpio_init);
+subsys_initcall(i2c_gpio_init);
 
 static void __exit i2c_gpio_exit(void)
 {
diff -Nru linux-2.6.30.5/drivers/input/misc/Kconfig linux-2.6.30.5-wrt/drivers/input/misc/Kconfig
--- linux-2.6.30.5/drivers/input/misc/Kconfig	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/input/misc/Kconfig	2009-09-06 18:43:48.450668314 +0200
@@ -250,4 +250,20 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called rb532_button.
 
+config INPUT_GPIO_BUTTONS
+	tristate "Polled GPIO buttons interface"
+	depends on GENERIC_GPIO
+	select INPUT_POLLDEV
+	help
+	  This driver implements support for buttons connected
+	  to GPIO pins of various CPUs (and some other chips).
+
+	  Say Y here if your device has buttons connected
+	  directly to such GPIO pins.  Your board-specific
+	  setup logic must also provide a platform device,
+	  with configuration data saying which GPIOs are used.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called gpio-buttons.
+
 endif
diff -Nru linux-2.6.30.5/drivers/input/misc/Makefile linux-2.6.30.5-wrt/drivers/input/misc/Makefile
--- linux-2.6.30.5/drivers/input/misc/Makefile	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/input/misc/Makefile	2009-09-06 18:43:48.450668314 +0200
@@ -24,3 +24,4 @@
 obj-$(CONFIG_INPUT_UINPUT)		+= uinput.o
 obj-$(CONFIG_INPUT_WISTRON_BTNS)	+= wistron_btns.o
 obj-$(CONFIG_INPUT_YEALINK)		+= yealink.o
+obj-$(CONFIG_INPUT_GPIO_BUTTONS)	+= gpio_buttons.o
diff -Nru linux-2.6.30.5/drivers/input/misc/gpio_buttons.c linux-2.6.30.5-wrt/drivers/input/misc/gpio_buttons.c
--- linux-2.6.30.5/drivers/input/misc/gpio_buttons.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/drivers/input/misc/gpio_buttons.c	2009-09-06 18:43:20.906698817 +0200
@@ -0,0 +1,209 @@
+/*
+ *  Driver for buttons on GPIO lines not capable of generating interrupts
+ *
+ *  Copyright (C) 2007,2008 Gabor Juhos <juhosg at openwrt.org>
+ *
+ *  This file was based on: /drivers/input/misc/cobalt_btns.c
+ *	Copyright (C) 2007 Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
+ *
+ *  also was based on: /drivers/input/keyboard/gpio_keys.c
+ *	Copyright 2005 Phil Blundell
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <linux/input.h>
+#include <linux/input-polldev.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+
+#include <linux/gpio_buttons.h>
+
+#include <asm/gpio.h>
+
+#define DRV_NAME	"gpio-buttons"
+#define DRV_VERSION	"0.1.1"
+#define PFX		DRV_NAME ": "
+
+struct gpio_buttons_dev {
+	struct input_polled_dev *poll_dev;
+	struct gpio_buttons_platform_data *pdata;
+};
+
+static void gpio_buttons_poll(struct input_polled_dev *dev)
+{
+	struct gpio_buttons_dev *bdev = dev->private;
+	struct gpio_buttons_platform_data *pdata = bdev->pdata;
+	struct input_dev *input = dev->input;
+	int i;
+
+	for (i = 0; i < bdev->pdata->nbuttons; i++) {
+		struct gpio_button *button = &pdata->buttons[i];
+		unsigned int type = button->type ?: EV_KEY;
+		int state;
+
+		state = gpio_get_value(button->gpio) ? 1 : 0;
+		state ^= button->active_low;
+
+		if (state) {
+			button->count++;
+		} else {
+			if (button->count >= button->threshold) {
+				input_event(input, type, button->code, 1);
+				input_sync(input);
+			}
+			button->count = 0;
+		}
+
+		if (button->count == button->threshold) {
+			input_event(input, type, button->code, 0);
+			input_sync(input);
+		}
+	}
+}
+
+static int __devinit gpio_buttons_probe(struct platform_device *pdev)
+{
+	struct gpio_buttons_platform_data *pdata = pdev->dev.platform_data;
+	struct gpio_buttons_dev *bdev;
+	struct input_polled_dev *poll_dev;
+	struct input_dev *input;
+	int error, i;
+
+
+	if (!pdata)
+		return -ENXIO;
+
+	bdev = kzalloc(sizeof(*bdev), GFP_KERNEL);
+	if (!bdev) {
+		printk(KERN_ERR DRV_NAME "no memory for device\n");
+		return -ENOMEM;
+	}
+
+	poll_dev = input_allocate_polled_device();
+	if (!poll_dev) {
+		printk(KERN_ERR DRV_NAME "no memory for polled device\n");
+		error = -ENOMEM;
+		goto err_free_bdev;
+	}
+
+	poll_dev->private = bdev;
+	poll_dev->poll = gpio_buttons_poll;
+	poll_dev->poll_interval = pdata->poll_interval;
+
+	input = poll_dev->input;
+
+	input->evbit[0] = BIT(EV_KEY);
+	input->name = pdev->name;
+	input->phys = "gpio-buttons/input0";
+	input->dev.parent = &pdev->dev;
+
+	input->id.bustype = BUS_HOST;
+	input->id.vendor = 0x0001;
+	input->id.product = 0x0001;
+	input->id.version = 0x0100;
+
+	for (i = 0; i < pdata->nbuttons; i++) {
+		struct gpio_button *button = &pdata->buttons[i];
+		unsigned int gpio = button->gpio;
+		unsigned int type = button->type ?: EV_KEY;
+
+		error = gpio_request(gpio, button->desc ?
+				button->desc : DRV_NAME);
+		if (error) {
+			printk(KERN_ERR PFX "unable to claim gpio %u, "
+				"error %d\n", gpio, error);
+			goto err_free_gpio;
+		}
+
+		error = gpio_direction_input(gpio);
+		if (error) {
+			printk(KERN_ERR PFX "unable to set direction on "
+				"gpio %u, error %d\n", gpio, error);
+			goto err_free_gpio;
+		}
+
+		input_set_capability(input, type, button->code);
+		button->count = 0;
+	}
+
+	bdev->poll_dev = poll_dev;
+	bdev->pdata = pdata;
+	platform_set_drvdata(pdev, bdev);
+
+	error = input_register_polled_device(poll_dev);
+	if (error) {
+		printk(KERN_ERR PFX "unable to register polled device, "
+			"error %d\n", error);
+		goto err_free_gpio;
+	}
+
+	return 0;
+
+err_free_gpio:
+	for (i = i - 1; i >= 0; i--)
+		gpio_free(pdata->buttons[i].gpio);
+
+	input_free_polled_device(poll_dev);
+
+err_free_bdev:
+	kfree(bdev);
+
+	platform_set_drvdata(pdev, NULL);
+	return error;
+}
+
+static int __devexit gpio_buttons_remove(struct platform_device *pdev)
+{
+	struct gpio_buttons_dev *bdev = platform_get_drvdata(pdev);
+	struct gpio_buttons_platform_data *pdata = bdev->pdata;
+	int i;
+
+	input_unregister_polled_device(bdev->poll_dev);
+
+	for (i = 0; i < pdata->nbuttons; i++)
+		gpio_free(pdata->buttons[i].gpio);
+
+	input_free_polled_device(bdev->poll_dev);
+
+	kfree(bdev);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static struct platform_driver gpio_buttons_driver = {
+	.probe	= gpio_buttons_probe,
+	.remove	= __devexit_p(gpio_buttons_remove),
+	.driver	= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init gpio_buttons_init(void)
+{
+	printk(KERN_INFO DRV_NAME " driver version " DRV_VERSION "\n");
+	return platform_driver_register(&gpio_buttons_driver);
+}
+
+static void __exit gpio_buttons_exit(void)
+{
+	platform_driver_unregister(&gpio_buttons_driver);
+}
+
+module_init(gpio_buttons_init);
+module_exit(gpio_buttons_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Gabor Juhos <juhosg at openwrt.org>");
+MODULE_VERSION(DRV_VERSION);
+MODULE_DESCRIPTION("Polled buttons driver for CPU GPIOs");
+
diff -Nru linux-2.6.30.5/drivers/leds/Kconfig linux-2.6.30.5-wrt/drivers/leds/Kconfig
--- linux-2.6.30.5/drivers/leds/Kconfig	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/leds/Kconfig	2009-09-06 18:43:48.446709118 +0200
@@ -295,4 +295,15 @@
 comment "iptables trigger is under Netfilter config (LED target)"
 	depends on LEDS_TRIGGERS
 
+config LEDS_TRIGGER_MORSE
+	tristate "LED Morse Trigger"
+	depends on LEDS_TRIGGERS
+
+config LEDS_TRIGGER_NETDEV
+	tristate "LED Netdev Trigger"
+	depends on LEDS_TRIGGERS
+	help
+	  This allows LEDs to be controlled by network device activity.
+	  If unsure, say Y.
+
 endif # NEW_LEDS
diff -Nru linux-2.6.30.5/drivers/leds/Makefile linux-2.6.30.5-wrt/drivers/leds/Makefile
--- linux-2.6.30.5/drivers/leds/Makefile	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/leds/Makefile	2009-09-06 18:43:48.446709118 +0200
@@ -38,3 +38,5 @@
 obj-$(CONFIG_LEDS_TRIGGER_BACKLIGHT)	+= ledtrig-backlight.o
 obj-$(CONFIG_LEDS_TRIGGER_GPIO)		+= ledtrig-gpio.o
 obj-$(CONFIG_LEDS_TRIGGER_DEFAULT_ON)	+= ledtrig-default-on.o
+obj-$(CONFIG_LEDS_TRIGGER_MORSE)	+= ledtrig-morse.o
+obj-$(CONFIG_LEDS_TRIGGER_NETDEV)      += ledtrig-netdev.o
diff -Nru linux-2.6.30.5/drivers/leds/leds-alix.c linux-2.6.30.5-wrt/drivers/leds/leds-alix.c
--- linux-2.6.30.5/drivers/leds/leds-alix.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/drivers/leds/leds-alix.c	2009-09-06 18:43:20.906698817 +0200
@@ -0,0 +1,172 @@
+/*
+ * LEDs driver for PCEngines ALIX 2/3 series
+ *
+ * Copyright (C) 2007 Petr Liebman
+ *
+ * Based on leds-wrap.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/leds.h>
+#include <linux/err.h>
+#include <asm/io.h>
+
+#define DRVNAME "alix-led"
+
+#define ALIX_LED1_PORT		(0x6100)
+#define ALIX_LED1_ON		(1<<22)
+#define ALIX_LED1_OFF		(1<<6)
+
+#define ALIX_LED2_PORT		(0x6180)
+#define ALIX_LED2_ON		(1<<25)
+#define ALIX_LED2_OFF		(1<<9)
+
+#define ALIX_LED3_PORT		(0x6180)
+#define ALIX_LED3_ON		(1<<27)
+#define ALIX_LED3_OFF		(1<<11)
+
+
+static struct platform_device *pdev;
+
+static void alix_led_set_1(struct led_classdev *led_cdev,
+		enum led_brightness value)
+{
+	if (value)
+		outl(ALIX_LED1_ON, ALIX_LED1_PORT);
+	else
+		outl(ALIX_LED1_OFF, ALIX_LED1_PORT);
+}
+
+static void alix_led_set_2(struct led_classdev *led_cdev,
+		enum led_brightness value)
+{
+	if (value)
+		outl(ALIX_LED2_ON, ALIX_LED2_PORT);
+	else
+		outl(ALIX_LED2_OFF, ALIX_LED2_PORT);
+}
+
+static void alix_led_set_3(struct led_classdev *led_cdev,
+		enum led_brightness value)
+{
+	if (value)
+		outl(ALIX_LED3_ON, ALIX_LED3_PORT);
+	else
+		outl(ALIX_LED3_OFF, ALIX_LED3_PORT);
+}
+
+static struct led_classdev alix_led_1 = {
+	.name		= "alix:1",
+	.brightness_set	= alix_led_set_1,
+};
+
+static struct led_classdev alix_led_2 = {
+	.name		= "alix:2",
+	.brightness_set	= alix_led_set_2,
+};
+
+static struct led_classdev alix_led_3 = {
+	.name		= "alix:3",
+	.brightness_set	= alix_led_set_3,
+};
+
+
+#ifdef CONFIG_PM
+static int alix_led_suspend(struct platform_device *dev,
+		pm_message_t state)
+{
+	led_classdev_suspend(&alix_led_1);
+	led_classdev_suspend(&alix_led_2);
+	led_classdev_suspend(&alix_led_3);
+	return 0;
+}
+
+static int alix_led_resume(struct platform_device *dev)
+{
+	led_classdev_resume(&alix_led_1);
+	led_classdev_resume(&alix_led_2);
+	led_classdev_resume(&alix_led_3);
+	return 0;
+}
+#else
+#define alix_led_suspend NULL
+#define alix_led_resume NULL
+#endif
+
+static int alix_led_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	ret = led_classdev_register(&pdev->dev, &alix_led_1);
+	if (ret >= 0)
+	{
+		ret = led_classdev_register(&pdev->dev, &alix_led_2);
+		if (ret >= 0)
+		{
+			ret = led_classdev_register(&pdev->dev, &alix_led_3);
+			if (ret < 0)
+				led_classdev_unregister(&alix_led_2);
+		}
+		if (ret < 0)
+			led_classdev_unregister(&alix_led_1);
+	}
+	return ret;
+}
+
+static int alix_led_remove(struct platform_device *pdev)
+{
+	led_classdev_unregister(&alix_led_1);
+	led_classdev_unregister(&alix_led_2);
+	led_classdev_unregister(&alix_led_3);
+	return 0;
+}
+
+static struct platform_driver alix_led_driver = {
+	.probe		= alix_led_probe,
+	.remove		= alix_led_remove,
+	.suspend	= alix_led_suspend,
+	.resume		= alix_led_resume,
+	.driver		= {
+		.name		= DRVNAME,
+		.owner		= THIS_MODULE,
+	},
+};
+
+static int __init alix_led_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&alix_led_driver);
+	if (ret < 0)
+		goto out;
+
+	pdev = platform_device_register_simple(DRVNAME, -1, NULL, 0);
+	if (IS_ERR(pdev)) {
+		ret = PTR_ERR(pdev);
+		platform_driver_unregister(&alix_led_driver);
+		goto out;
+	}
+
+out:
+	return ret;
+}
+
+static void __exit alix_led_exit(void)
+{
+	platform_device_unregister(pdev);
+	platform_driver_unregister(&alix_led_driver);
+}
+
+module_init(alix_led_init);
+module_exit(alix_led_exit);
+
+MODULE_AUTHOR("Petr Liebman");
+MODULE_DESCRIPTION("PCEngines ALIX LED driver");
+MODULE_LICENSE("GPL");
+
diff -Nru linux-2.6.30.5/drivers/leds/ledtrig-morse.c linux-2.6.30.5-wrt/drivers/leds/ledtrig-morse.c
--- linux-2.6.30.5/drivers/leds/ledtrig-morse.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/drivers/leds/ledtrig-morse.c	2009-09-06 18:43:20.906698817 +0200
@@ -0,0 +1,365 @@
+/*
+ *  LED Morse Trigger
+ *
+ *  Copyright (C) 2007 Gabor Juhos <juhosg at openwrt.org>
+ *
+ *  This file was based on: drivers/led/ledtrig-timer.c
+ *	Copyright 2005-2006 Openedhand Ltd.
+ *	Author: Richard Purdie <rpurdie@openedhand.com>
+ *
+ *  also based on the patch '[PATCH] 2.5.59 morse code panics' posted
+ *  in the LKML by Tomas Szepe at Thu, 30 Jan 2003
+ *	Copyright (C) 2002 Andrew Rodland <arodland@noln.com>
+ *	Copyright (C) 2003 Tomas Szepe <szepe@pinerecords.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/jiffies.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/device.h>
+#include <linux/sysdev.h>
+#include <linux/timer.h>
+#include <linux/ctype.h>
+#include <linux/leds.h>
+
+#include "leds.h"
+
+#define MORSE_DELAY_BASE	(HZ/2)
+
+#define MORSE_STATE_BLINK_START	0
+#define MORSE_STATE_BLINK_STOP	1
+
+#define MORSE_DIT_LEN	1
+#define MORSE_DAH_LEN	3
+#define MORSE_SPACE_LEN	7
+
+struct morse_trig_data {
+	unsigned long delay;
+	char *msg;
+
+	unsigned char morse;
+	unsigned char state;
+	char *msgpos;
+	struct timer_list timer;
+};
+
+const unsigned char morsetable[] = {
+	0122, 0, 0310, 0, 0, 0163,				/* "#$%&' */
+	055, 0155, 0, 0, 0163, 0141, 0152, 0051, 		/* ()*+,-./ */
+	077, 076, 074, 070, 060, 040, 041, 043, 047, 057,	/* 0-9 */
+	0107, 0125, 0, 0061, 0, 0114, 0, 			/* :;<=>?@ */
+	006, 021, 025, 011, 002, 024, 013, 020, 004,		/* A-I */
+	036, 015, 022, 007, 005, 017, 026, 033, 012,		/* J-R */
+	010, 003, 014, 030, 016, 031, 035, 023,			/* S-Z */
+	0, 0, 0, 0, 0154					/* [\]^_ */
+};
+
+static inline unsigned char tomorse(char c) {
+	if (c >= 'a' && c <= 'z')
+		c = c - 'a' + 'A';
+	if (c >= '"' && c <= '_') {
+		return morsetable[c - '"'];
+	} else
+		return 0;
+}
+
+static inline unsigned long dit_len(struct morse_trig_data *morse_data)
+{
+	return MORSE_DIT_LEN*morse_data->delay;
+}
+
+static inline unsigned long dah_len(struct morse_trig_data *morse_data)
+{
+	return MORSE_DAH_LEN*morse_data->delay;
+}
+
+static inline unsigned long space_len(struct morse_trig_data *morse_data)
+{
+	return MORSE_SPACE_LEN*morse_data->delay;
+}
+
+static void morse_timer_function(unsigned long data)
+{
+	struct led_classdev *led_cdev = (struct led_classdev *)data;
+	struct morse_trig_data *morse_data = led_cdev->trigger_data;
+	unsigned long brightness = LED_OFF;
+	unsigned long delay = 0;
+
+	if (!morse_data->msg)
+		goto set_led;
+
+	switch (morse_data->state) {
+	case MORSE_STATE_BLINK_START:
+		/* Starting a new blink.  We have a valid code in morse. */
+		delay = (morse_data->morse & 001) ? dah_len(morse_data):
+			dit_len(morse_data);
+		brightness = LED_FULL;
+		morse_data->state = MORSE_STATE_BLINK_STOP;
+		morse_data->morse >>= 1;
+		break;
+	case MORSE_STATE_BLINK_STOP:
+		/* Coming off of a blink. */
+		morse_data->state = MORSE_STATE_BLINK_START;
+
+		if (morse_data->morse > 1) {
+			/* Not done yet, just a one-dit pause. */
+			delay = dit_len(morse_data);
+			break;
+		}
+
+		/* Get a new char, figure out how much space. */
+		/* First time through */
+		if (!morse_data->msgpos)
+			morse_data->msgpos = (char *)morse_data->msg;
+
+		if (!*morse_data->msgpos) {
+			/* Repeating */
+			morse_data->msgpos = (char *)morse_data->msg;
+			delay = space_len(morse_data);
+		} else {
+			/* Inter-letter space */
+			delay = dah_len(morse_data);
+		}
+
+		if (!(morse_data->morse = tomorse(*morse_data->msgpos))) {
+			delay = space_len(morse_data);
+			/* And get us back here */
+			morse_data->state = MORSE_STATE_BLINK_STOP;
+		}
+		morse_data->msgpos++;
+		break;
+	}
+
+	mod_timer(&morse_data->timer, jiffies + msecs_to_jiffies(delay));
+
+set_led:
+	led_set_brightness(led_cdev, brightness);
+}
+
+static ssize_t _morse_delay_show(struct led_classdev *led_cdev, char *buf)
+{
+	struct morse_trig_data *morse_data = led_cdev->trigger_data;
+
+	sprintf(buf, "%lu\n", morse_data->delay);
+
+	return strlen(buf) + 1;
+}
+
+static ssize_t _morse_delay_store(struct led_classdev *led_cdev,
+		const char *buf, size_t size)
+{
+	struct morse_trig_data *morse_data = led_cdev->trigger_data;
+	char *after;
+	unsigned long state = simple_strtoul(buf, &after, 10);
+	size_t count = after - buf;
+	int ret = -EINVAL;
+
+	if (*after && isspace(*after))
+		count++;
+
+	if (count == size) {
+		morse_data->delay = state;
+		mod_timer(&morse_data->timer, jiffies + 1);
+		ret = count;
+	}
+
+	return ret;
+}
+
+static ssize_t _morse_msg_show(struct led_classdev *led_cdev, char *buf)
+{
+	struct morse_trig_data *morse_data = led_cdev->trigger_data;
+
+	if (!morse_data->msg)
+		sprintf(buf, "<none>\n");
+	else
+		sprintf(buf, "%s\n", morse_data->msg);
+
+	return strlen(buf) + 1;
+}
+
+static ssize_t _morse_msg_store(struct led_classdev *led_cdev,
+		const char *buf, size_t size)
+{
+	struct morse_trig_data *morse_data = led_cdev->trigger_data;
+	char *m;
+
+	m = kmalloc(size, GFP_KERNEL);
+	if (!m)
+		return -ENOMEM;
+
+	memcpy(m,buf,size);
+	m[size]='\0';
+
+	if (morse_data->msg)
+		kfree(morse_data->msg);
+
+	morse_data->msg = m;
+	morse_data->msgpos = NULL;
+	morse_data->state = MORSE_STATE_BLINK_STOP;
+
+	mod_timer(&morse_data->timer, jiffies + 1);
+
+	return size;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)
+static ssize_t morse_delay_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+
+	return _morse_delay_show(led_cdev, buf);
+}
+
+static ssize_t morse_delay_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+
+	return _morse_delay_store(led_cdev, buf, size);
+}
+
+static ssize_t morse_msg_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+
+	return _morse_msg_show(led_cdev, buf);
+}
+
+static ssize_t morse_msg_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+
+	return _morse_msg_store(led_cdev, buf, size);
+}
+
+static DEVICE_ATTR(delay, 0644, morse_delay_show, morse_delay_store);
+static DEVICE_ATTR(message, 0644, morse_msg_show, morse_msg_store);
+
+#define led_device_create_file(leddev, attr) \
+	device_create_file(leddev->dev, &dev_attr_ ## attr)
+#define led_device_remove_file(leddev, attr) \
+	device_remove_file(leddev->dev, &dev_attr_ ## attr)
+
+#else
+static ssize_t morse_delay_show(struct class_device *dev, char *buf)
+{
+	struct led_classdev *led_cdev = class_get_devdata(dev);
+
+	return _morse_delay_show(led_cdev, buf);
+}
+
+static ssize_t morse_delay_store(struct class_device *dev, const char *buf,
+		size_t size)
+{
+	struct led_classdev *led_cdev = class_get_devdata(dev);
+
+	return _morse_delay_store(led_cdev, buf, size);
+}
+
+static ssize_t morse_msg_show(struct class_device *dev, char *buf)
+{
+	struct led_classdev *led_cdev = class_get_devdata(dev);
+
+	return _morse_msg_show(led_cdev, buf);
+}
+
+static ssize_t morse_msg_store(struct class_device *dev, const char *buf,
+				size_t size)
+{
+	struct led_classdev *led_cdev = class_get_devdata(dev);
+
+	return _morse_msg_store(led_cdev, buf, size);
+}
+
+static CLASS_DEVICE_ATTR(delay, 0644, morse_delay_show, morse_delay_store);
+static CLASS_DEVICE_ATTR(message, 0644, morse_msg_show, morse_msg_store);
+
+#define led_device_create_file(leddev, attr) \
+	class_device_create_file(leddev->class_dev, &class_device_attr_ ## attr)
+#define led_device_remove_file(leddev, attr) \
+	class_device_remove_file(leddev->class_dev, &class_device_attr_ ## attr)
+
+#endif
+
+static void morse_trig_activate(struct led_classdev *led_cdev)
+{
+	struct morse_trig_data *morse_data;
+	int rc;
+
+	morse_data = kzalloc(sizeof(*morse_data), GFP_KERNEL);
+	if (!morse_data)
+		return;
+
+	morse_data->delay = MORSE_DELAY_BASE;
+	init_timer(&morse_data->timer);
+	morse_data->timer.function = morse_timer_function;
+	morse_data->timer.data = (unsigned long)led_cdev;
+
+	rc = led_device_create_file(led_cdev, delay);
+	if (rc) goto err;
+
+	rc = led_device_create_file(led_cdev, message);
+	if (rc) goto err_delay;
+
+	led_cdev->trigger_data = morse_data;
+
+	return;
+
+err_delay:
+	led_device_remove_file(led_cdev, delay);
+err:
+	kfree(morse_data);
+}
+
+static void morse_trig_deactivate(struct led_classdev *led_cdev)
+{
+	struct morse_trig_data *morse_data = led_cdev->trigger_data;
+
+	if (!morse_data)
+		return;
+
+	led_device_remove_file(led_cdev, message);
+	led_device_remove_file(led_cdev, delay);
+
+	del_timer_sync(&morse_data->timer);
+	if (morse_data->msg)
+		kfree(morse_data->msg);
+
+	kfree(morse_data);
+}
+
+static struct led_trigger morse_led_trigger = {
+	.name		= "morse",
+	.activate	= morse_trig_activate,
+	.deactivate	= morse_trig_deactivate,
+};
+
+static int __init morse_trig_init(void)
+{
+	return led_trigger_register(&morse_led_trigger);
+}
+
+static void __exit morse_trig_exit(void)
+{
+	led_trigger_unregister(&morse_led_trigger);
+}
+
+module_init(morse_trig_init);
+module_exit(morse_trig_exit);
+
+MODULE_AUTHOR("Gabor Juhos <juhosg at openwrt.org>");
+MODULE_DESCRIPTION("Morse LED trigger");
+MODULE_LICENSE("GPL");
diff -Nru linux-2.6.30.5/drivers/leds/ledtrig-netdev.c linux-2.6.30.5-wrt/drivers/leds/ledtrig-netdev.c
--- linux-2.6.30.5/drivers/leds/ledtrig-netdev.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/drivers/leds/ledtrig-netdev.c	2009-09-06 18:43:20.906698817 +0200
@@ -0,0 +1,454 @@
+/*
+ * LED Kernel Netdev Trigger
+ *
+ * Toggles the LED to reflect the link and traffic state of a named net device
+ *
+ * Copyright 2007 Oliver Jowett <oliver@opencloud.com>
+ *
+ * Derived from ledtrig-timer.c which is:
+ *  Copyright 2005-2006 Openedhand Ltd.
+ *  Author: Richard Purdie <rpurdie@openedhand.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/jiffies.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/device.h>
+#include <linux/sysdev.h>
+#include <linux/netdevice.h>
+#include <linux/timer.h>
+#include <linux/ctype.h>
+#include <linux/leds.h>
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+#include <net/net_namespace.h>
+#endif
+
+#include "leds.h"
+
+/*
+ * Configurable sysfs attributes:
+ *
+ * device_name - network device name to monitor
+ *
+ * interval - duration of LED blink, in milliseconds
+ *
+ * mode - either "none" (LED is off) or a space separated list of one or more of:
+ *   link: LED's normal state reflects whether the link is up (has carrier) or not
+ *   tx:   LED blinks on transmitted data
+ *   rx:   LED blinks on receive data
+ * 
+ * Some suggestions:
+ *
+ *  Simple link status LED:
+ *  $ echo netdev >someled/trigger
+ *  $ echo eth0 >someled/device_name
+ *  $ echo link >someled/mode
+ *
+ *  Ethernet-style link/activity LED:
+ *  $ echo netdev >someled/trigger
+ *  $ echo eth0 >someled/device_name
+ *  $ echo "link tx rx" >someled/mode
+ *
+ *  Modem-style tx/rx LEDs:
+ *  $ echo netdev >led1/trigger
+ *  $ echo ppp0 >led1/device_name
+ *  $ echo tx >led1/mode
+ *  $ echo netdev >led2/trigger
+ *  $ echo ppp0 >led2/device_name
+ *  $ echo rx >led2/mode
+ *
+ */
+
+#define MODE_LINK 1
+#define MODE_TX   2
+#define MODE_RX   4
+
+struct led_netdev_data {
+	rwlock_t lock;
+
+	struct timer_list timer;
+	struct notifier_block notifier;
+
+	struct led_classdev *led_cdev;
+	struct net_device *net_dev;
+
+	char device_name[IFNAMSIZ];
+	unsigned interval;
+	unsigned mode;
+	unsigned link_up;
+	unsigned last_activity;
+};
+
+static void set_baseline_state(struct led_netdev_data *trigger_data)
+{
+	if ((trigger_data->mode & MODE_LINK) != 0 && trigger_data->link_up)
+		led_set_brightness(trigger_data->led_cdev, LED_FULL);
+	else
+		led_set_brightness(trigger_data->led_cdev, LED_OFF);
+
+	if ((trigger_data->mode & (MODE_TX | MODE_RX)) != 0 && trigger_data->link_up)
+		mod_timer(&trigger_data->timer, jiffies + trigger_data->interval);
+	else
+		del_timer(&trigger_data->timer);
+}
+
+static ssize_t led_device_name_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
+
+	read_lock(&trigger_data->lock);
+	sprintf(buf, "%s\n", trigger_data->device_name);
+	read_unlock(&trigger_data->lock);
+
+	return strlen(buf) + 1;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,21)
+extern struct net init_net;
+#endif
+
+static ssize_t led_device_name_store(struct device *dev,
+				     struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
+
+	if (size < 0 || size >= IFNAMSIZ)
+		return -EINVAL;
+
+	write_lock(&trigger_data->lock);
+
+	strcpy(trigger_data->device_name, buf);
+	if (size > 0 && trigger_data->device_name[size-1] == '\n')
+		trigger_data->device_name[size-1] = 0;
+
+	if (trigger_data->device_name[0] != 0) {
+		/* check for existing device to update from */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+		trigger_data->net_dev = dev_get_by_name(&init_net, trigger_data->device_name);
+#else
+		trigger_data->net_dev = dev_get_by_name(trigger_data->device_name);
+#endif
+		if (trigger_data->net_dev != NULL)
+			trigger_data->link_up = (dev_get_flags(trigger_data->net_dev) & IFF_LOWER_UP) != 0;
+		set_baseline_state(trigger_data); /* updates LEDs, may start timers */
+	}
+
+	write_unlock(&trigger_data->lock);
+	return size;
+}
+
+static DEVICE_ATTR(device_name, 0644, led_device_name_show, led_device_name_store);
+
+static ssize_t led_mode_show(struct device *dev,
+			     struct device_attribute *attr, char *buf)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
+
+	read_lock(&trigger_data->lock);
+
+	if (trigger_data->mode == 0) {
+		strcpy(buf, "none\n");
+	} else {
+		if (trigger_data->mode & MODE_LINK)
+			strcat(buf, "link ");
+		if (trigger_data->mode & MODE_TX)
+			strcat(buf, "tx ");
+		if (trigger_data->mode & MODE_RX)
+			strcat(buf, "rx ");
+		strcat(buf, "\n");
+	}
+
+	read_unlock(&trigger_data->lock);
+
+	return strlen(buf)+1;
+}
+
+static ssize_t led_mode_store(struct device *dev,
+			      struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
+	char copybuf[1024];
+	int new_mode = -1;
+	char *p, *token;
+
+	/* take a copy since we don't want to trash the inbound buffer when using strsep */
+	strncpy(copybuf, buf, sizeof(copybuf));
+	copybuf[1023] = 0;
+	p = copybuf;
+
+	while ((token = strsep(&p, " \t\n")) != NULL) {
+		if (!*token)
+			continue;
+
+		if (new_mode == -1)
+			new_mode = 0;
+
+		if (!strcmp(token, "none"))
+			new_mode = 0;
+		else if (!strcmp(token, "tx"))
+			new_mode |= MODE_TX;
+		else if (!strcmp(token, "rx"))
+			new_mode |= MODE_RX;
+		else if (!strcmp(token, "link"))
+			new_mode |= MODE_LINK;
+		else
+			return -EINVAL;
+	}
+
+	if (new_mode == -1)
+		return -EINVAL;
+
+	write_lock(&trigger_data->lock);
+	trigger_data->mode = new_mode;
+	set_baseline_state(trigger_data);
+	write_unlock(&trigger_data->lock);
+
+	return size;
+}
+
+static DEVICE_ATTR(mode, 0644, led_mode_show, led_mode_store);
+
+static ssize_t led_interval_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
+
+	read_lock(&trigger_data->lock);
+	sprintf(buf, "%u\n", jiffies_to_msecs(trigger_data->interval));
+	read_unlock(&trigger_data->lock);
+
+	return strlen(buf) + 1;
+}
+
+static ssize_t led_interval_store(struct device *dev,
+				  struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
+	int ret = -EINVAL;
+	char *after;
+	unsigned long value = simple_strtoul(buf, &after, 10);
+	size_t count = after - buf;
+
+	if (*after && isspace(*after))
+		count++;
+
+	/* impose some basic bounds on the timer interval */
+	if (count == size && value >= 5 && value <= 10000) {
+		write_lock(&trigger_data->lock);
+		trigger_data->interval = msecs_to_jiffies(value);
+		set_baseline_state(trigger_data); // resets timer
+		write_unlock(&trigger_data->lock);
+		ret = count;
+	}
+
+	return ret;
+}
+
+static DEVICE_ATTR(interval, 0644, led_interval_show, led_interval_store);
+
+static int netdev_trig_notify(struct notifier_block *nb,
+			      unsigned long evt,
+			      void *dv)
+{
+	struct net_device *dev = dv;
+	struct led_netdev_data *trigger_data = container_of(nb, struct led_netdev_data, notifier);
+
+	if (evt != NETDEV_UP && evt != NETDEV_DOWN && evt != NETDEV_CHANGE && evt != NETDEV_REGISTER && evt != NETDEV_UNREGISTER)
+		return NOTIFY_DONE;
+
+	write_lock(&trigger_data->lock);
+
+	if (strcmp(dev->name, trigger_data->device_name))
+		goto done;
+
+	if (evt == NETDEV_REGISTER) {
+		if (trigger_data->net_dev != NULL)
+			dev_put(trigger_data->net_dev);
+		dev_hold(dev);
+		trigger_data->net_dev = dev;
+		trigger_data->link_up = 0;
+		goto done;
+	}
+
+	if (evt == NETDEV_UNREGISTER && trigger_data->net_dev != NULL) {
+		dev_put(trigger_data->net_dev);
+		trigger_data->net_dev = NULL;
+		goto done;
+	}
+
+	/* UP / DOWN / CHANGE */
+
+	trigger_data->link_up = (evt != NETDEV_DOWN && netif_carrier_ok(dev));
+	set_baseline_state(trigger_data);
+
+done:
+	write_unlock(&trigger_data->lock);
+	return NOTIFY_DONE;
+}
+
+/* here's the real work! */
+static void netdev_trig_timer(unsigned long arg)
+{
+	struct led_netdev_data *trigger_data = (struct led_netdev_data *)arg;
+	struct net_device_stats *dev_stats;
+	unsigned new_activity;
+
+	write_lock(&trigger_data->lock);
+
+	if (!trigger_data->link_up || !trigger_data->net_dev || (trigger_data->mode & (MODE_TX | MODE_RX)) == 0) {
+		/* we don't need to do timer work, just reflect link state. */
+		led_set_brightness(trigger_data->led_cdev, ((trigger_data->mode & MODE_LINK) != 0 && trigger_data->link_up) ? LED_FULL : LED_OFF);
+		goto no_restart;
+	}
+#ifdef CONFIG_COMPAT_NET_DEV_OPS
+	dev_stats = trigger_data->net_dev->get_stats(trigger_data->net_dev);
+#else
+	dev_stats = trigger_data->net_dev->netdev_ops->ndo_get_stats(trigger_data->net_dev);
+#endif
+	new_activity =
+		((trigger_data->mode & MODE_TX) ? dev_stats->tx_packets : 0) +
+		((trigger_data->mode & MODE_RX) ? dev_stats->rx_packets : 0);
+
+	if (trigger_data->mode & MODE_LINK) {
+		/* base state is ON (link present) */
+		/* if there's no link, we don't get this far and the LED is off */
+
+		/* OFF -> ON always */
+		/* ON -> OFF on activity */
+		if (trigger_data->led_cdev->brightness == LED_OFF) {
+			led_set_brightness(trigger_data->led_cdev, LED_FULL);
+		} else if (trigger_data->last_activity != new_activity) {
+			led_set_brightness(trigger_data->led_cdev, LED_OFF);
+		}
+	} else {
+		/* base state is OFF */
+		/* ON -> OFF always */
+		/* OFF -> ON on activity */
+		if (trigger_data->led_cdev->brightness == LED_FULL) {
+			led_set_brightness(trigger_data->led_cdev, LED_OFF);
+		} else if (trigger_data->last_activity != new_activity) {
+			led_set_brightness(trigger_data->led_cdev, LED_FULL);
+		}
+	}
+
+	trigger_data->last_activity = new_activity;
+	mod_timer(&trigger_data->timer, jiffies + trigger_data->interval);
+
+no_restart:
+	write_unlock(&trigger_data->lock);
+}
+
+static void netdev_trig_activate(struct led_classdev *led_cdev)
+{
+	struct led_netdev_data *trigger_data;
+	int rc;
+
+	trigger_data = kzalloc(sizeof(struct led_netdev_data), GFP_KERNEL);
+	if (!trigger_data)
+		return;
+
+	rwlock_init(&trigger_data->lock);
+
+	trigger_data->notifier.notifier_call = netdev_trig_notify;
+	trigger_data->notifier.priority = 10;
+
+	setup_timer(&trigger_data->timer, netdev_trig_timer, (unsigned long) trigger_data);
+
+	trigger_data->led_cdev = led_cdev;
+	trigger_data->net_dev = NULL;
+	trigger_data->device_name[0] = 0;
+
+	trigger_data->mode = 0;
+	trigger_data->interval = msecs_to_jiffies(50);
+	trigger_data->link_up = 0;
+	trigger_data->last_activity = 0;
+
+	led_cdev->trigger_data = trigger_data;
+
+	rc = device_create_file(led_cdev->dev, &dev_attr_device_name);
+	if (rc)
+		goto err_out;
+	rc = device_create_file(led_cdev->dev, &dev_attr_mode);
+	if (rc)
+		goto err_out_device_name;
+	rc = device_create_file(led_cdev->dev, &dev_attr_interval);
+	if (rc)
+		goto err_out_mode;
+
+	register_netdevice_notifier(&trigger_data->notifier);
+	return;
+
+err_out_mode:
+	device_remove_file(led_cdev->dev, &dev_attr_mode);
+err_out_device_name:
+	device_remove_file(led_cdev->dev, &dev_attr_device_name);
+err_out:
+	led_cdev->trigger_data = NULL;
+	kfree(trigger_data);
+}
+
+static void netdev_trig_deactivate(struct led_classdev *led_cdev)
+{
+	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
+
+	if (trigger_data) {
+		unregister_netdevice_notifier(&trigger_data->notifier);
+
+		device_remove_file(led_cdev->dev, &dev_attr_device_name);
+		device_remove_file(led_cdev->dev, &dev_attr_mode);
+		device_remove_file(led_cdev->dev, &dev_attr_interval);
+
+		write_lock(&trigger_data->lock);
+
+		if (trigger_data->net_dev) {
+			dev_put(trigger_data->net_dev);
+			trigger_data->net_dev = NULL;
+		}
+
+		write_unlock(&trigger_data->lock);
+
+		del_timer_sync(&trigger_data->timer);
+
+		kfree(trigger_data);
+	}
+}
+
+static struct led_trigger netdev_led_trigger = {
+	.name     = "netdev",
+	.activate = netdev_trig_activate,
+	.deactivate = netdev_trig_deactivate,
+};
+
+static int __init netdev_trig_init(void)
+{
+	return led_trigger_register(&netdev_led_trigger);
+}
+
+static void __exit netdev_trig_exit(void)
+{
+	led_trigger_unregister(&netdev_led_trigger);
+}
+
+module_init(netdev_trig_init);
+module_exit(netdev_trig_exit);
+
+MODULE_AUTHOR("Oliver Jowett <oliver@opencloud.com>");
+MODULE_DESCRIPTION("Netdev LED trigger");
+MODULE_LICENSE("GPL");
diff -Nru linux-2.6.30.5/drivers/mmc/host/Kconfig linux-2.6.30.5-wrt/drivers/mmc/host/Kconfig
--- linux-2.6.30.5/drivers/mmc/host/Kconfig	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/mmc/host/Kconfig	2009-09-06 18:44:06.807166783 +0200
@@ -241,3 +241,28 @@
 	help
 	  This provides support for the SD/MMC cell found in TC6393XB,
 	  T7L66XB and also ipaq ASIC3
+
+config GPIOMMC
+	tristate "MMC/SD over GPIO-based SPI"
+	depends on MMC && MMC_SPI && SPI_GPIO
+	help
+	  This driver hooks up the mmc_spi and spi_gpio modules so that
+	  MMC/SD cards can be used on a GPIO based bus by bitbanging
+	  the SPI protocol in software.
+
+	  This driver provides a configfs interface to dynamically create
+	  and destroy GPIO-based MMC/SD card devices. It also provides
+	  a platform device interface API.
+	  See Documentation/gpiommc.txt for details.
+
+	  The module will be called gpiommc.
+
+	  If unsure, say N.
+
+config GPIOMMC_CONFIGFS
+	bool
+	depends on GPIOMMC && CONFIGFS_FS
+	default y
+	help
+	  This option automatically enables configfs support for gpiommc
+	  if configfs is available.
diff -Nru linux-2.6.30.5/drivers/mmc/host/Makefile linux-2.6.30.5-wrt/drivers/mmc/host/Makefile
--- linux-2.6.30.5/drivers/mmc/host/Makefile	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/mmc/host/Makefile	2009-09-06 18:44:06.807166783 +0200
@@ -29,4 +29,5 @@
 obj-$(CONFIG_MMC_S3C)   	+= s3cmci.o
 obj-$(CONFIG_MMC_SDRICOH_CS)	+= sdricoh_cs.o
 obj-$(CONFIG_MMC_TMIO)		+= tmio_mmc.o
+obj-$(CONFIG_GPIOMMC)		+= gpiommc.o
 
diff -Nru linux-2.6.30.5/drivers/mmc/host/gpiommc.c linux-2.6.30.5-wrt/drivers/mmc/host/gpiommc.c
--- linux-2.6.30.5/drivers/mmc/host/gpiommc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/drivers/mmc/host/gpiommc.c	2009-09-06 18:44:06.811167583 +0200
@@ -0,0 +1,619 @@
+/*
+ * Driver an MMC/SD card on a bitbanging GPIO SPI bus.
+ * This module hooks up the mmc_spi and spi_gpio modules and also
+ * provides a configfs interface.
+ *
+ * Copyright 2008 Michael Buesch <mb@bu3sch.de>
+ *
+ * Licensed under the GNU/GPL. See COPYING for details.
+ */
+
+#include <linux/mmc/gpiommc.h>
+#include <linux/platform_device.h>
+#include <linux/list.h>
+#include <linux/mutex.h>
+#include <linux/spi/spi_gpio_old.h>
+#include <linux/configfs.h>
+#include <linux/gpio.h>
+#include <asm/atomic.h>
+
+
+#define PFX				"gpio-mmc: "
+
+
+struct gpiommc_device {
+	struct platform_device *pdev;
+	struct platform_device *spi_pdev;
+	struct spi_board_info boardinfo;
+};
+
+
+MODULE_DESCRIPTION("GPIO based MMC driver");
+MODULE_AUTHOR("Michael Buesch");
+MODULE_LICENSE("GPL");
+
+
+static int gpiommc_boardinfo_setup(struct spi_board_info *bi,
+				   struct spi_master *master,
+				   void *data)
+{
+	struct gpiommc_device *d = data;
+	struct gpiommc_platform_data *pdata = d->pdev->dev.platform_data;
+
+	/* Bind the SPI master to the MMC-SPI host driver. */
+	strlcpy(bi->modalias, "mmc_spi", sizeof(bi->modalias));
+
+	bi->max_speed_hz = pdata->max_bus_speed;
+	bi->bus_num = master->bus_num;
+	bi->mode = pdata->mode;
+
+	return 0;
+}
+
+static int gpiommc_probe(struct platform_device *pdev)
+{
+	struct gpiommc_platform_data *mmc_pdata = pdev->dev.platform_data;
+	struct spi_gpio_platform_data spi_pdata;
+	struct gpiommc_device *d;
+	int err;
+
+	err = -ENXIO;
+	if (!mmc_pdata)
+		goto error;
+
+#ifdef CONFIG_MMC_SPI_MODULE
+	err = request_module("mmc_spi");
+	if (err) {
+		printk(KERN_WARNING PFX
+		       "Failed to request mmc_spi module.\n");
+	}
+#endif /* CONFIG_MMC_SPI_MODULE */
+
+	/* Allocate the GPIO-MMC device */
+	err = -ENOMEM;
+	d = kzalloc(sizeof(*d), GFP_KERNEL);
+	if (!d)
+		goto error;
+	d->pdev = pdev;
+
+	/* Create the SPI-GPIO device */
+	d->spi_pdev = platform_device_alloc(SPI_GPIO_PLATDEV_NAME,
+					    spi_gpio_next_id());
+	if (!d->spi_pdev)
+		goto err_free_d;
+
+	memset(&spi_pdata, 0, sizeof(spi_pdata));
+	spi_pdata.pin_clk = mmc_pdata->pins.gpio_clk;
+	spi_pdata.pin_miso = mmc_pdata->pins.gpio_do;
+	spi_pdata.pin_mosi = mmc_pdata->pins.gpio_di;
+	spi_pdata.pin_cs = mmc_pdata->pins.gpio_cs;
+	spi_pdata.cs_activelow = mmc_pdata->pins.cs_activelow;
+	spi_pdata.no_spi_delay = mmc_pdata->no_spi_delay;
+	spi_pdata.boardinfo_setup = gpiommc_boardinfo_setup;
+	spi_pdata.boardinfo_setup_data = d;
+
+	err = platform_device_add_data(d->spi_pdev, &spi_pdata,
+				       sizeof(spi_pdata));
+	if (err)
+		goto err_free_pdev;
+	err = platform_device_add(d->spi_pdev);
+	if (err)
+		goto err_free_pdata;
+	platform_set_drvdata(pdev, d);
+
+	printk(KERN_INFO PFX "MMC-Card \"%s\" "
+	       "attached to GPIO pins di=%u, do=%u, clk=%u, cs=%u\n",
+	       mmc_pdata->name, mmc_pdata->pins.gpio_di,
+	       mmc_pdata->pins.gpio_do,
+	       mmc_pdata->pins.gpio_clk,
+	       mmc_pdata->pins.gpio_cs);
+
+	return 0;
+
+err_free_pdata:
+	kfree(d->spi_pdev->dev.platform_data);
+	d->spi_pdev->dev.platform_data = NULL;
+err_free_pdev:
+	platform_device_put(d->spi_pdev);
+err_free_d:
+	kfree(d);
+error:
+	return err;
+}
+
+static int gpiommc_remove(struct platform_device *pdev)
+{
+	struct gpiommc_device *d = platform_get_drvdata(pdev);
+	struct gpiommc_platform_data *pdata = d->pdev->dev.platform_data;
+
+	platform_device_unregister(d->spi_pdev);
+	printk(KERN_INFO PFX "GPIO based MMC-Card \"%s\" removed\n",
+	       pdata->name);
+	platform_device_put(d->spi_pdev);
+
+	return 0;
+}
+
+#ifdef CONFIG_GPIOMMC_CONFIGFS
+
+/* A device that was created through configfs */
+struct gpiommc_configfs_device {
+	struct config_item item;
+	/* The platform device, after registration. */
+	struct platform_device *pdev;
+	/* The configuration */
+	struct gpiommc_platform_data pdata;
+	/* Mutex to protect this structure */
+	struct mutex mutex;
+};
+
+#define GPIO_INVALID	-1
+
+static inline bool gpiommc_is_registered(struct gpiommc_configfs_device *dev)
+{
+	return (dev->pdev != NULL);
+}
+
+static inline struct gpiommc_configfs_device *ci_to_gpiommc(struct config_item *item)
+{
+	return item ? container_of(item, struct gpiommc_configfs_device, item) : NULL;
+}
+
+static struct configfs_attribute gpiommc_attr_DI = {
+	.ca_owner = THIS_MODULE,
+	.ca_name = "gpio_data_in",
+	.ca_mode = S_IRUGO | S_IWUSR,
+};
+
+static struct configfs_attribute gpiommc_attr_DO = {
+	.ca_owner = THIS_MODULE,
+	.ca_name = "gpio_data_out",
+	.ca_mode = S_IRUGO | S_IWUSR,
+};
+
+static struct configfs_attribute gpiommc_attr_CLK = {
+	.ca_owner = THIS_MODULE,
+	.ca_name = "gpio_clock",
+	.ca_mode = S_IRUGO | S_IWUSR,
+};
+
+static struct configfs_attribute gpiommc_attr_CS = {
+	.ca_owner = THIS_MODULE,
+	.ca_name = "gpio_chipselect",
+	.ca_mode = S_IRUGO | S_IWUSR,
+};
+
+static struct configfs_attribute gpiommc_attr_CS_activelow = {
+	.ca_owner = THIS_MODULE,
+	.ca_name = "gpio_chipselect_activelow",
+	.ca_mode = S_IRUGO | S_IWUSR,
+};
+
+static struct configfs_attribute gpiommc_attr_spimode = {
+	.ca_owner = THIS_MODULE,
+	.ca_name = "spi_mode",
+	.ca_mode = S_IRUGO | S_IWUSR,
+};
+
+static struct configfs_attribute gpiommc_attr_spidelay = {
+	.ca_owner = THIS_MODULE,
+	.ca_name = "spi_delay",
+	.ca_mode = S_IRUGO | S_IWUSR,
+};
+
+static struct configfs_attribute gpiommc_attr_max_bus_speed = {
+	.ca_owner = THIS_MODULE,
+	.ca_name = "max_bus_speed",
+	.ca_mode = S_IRUGO | S_IWUSR,
+};
+
+static struct configfs_attribute gpiommc_attr_register = {
+	.ca_owner = THIS_MODULE,
+	.ca_name = "register",
+	.ca_mode = S_IRUGO | S_IWUSR,
+};
+
+static struct configfs_attribute *gpiommc_config_attrs[] = {
+	&gpiommc_attr_DI,
+	&gpiommc_attr_DO,
+	&gpiommc_attr_CLK,
+	&gpiommc_attr_CS,
+	&gpiommc_attr_CS_activelow,
+	&gpiommc_attr_spimode,
+	&gpiommc_attr_spidelay,
+	&gpiommc_attr_max_bus_speed,
+	&gpiommc_attr_register,
+	NULL,
+};
+
+static ssize_t gpiommc_config_attr_show(struct config_item *item,
+					struct configfs_attribute *attr,
+					char *page)
+{
+	struct gpiommc_configfs_device *dev = ci_to_gpiommc(item);
+	ssize_t count = 0;
+	unsigned int gpio;
+	int err = 0;
+
+	mutex_lock(&dev->mutex);
+
+	if (attr == &gpiommc_attr_DI) {
+		gpio = dev->pdata.pins.gpio_di;
+		if (gpio == GPIO_INVALID)
+			count = snprintf(page, PAGE_SIZE, "not configured\n");
+		else
+			count = snprintf(page, PAGE_SIZE, "%u\n", gpio);
+		goto out;
+	}
+	if (attr == &gpiommc_attr_DO) {
+		gpio = dev->pdata.pins.gpio_do;
+		if (gpio == GPIO_INVALID)
+			count = snprintf(page, PAGE_SIZE, "not configured\n");
+		else
+			count = snprintf(page, PAGE_SIZE, "%u\n", gpio);
+		goto out;
+	}
+	if (attr == &gpiommc_attr_CLK) {
+		gpio = dev->pdata.pins.gpio_clk;
+		if (gpio == GPIO_INVALID)
+			count = snprintf(page, PAGE_SIZE, "not configured\n");
+		else
+			count = snprintf(page, PAGE_SIZE, "%u\n", gpio);
+		goto out;
+	}
+	if (attr == &gpiommc_attr_CS) {
+		gpio = dev->pdata.pins.gpio_cs;
+		if (gpio == GPIO_INVALID)
+			count = snprintf(page, PAGE_SIZE, "not configured\n");
+		else
+			count = snprintf(page, PAGE_SIZE, "%u\n", gpio);
+		goto out;
+	}
+	if (attr == &gpiommc_attr_CS_activelow) {
+		count = snprintf(page, PAGE_SIZE, "%u\n",
+				 dev->pdata.pins.cs_activelow);
+		goto out;
+	}
+	if (attr == &gpiommc_attr_spimode) {
+		count = snprintf(page, PAGE_SIZE, "%u\n",
+				 dev->pdata.mode);
+		goto out;
+	}
+	if (attr == &gpiommc_attr_spidelay) {
+		count = snprintf(page, PAGE_SIZE, "%u\n",
+				 !dev->pdata.no_spi_delay);
+		goto out;
+	}
+	if (attr == &gpiommc_attr_max_bus_speed) {
+		count = snprintf(page, PAGE_SIZE, "%u\n",
+				 dev->pdata.max_bus_speed);
+		goto out;
+	}
+	if (attr == &gpiommc_attr_register) {
+		count = snprintf(page, PAGE_SIZE, "%u\n",
+				 gpiommc_is_registered(dev));
+		goto out;
+	}
+	WARN_ON(1);
+	err = -ENOSYS;
+out:
+	mutex_unlock(&dev->mutex);
+
+	return err ? err : count;
+}
+
+static int gpiommc_do_register(struct gpiommc_configfs_device *dev,
+			       const char *name)
+{
+	int err;
+
+	if (gpiommc_is_registered(dev))
+		return 0;
+
+	if (!gpio_is_valid(dev->pdata.pins.gpio_di) ||
+	    !gpio_is_valid(dev->pdata.pins.gpio_do) ||
+	    !gpio_is_valid(dev->pdata.pins.gpio_clk) ||
+	    !gpio_is_valid(dev->pdata.pins.gpio_cs)) {
+		printk(KERN_ERR PFX
+		       "configfs: Invalid GPIO pin number(s)\n");
+		return -EINVAL;
+	}
+
+	strlcpy(dev->pdata.name, name,
+		sizeof(dev->pdata.name));
+
+	dev->pdev = platform_device_alloc(GPIOMMC_PLATDEV_NAME,
+					  gpiommc_next_id());
+	if (!dev->pdev)
+		return -ENOMEM;
+	err = platform_device_add_data(dev->pdev, &dev->pdata,
+				       sizeof(dev->pdata));
+	if (err) {
+		platform_device_put(dev->pdev);
+		return err;
+	}
+	err = platform_device_add(dev->pdev);
+	if (err) {
+		platform_device_put(dev->pdev);
+		return err;
+	}
+
+	return 0;
+}
+
+static void gpiommc_do_unregister(struct gpiommc_configfs_device *dev)
+{
+	if (!gpiommc_is_registered(dev))
+		return;
+
+	platform_device_unregister(dev->pdev);
+	dev->pdev = NULL;
+}
+
+static ssize_t gpiommc_config_attr_store(struct config_item *item,
+					 struct configfs_attribute *attr,
+					 const char *page, size_t count)
+{
+	struct gpiommc_configfs_device *dev = ci_to_gpiommc(item);
+	int err = -EINVAL;
+	unsigned long data;
+
+	mutex_lock(&dev->mutex);
+
+	if (attr == &gpiommc_attr_register) {
+		err = strict_strtoul(page, 10, &data);
+		if (err)
+			goto out;
+		err = -EINVAL;
+		if (data == 1)
+			err = gpiommc_do_register(dev, item->ci_name);
+		if (data == 0) {
+			gpiommc_do_unregister(dev);
+			err = 0;
+		}
+		goto out;
+	}
+
+	if (gpiommc_is_registered(dev)) {
+		/* The rest of the config parameters can only be set
+		 * as long as the device is not registered, yet. */
+		err = -EBUSY;
+		goto out;
+	}
+
+	if (attr == &gpiommc_attr_DI) {
+		err = strict_strtoul(page, 10, &data);
+		if (err)
+			goto out;
+		err = -EINVAL;
+		if (!gpio_is_valid(data))
+			goto out;
+		dev->pdata.pins.gpio_di = data;
+		err = 0;
+		goto out;
+	}
+	if (attr == &gpiommc_attr_DO) {
+		err = strict_strtoul(page, 10, &data);
+		if (err)
+			goto out;
+		err = -EINVAL;
+		if (!gpio_is_valid(data))
+			goto out;
+		dev->pdata.pins.gpio_do = data;
+		err = 0;
+		goto out;
+	}
+	if (attr == &gpiommc_attr_CLK) {
+		err = strict_strtoul(page, 10, &data);
+		if (err)
+			goto out;
+		err = -EINVAL;
+		if (!gpio_is_valid(data))
+			goto out;
+		dev->pdata.pins.gpio_clk = data;
+		err = 0;
+		goto out;
+	}
+	if (attr == &gpiommc_attr_CS) {
+		err = strict_strtoul(page, 10, &data);
+		if (err)
+			goto out;
+		err = -EINVAL;
+		if (!gpio_is_valid(data))
+			goto out;
+		dev->pdata.pins.gpio_cs = data;
+		err = 0;
+		goto out;
+	}
+	if (attr == &gpiommc_attr_CS_activelow) {
+		err = strict_strtoul(page, 10, &data);
+		if (err)
+			goto out;
+		err = -EINVAL;
+		if (data != 0 && data != 1)
+			goto out;
+		dev->pdata.pins.cs_activelow = data;
+		err = 0;
+		goto out;
+	}
+	if (attr == &gpiommc_attr_spimode) {
+		err = strict_strtoul(page, 10, &data);
+		if (err)
+			goto out;
+		err = -EINVAL;
+		switch (data) {
+		case 0:
+			dev->pdata.mode = SPI_MODE_0;
+			break;
+		case 1:
+			dev->pdata.mode = SPI_MODE_1;
+			break;
+		case 2:
+			dev->pdata.mode = SPI_MODE_2;
+			break;
+		case 3:
+			dev->pdata.mode = SPI_MODE_3;
+			break;
+		default:
+			goto out;
+		}
+		err = 0;
+		goto out;
+	}
+	if (attr == &gpiommc_attr_spidelay) {
+		err = strict_strtoul(page, 10, &data);
+		if (err)
+			goto out;
+		err = -EINVAL;
+		if (data != 0 && data != 1)
+			goto out;
+		dev->pdata.no_spi_delay = !data;
+		err = 0;
+		goto out;
+	}
+	if (attr == &gpiommc_attr_max_bus_speed) {
+		err = strict_strtoul(page, 10, &data);
+		if (err)
+			goto out;
+		err = -EINVAL;
+		if (data > UINT_MAX)
+			goto out;
+		dev->pdata.max_bus_speed = data;
+		err = 0;
+		goto out;
+	}
+	WARN_ON(1);
+	err = -ENOSYS;
+out:
+	mutex_unlock(&dev->mutex);
+
+	return err ? err : count;
+}
+
+static void gpiommc_config_item_release(struct config_item *item)
+{
+	struct gpiommc_configfs_device *dev = ci_to_gpiommc(item);
+
+	kfree(dev);
+}
+
+static struct configfs_item_operations gpiommc_config_item_ops = {
+	.release		= gpiommc_config_item_release,
+	.show_attribute		= gpiommc_config_attr_show,
+	.store_attribute	= gpiommc_config_attr_store,
+};
+
+static struct config_item_type gpiommc_dev_ci_type = {
+	.ct_item_ops	= &gpiommc_config_item_ops,
+	.ct_attrs	= gpiommc_config_attrs,
+	.ct_owner	= THIS_MODULE,
+};
+
+static struct config_item *gpiommc_make_item(struct config_group *group,
+					     const char *name)
+{
+	struct gpiommc_configfs_device *dev;
+
+	if (strlen(name) > GPIOMMC_MAX_NAMELEN) {
+		printk(KERN_ERR PFX "configfs: device name too long\n");
+		return NULL;
+	}
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return NULL;
+
+	mutex_init(&dev->mutex);
+	config_item_init_type_name(&dev->item, name,
+				   &gpiommc_dev_ci_type);
+
+	/* Assign default configuration */
+	dev->pdata.pins.gpio_di = GPIO_INVALID;
+	dev->pdata.pins.gpio_do = GPIO_INVALID;
+	dev->pdata.pins.gpio_clk = GPIO_INVALID;
+	dev->pdata.pins.gpio_cs = GPIO_INVALID;
+	dev->pdata.pins.cs_activelow = 1;
+	dev->pdata.mode = SPI_MODE_0;
+	dev->pdata.no_spi_delay = 0;
+	dev->pdata.max_bus_speed = 5000000; /* 5 MHz */
+
+	return &(dev->item);
+}
+
+static void gpiommc_drop_item(struct config_group *group,
+			      struct config_item *item)
+{
+	struct gpiommc_configfs_device *dev = ci_to_gpiommc(item);
+
+	gpiommc_do_unregister(dev);
+	kfree(dev);
+}
+
+static struct configfs_group_operations gpiommc_ct_group_ops = {
+	.make_item	= gpiommc_make_item,
+	.drop_item	= gpiommc_drop_item,
+};
+
+static struct config_item_type gpiommc_ci_type = {
+	.ct_group_ops	= &gpiommc_ct_group_ops,
+	.ct_owner	= THIS_MODULE,
+};
+
+static struct configfs_subsystem gpiommc_subsys = {
+	.su_group = {
+		.cg_item = {
+			.ci_namebuf = GPIOMMC_PLATDEV_NAME,
+			.ci_type = &gpiommc_ci_type,
+		},
+	},
+	.su_mutex = __MUTEX_INITIALIZER(gpiommc_subsys.su_mutex),
+};
+
+#endif /* CONFIG_GPIOMMC_CONFIGFS */
+
+static struct platform_driver gpiommc_plat_driver = {
+	.probe	= gpiommc_probe,
+	.remove	= gpiommc_remove,
+	.driver	= {
+		.name	= GPIOMMC_PLATDEV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+int gpiommc_next_id(void)
+{
+	static atomic_t counter = ATOMIC_INIT(-1);
+
+	return atomic_inc_return(&counter);
+}
+EXPORT_SYMBOL(gpiommc_next_id);
+
+static int __init gpiommc_modinit(void)
+{
+	int err;
+
+	err = platform_driver_register(&gpiommc_plat_driver);
+	if (err)
+		return err;
+
+#ifdef CONFIG_GPIOMMC_CONFIGFS
+	config_group_init(&gpiommc_subsys.su_group);
+	err = configfs_register_subsystem(&gpiommc_subsys);
+	if (err) {
+		platform_driver_unregister(&gpiommc_plat_driver);
+		return err;
+	}
+#endif /* CONFIG_GPIOMMC_CONFIGFS */
+
+	return 0;
+}
+module_init(gpiommc_modinit);
+
+static void __exit gpiommc_modexit(void)
+{
+#ifdef CONFIG_GPIOMMC_CONFIGFS
+	configfs_unregister_subsystem(&gpiommc_subsys);
+#endif
+	platform_driver_unregister(&gpiommc_plat_driver);
+}
+module_exit(gpiommc_modexit);
diff -Nru linux-2.6.30.5/drivers/mtd/Kconfig linux-2.6.30.5-wrt/drivers/mtd/Kconfig
--- linux-2.6.30.5/drivers/mtd/Kconfig	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/mtd/Kconfig	2009-09-06 18:43:48.358667468 +0200
@@ -53,6 +53,16 @@
 	  should normally be compiled as kernel modules. The modules perform
 	  various checks and verifications when loaded.
 
+config MTD_ROOTFS_ROOT_DEV
+	bool "Automatically set 'rootfs' partition to be root filesystem"
+	depends on MTD_PARTITIONS
+	default y
+
+config MTD_ROOTFS_SPLIT
+	bool "Automatically split 'rootfs' partition for squashfs"
+	depends on MTD_PARTITIONS
+	default y
+
 config MTD_REDBOOT_PARTS
 	tristate "RedBoot partition table parsing"
 	depends on MTD_PARTITIONS
@@ -170,6 +180,22 @@
 	---help---
 	  TI AR7 partitioning support
 
+config MTD_MYLOADER_PARTS
+	tristate "MyLoader partition parsing"
+	depends on MTD_PARTITIONS && (ADM5120 || ATHEROS_AR231X || ATHEROS_AR71XX)
+	---help---
+	  MyLoader is a bootloader which allows the user to define partitions
+	  in flash devices, by putting a table in the second erase block
+	  on the device, similar to a partition table. This table gives the 
+	  offsets and lengths of the user defined partitions.
+
+	  If you need code which can detect and parse these tables, and
+	  register MTD 'partitions' corresponding to each image detected,
+	  enable this option.
+
+	  You will still need the parsing functions to be called by the driver
+	  for your particular device. It won't happen automatically.
+
 comment "User Modules And Translation Layers"
 
 config MTD_CHAR
diff -Nru linux-2.6.30.5/drivers/mtd/Makefile linux-2.6.30.5-wrt/drivers/mtd/Makefile
--- linux-2.6.30.5/drivers/mtd/Makefile	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/mtd/Makefile	2009-09-06 18:43:48.358667468 +0200
@@ -13,6 +13,7 @@
 obj-$(CONFIG_MTD_AFS_PARTS)	+= afs.o
 obj-$(CONFIG_MTD_AR7_PARTS)	+= ar7part.o
 obj-$(CONFIG_MTD_OF_PARTS)      += ofpart.o
+obj-$(CONFIG_MTD_MYLOADER_PARTS) += myloader.o
 
 # 'Users' - code which presents functionality to userspace.
 obj-$(CONFIG_MTD_CHAR)		+= mtdchar.o
diff -Nru linux-2.6.30.5/drivers/mtd/chips/cfi_cmdset_0002.c linux-2.6.30.5-wrt/drivers/mtd/chips/cfi_cmdset_0002.c
--- linux-2.6.30.5/drivers/mtd/chips/cfi_cmdset_0002.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/mtd/chips/cfi_cmdset_0002.c	2009-09-06 18:43:48.314668017 +0200
@@ -51,6 +51,7 @@
 #define SST49LF040B	        0x0050
 #define SST49LF008A		0x005a
 #define AT49BV6416		0x00d6
+#define MANUFACTURER_SAMSUNG	0x00ec
 
 static int cfi_amdstd_read (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
 static int cfi_amdstd_write_words(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
@@ -386,12 +387,19 @@
 
 		if (extp->MajorVersion != '1' ||
 		    (extp->MinorVersion < '0' || extp->MinorVersion > '4')) {
-			printk(KERN_ERR "  Unknown Amd/Fujitsu Extended Query "
-			       "version %c.%c.\n",  extp->MajorVersion,
-			       extp->MinorVersion);
-			kfree(extp);
-			kfree(mtd);
-			return NULL;
+		        if (cfi->mfr == MANUFACTURER_SAMSUNG &&
+			    (extp->MajorVersion == '3' && extp->MinorVersion == '3')) {
+			    printk(KERN_NOTICE "  Newer Samsung flash detected, "
+			           "should be compatibile with Amd/Fujitsu.\n");
+		        }
+		        else {
+			    printk(KERN_ERR "  Unknown Amd/Fujitsu Extended Query "
+			           "version %c.%c.\n",  extp->MajorVersion,
+			           extp->MinorVersion);
+			    kfree(extp);
+			    kfree(mtd);
+			    return NULL;
+		        }
 		}
 
 		/* Install our own private info structure */
diff -Nru linux-2.6.30.5/drivers/mtd/devices/block2mtd.c linux-2.6.30.5-wrt/drivers/mtd/devices/block2mtd.c
--- linux-2.6.30.5/drivers/mtd/devices/block2mtd.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/mtd/devices/block2mtd.c	2009-09-06 18:43:48.346667558 +0200
@@ -14,6 +14,7 @@
 #include <linux/list.h>
 #include <linux/init.h>
 #include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
 #include <linux/buffer_head.h>
 #include <linux/mutex.h>
 #include <linux/mount.h>
@@ -28,6 +29,8 @@
 	struct block_device *blkdev;
 	struct mtd_info mtd;
 	struct mutex write_mutex;
+	rwlock_t bdev_mutex;
+	char devname[0];
 };
 
 
@@ -80,6 +83,12 @@
 	size_t len = instr->len;
 	int err;
 
+	read_lock(&dev->bdev_mutex);
+	if (!dev->blkdev) {
+		err = -EINVAL;
+		goto done;
+	}
+
 	instr->state = MTD_ERASING;
 	mutex_lock(&dev->write_mutex);
 	err = _block2mtd_erase(dev, from, len);
@@ -92,6 +101,10 @@
 
 	instr->state = MTD_ERASE_DONE;
 	mtd_erase_callback(instr);
+
+done:
+	read_unlock(&dev->bdev_mutex);
+
 	return err;
 }
 
@@ -103,10 +116,14 @@
 	struct page *page;
 	int index = from >> PAGE_SHIFT;
 	int offset = from & (PAGE_SIZE-1);
-	int cpylen;
+	int cpylen, err = 0;
+
+	read_lock(&dev->bdev_mutex);
+	if (!dev->blkdev || (from > mtd->size)) {
+		err = -EINVAL;
+		goto done;
+	}
 
-	if (from > mtd->size)
-		return -EINVAL;
 	if (from + len > mtd->size)
 		len = mtd->size - from;
 
@@ -121,10 +138,14 @@
 		len = len - cpylen;
 
 		page = page_read(dev->blkdev->bd_inode->i_mapping, index);
-		if (!page)
-			return -ENOMEM;
-		if (IS_ERR(page))
-			return PTR_ERR(page);
+		if (!page) {
+			err = -ENOMEM;
+			goto done;
+		}
+		if (IS_ERR(page)) {
+			err = PTR_ERR(page);
+			goto done;
+		}
 
 		memcpy(buf, page_address(page) + offset, cpylen);
 		page_cache_release(page);
@@ -135,7 +156,10 @@
 		offset = 0;
 		index++;
 	}
-	return 0;
+
+done:
+	read_unlock(&dev->bdev_mutex);
+	return err;
 }
 
 
@@ -187,12 +211,22 @@
 		size_t *retlen, const u_char *buf)
 {
 	struct block2mtd_dev *dev = mtd->priv;
-	int err;
+	int err = 0;
+
+	read_lock(&dev->bdev_mutex);
+	if (!dev->blkdev) {
+		err = -EINVAL;
+		goto done;
+	}
 
 	if (!len)
-		return 0;
-	if (to >= mtd->size)
-		return -ENOSPC;
+		goto done;
+
+	if (to >= mtd->size) {
+		err = -ENOSPC;
+		goto done;
+	}
+
 	if (to + len > mtd->size)
 		len = mtd->size - to;
 
@@ -201,6 +235,9 @@
 	mutex_unlock(&dev->write_mutex);
 	if (err > 0)
 		err = 0;
+
+done:
+	read_unlock(&dev->bdev_mutex);
 	return err;
 }
 
@@ -209,51 +246,29 @@
 static void block2mtd_sync(struct mtd_info *mtd)
 {
 	struct block2mtd_dev *dev = mtd->priv;
-	sync_blockdev(dev->blkdev);
-	return;
-}
-
-
-static void block2mtd_free_device(struct block2mtd_dev *dev)
-{
-	if (!dev)
-		return;
-
-	kfree(dev->mtd.name);
 
-	if (dev->blkdev) {
-		invalidate_mapping_pages(dev->blkdev->bd_inode->i_mapping,
-					0, -1);
-		close_bdev_exclusive(dev->blkdev, FMODE_READ|FMODE_WRITE);
-	}
+	read_lock(&dev->bdev_mutex);
+	if (dev->blkdev)
+		sync_blockdev(dev->blkdev);
+	read_unlock(&dev->bdev_mutex);
 
-	kfree(dev);
+	return;
 }
 
 
-/* FIXME: ensure that mtd->size % erase_size == 0 */
-static struct block2mtd_dev *add_device(char *devname, int erase_size)
+static int _open_bdev(struct block2mtd_dev *dev)
 {
 	struct block_device *bdev;
-	struct block2mtd_dev *dev;
-	char *name;
-
-	if (!devname)
-		return NULL;
-
-	dev = kzalloc(sizeof(struct block2mtd_dev), GFP_KERNEL);
-	if (!dev)
-		return NULL;
 
 	/* Get a handle on the device */
-	bdev = open_bdev_exclusive(devname, FMODE_READ|FMODE_WRITE, NULL);
+	bdev = open_bdev_exclusive(dev->devname, FMODE_READ|FMODE_WRITE, NULL);
 #ifndef MODULE
 	if (IS_ERR(bdev)) {
 
 		/* We might not have rootfs mounted at this point. Try
 		   to resolve the device name by other means. */
 
-		dev_t devt = name_to_dev_t(devname);
+		dev_t devt = name_to_dev_t(dev->devname);
 		if (devt) {
 			bdev = open_by_devnum(devt, FMODE_WRITE | FMODE_READ);
 		}
@@ -261,29 +276,109 @@
 #endif
 
 	if (IS_ERR(bdev)) {
-		ERROR("error: cannot open device %s", devname);
-		goto devinit_err;
+		ERROR("error: cannot open device %s", dev->devname);
+		return 1;
 	}
 	dev->blkdev = bdev;
 
 	if (MAJOR(bdev->bd_dev) == MTD_BLOCK_MAJOR) {
 		ERROR("attempting to use an MTD device as a block device");
-		goto devinit_err;
+		return 1;
 	}
 
+	return 0;
+}
+
+static void _close_bdev(struct block2mtd_dev *dev)
+{
+	struct block_device *bdev;
+
+	if (!dev->blkdev)
+		return;
+
+	bdev = dev->blkdev;
+	invalidate_mapping_pages(dev->blkdev->bd_inode->i_mapping, 0, -1);
+	close_bdev_exclusive(dev->blkdev, FMODE_READ|FMODE_WRITE);
+	dev->blkdev = NULL;
+}
+
+static void block2mtd_free_device(struct block2mtd_dev *dev)
+{
+	if (!dev)
+		return;
+
+	kfree(dev->mtd.name);
+	_close_bdev(dev);
+	kfree(dev);
+}
+
+
+static int block2mtd_refresh(struct mtd_info *mtd)
+{
+	struct block2mtd_dev *dev = mtd->priv;
+	struct block_device *bdev;
+	dev_t devt;
+	int err = 0;
+
+	/* no other mtd function can run at this point */
+	write_lock(&dev->bdev_mutex);
+
+	/* get the device number for the whole disk */
+	devt = MKDEV(MAJOR(dev->blkdev->bd_dev), 0);
+
+	/* close the old block device */
+	_close_bdev(dev);
+
+	/* open the whole disk, issue a partition rescan, then */
+	bdev = open_by_devnum(devt, FMODE_WRITE | FMODE_READ);
+	if (!bdev || !bdev->bd_disk)
+		err = -EINVAL;
+	else {
+		err = rescan_partitions(bdev->bd_disk, bdev);
+	}
+	if (bdev)
+		close_bdev_exclusive(bdev, FMODE_READ|FMODE_WRITE);
+
+	/* try to open the partition block device again */
+	_open_bdev(dev);
+	write_unlock(&dev->bdev_mutex);
+
+	return err;
+}
+
+/* FIXME: ensure that mtd->size % erase_size == 0 */
+static struct block2mtd_dev *add_device(char *devname, int erase_size, char *mtdname)
+{
+	struct block2mtd_dev *dev;
+	struct mtd_partition *part;
+	char *name;
+
+	if (!devname)
+		return NULL;
+
+	dev = kzalloc(sizeof(struct block2mtd_dev) + strlen(devname) + 1, GFP_KERNEL);
+	if (!dev)
+		return NULL;
+
+	strcpy(dev->devname, devname);
+
+	if (_open_bdev(dev))
+		goto devinit_err;
+
 	mutex_init(&dev->write_mutex);
+	rwlock_init(&dev->bdev_mutex);
+
+	if (!mtdname)
+		mtdname = devname;
 
-	/* Setup the MTD structure */
-	/* make the name contain the block device in */
-	name = kmalloc(sizeof("block2mtd: ") + strlen(devname) + 1,
-			GFP_KERNEL);
+	name = kmalloc(strlen(mtdname) + 1, GFP_KERNEL);
 	if (!name)
 		goto devinit_err;
 
-	sprintf(name, "block2mtd: %s", devname);
+	strcpy(name, mtdname);
 	dev->mtd.name = name;
 
-	dev->mtd.size = dev->blkdev->bd_inode->i_size & PAGE_MASK;
+	dev->mtd.size = dev->blkdev->bd_inode->i_size & PAGE_MASK & ~(erase_size - 1);
 	dev->mtd.erasesize = erase_size;
 	dev->mtd.writesize = 1;
 	dev->mtd.type = MTD_RAM;
@@ -295,15 +390,19 @@
 	dev->mtd.read = block2mtd_read;
 	dev->mtd.priv = dev;
 	dev->mtd.owner = THIS_MODULE;
+	dev->mtd.refresh_device = block2mtd_refresh;
 
-	if (add_mtd_device(&dev->mtd)) {
+	part = kzalloc(sizeof(struct mtd_partition), GFP_KERNEL);
+	part->name = dev->mtd.name;
+	part->offset = 0;
+	part->size = dev->mtd.size;
+	if (add_mtd_partitions(&dev->mtd, part, 1)) {
 		/* Device didnt get added, so free the entry */
 		goto devinit_err;
 	}
 	list_add(&dev->list, &blkmtd_device_list);
 	INFO("mtd%d: [%s] erase_size = %dKiB [%d]", dev->mtd.index,
-			dev->mtd.name + strlen("block2mtd: "),
-			dev->mtd.erasesize >> 10, dev->mtd.erasesize);
+			mtdname, dev->mtd.erasesize >> 10, dev->mtd.erasesize);
 	return dev;
 
 devinit_err:
@@ -376,9 +475,9 @@
 
 static int block2mtd_setup2(const char *val)
 {
-	char buf[80 + 12]; /* 80 for device, 12 for erase size */
+	char buf[80 + 12 + 80]; /* 80 for device, 12 for erase size, 80 for name */
 	char *str = buf;
-	char *token[2];
+	char *token[3];
 	char *name;
 	size_t erase_size = PAGE_SIZE;
 	int i, ret;
@@ -389,7 +488,7 @@
 	strcpy(str, val);
 	kill_final_newline(str);
 
-	for (i = 0; i < 2; i++)
+	for (i = 0; i < 3; i++)
 		token[i] = strsep(&str, ",");
 
 	if (str)
@@ -408,8 +507,10 @@
 			parse_err("illegal erase size");
 		}
 	}
+	if (token[2] && (strlen(token[2]) + 1 > 80))
+		parse_err("mtd device name too long");
 
-	add_device(name, erase_size);
+	add_device(name, erase_size, token[2]);
 
 	return 0;
 }
@@ -443,7 +544,7 @@
 
 
 module_param_call(block2mtd, block2mtd_setup, NULL, NULL, 0200);
-MODULE_PARM_DESC(block2mtd, "Device to use. \"block2mtd=<dev>[,<erasesize>]\"");
+MODULE_PARM_DESC(block2mtd, "Device to use. \"block2mtd=<dev>[,<erasesize>[,<name>]]\"");
 
 static int __init block2mtd_init(void)
 {
diff -Nru linux-2.6.30.5/drivers/mtd/maps/Kconfig linux-2.6.30.5-wrt/drivers/mtd/maps/Kconfig
--- linux-2.6.30.5/drivers/mtd/maps/Kconfig	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/mtd/maps/Kconfig	2009-09-06 18:47:53.770742476 +0200
@@ -343,6 +343,12 @@
 	  Mapping for the Flaga digital module. If you don't have one, ignore
 	  this setting.
 
+config MTD_BCM47XX
+	tristate "BCM47xx flash device"
+	depends on MIPS && MTD_CFI && BCM47XX
+	help
+	  Support for the flash chips on the BCM947xx board.
+
 config MTD_REDWOOD
 	tristate "CFI Flash devices mapped on IBM Redwood"
 	depends on MTD_CFI && ( REDWOOD_4 || REDWOOD_5 || REDWOOD_6 )
diff -Nru linux-2.6.30.5/drivers/mtd/maps/Makefile linux-2.6.30.5-wrt/drivers/mtd/maps/Makefile
--- linux-2.6.30.5/drivers/mtd/maps/Makefile	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/mtd/maps/Makefile	2009-09-06 18:47:53.770742476 +0200
@@ -29,6 +29,7 @@
 obj-$(CONFIG_MTD_PCMCIA)	+= pcmciamtd.o
 obj-$(CONFIG_MTD_RPXLITE)	+= rpxlite.o
 obj-$(CONFIG_MTD_TQM8XXL)	+= tqm8xxl.o
+obj-$(CONFIG_MTD_BCM47XX)	+= bcm47xx-flash.o
 obj-$(CONFIG_MTD_SA1100)	+= sa1100-flash.o
 obj-$(CONFIG_MTD_IPAQ)		+= ipaq-flash.o
 obj-$(CONFIG_MTD_SBC_GXX)	+= sbc_gxx.o
diff -Nru linux-2.6.30.5/drivers/mtd/maps/bcm47xx-flash.c linux-2.6.30.5-wrt/drivers/mtd/maps/bcm47xx-flash.c
--- linux-2.6.30.5/drivers/mtd/maps/bcm47xx-flash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/drivers/mtd/maps/bcm47xx-flash.c	2009-09-06 18:48:09.942698957 +0200
@@ -0,0 +1,440 @@
+/*
+ *  Copyright (C) 2006 Felix Fietkau <nbd@openwrt.org>
+ *  Copyright (C) 2005 Waldemar Brodkorb <wbx@openwrt.org>
+ *  Copyright (C) 2004 Florian Schirmer (jolt@tuxbox.org)
+ *
+ *  original functions for finding root filesystem from Mike Baker 
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ * 
+ *  Copyright 2001-2003, Broadcom Corporation
+ *  All Rights Reserved.
+ * 
+ *  THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ *  KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ *  SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ *  FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ *  Flash mapping for BCM947XX boards
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#ifdef CONFIG_MTD_PARTITIONS
+#include <linux/mtd/partitions.h>
+#endif
+#include <linux/crc32.h>
+#ifdef CONFIG_SSB
+#include <linux/ssb/ssb.h>
+#endif
+#include <asm/io.h>
+
+
+#define TRX_MAGIC	0x30524448	/* "HDR0" */
+#define TRX_VERSION	1
+#define TRX_MAX_LEN	0x3A0000
+#define TRX_NO_HEADER	1		/* Do not write TRX header */	
+#define TRX_GZ_FILES	0x2     /* Contains up to TRX_MAX_OFFSET individual gzip files */
+#define TRX_MAX_OFFSET	3
+
+struct trx_header {
+	u32 magic;		/* "HDR0" */
+	u32 len;		/* Length of file including header */
+	u32 crc32;		/* 32-bit CRC from flag_version to end of file */
+	u32 flag_version;	/* 0:15 flags, 16:31 version */
+	u32 offsets[TRX_MAX_OFFSET];	/* Offsets of partitions from start of header */
+};
+
+#define ROUNDUP(x, y) ((((x)+((y)-1))/(y))*(y))
+#define NVRAM_SPACE 0x8000
+#define WINDOW_ADDR 0x1fc00000
+#define WINDOW_SIZE 0x400000
+#define BUSWIDTH 2
+
+#ifdef CONFIG_SSB
+extern struct ssb_bus ssb_bcm47xx;
+#endif
+static struct mtd_info *bcm47xx_mtd;
+
+static void bcm47xx_map_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	if (len==1) {
+		memcpy_fromio(to, map->virt + from, len);
+	} else {
+		int i;
+		u16 *dest = (u16 *) to;
+		u16 *src  = (u16 *) (map->virt + from);
+		for (i = 0; i < (len / 2); i++) {
+			dest[i] = src[i];
+		}
+		if (len & 1)
+			*((u8 *)dest+len-1) = src[i] & 0xff;
+	}
+}
+
+static struct map_info bcm47xx_map = {
+	name: "Physically mapped flash",
+	size: WINDOW_SIZE,
+	bankwidth: BUSWIDTH,
+	phys: WINDOW_ADDR,
+};
+
+#ifdef CONFIG_MTD_PARTITIONS
+
+static struct mtd_partition bcm47xx_parts[] = {
+	{ name: "cfe",	offset: 0, size: 0, mask_flags: MTD_WRITEABLE, },
+	{ name: "linux", offset: 0, size: 0, },
+	{ name: "rootfs", offset: 0, size: 0, },
+	{ name: "nvram", offset: 0, size: 0, },
+	{ name: NULL, },
+};
+
+static int __init
+find_cfe_size(struct mtd_info *mtd, size_t size)
+{
+	struct trx_header *trx;
+	unsigned char buf[512];
+	int off;
+	size_t len;
+	int blocksize;
+
+	trx = (struct trx_header *) buf;
+
+	blocksize = mtd->erasesize;
+	if (blocksize < 0x10000)
+		blocksize = 0x10000;
+
+	for (off = (128*1024); off < size; off += blocksize) {
+		memset(buf, 0xe5, sizeof(buf));
+
+		/*
+		 * Read into buffer 
+		 */
+		if (mtd->read(mtd, off, sizeof(buf), &len, buf) ||
+		    len != sizeof(buf))
+			continue;
+
+		/* found a TRX header */
+		if (le32_to_cpu(trx->magic) == TRX_MAGIC) {
+			goto found;
+		}
+	}
+
+	printk(KERN_NOTICE
+	       "%s: Couldn't find bootloader size\n",
+	       mtd->name);
+	return -1;
+
+ found:
+	printk(KERN_NOTICE "bootloader size: %d\n", off);
+	return off;
+
+}
+
+/*
+ * Copied from mtdblock.c
+ *
+ * Cache stuff...
+ * 
+ * Since typical flash erasable sectors are much larger than what Linux's
+ * buffer cache can handle, we must implement read-modify-write on flash
+ * sectors for each block write requests.  To avoid over-erasing flash sectors
+ * and to speed things up, we locally cache a whole flash sector while it is
+ * being written to until a different sector is required.
+ */
+
+static void erase_callback(struct erase_info *done)
+{
+	wait_queue_head_t *wait_q = (wait_queue_head_t *)done->priv;
+	wake_up(wait_q);
+}
+
+static int erase_write (struct mtd_info *mtd, unsigned long pos, 
+			int len, const char *buf)
+{
+	struct erase_info erase;
+	DECLARE_WAITQUEUE(wait, current);
+	wait_queue_head_t wait_q;
+	size_t retlen;
+	int ret;
+
+	/*
+	 * First, let's erase the flash block.
+	 */
+
+	init_waitqueue_head(&wait_q);
+	erase.mtd = mtd;
+	erase.callback = erase_callback;
+	erase.addr = pos;
+	erase.len = len;
+	erase.priv = (u_long)&wait_q;
+
+	set_current_state(TASK_INTERRUPTIBLE);
+	add_wait_queue(&wait_q, &wait);
+
+	ret = mtd->erase(mtd, &erase);
+	if (ret) {
+		set_current_state(TASK_RUNNING);
+		remove_wait_queue(&wait_q, &wait);
+		printk (KERN_WARNING "erase of region [0x%lx, 0x%x] "
+				     "on \"%s\" failed\n",
+			pos, len, mtd->name);
+		return ret;
+	}
+
+	schedule();  /* Wait for erase to finish. */
+	remove_wait_queue(&wait_q, &wait);
+
+	/*
+	 * Next, writhe data to flash.
+	 */
+
+	ret = mtd->write (mtd, pos, len, &retlen, buf);
+	if (ret)
+		return ret;
+	if (retlen != len)
+		return -EIO;
+	return 0;
+}
+
+
+
+
+static int __init
+find_root(struct mtd_info *mtd, size_t size, struct mtd_partition *part)
+{
+	struct trx_header trx, *trx2;
+	unsigned char buf[512], *block;
+	int off, blocksize;
+	u32 i, crc = ~0;
+	size_t len;
+	struct squashfs_super_block *sb = (struct squashfs_super_block *) buf;
+
+	blocksize = mtd->erasesize;
+	if (blocksize < 0x10000)
+		blocksize = 0x10000;
+
+	for (off = (128*1024); off < size; off += blocksize) {
+		memset(&trx, 0xe5, sizeof(trx));
+
+		/*
+		 * Read into buffer 
+		 */
+		if (mtd->read(mtd, off, sizeof(trx), &len, (char *) &trx) ||
+		    len != sizeof(trx))
+			continue;
+
+		/* found a TRX header */
+		if (le32_to_cpu(trx.magic) == TRX_MAGIC) {
+			part->offset = le32_to_cpu(trx.offsets[2]) ? : 
+				le32_to_cpu(trx.offsets[1]);
+			part->size = le32_to_cpu(trx.len); 
+
+			part->size -= part->offset;
+			part->offset += off;
+
+			goto found;
+		}
+	}
+
+	printk(KERN_NOTICE
+	       "%s: Couldn't find root filesystem\n",
+	       mtd->name);
+	return -1;
+
+ found:
+	if (part->size == 0)
+		return 0;
+	
+	if (mtd->read(mtd, part->offset, sizeof(buf), &len, buf) || len != sizeof(buf))
+		return 0;
+
+	/* Move the fs outside of the trx */
+	part->size = 0;
+
+	if (trx.len != part->offset + part->size - off) {
+		/* Update the trx offsets and length */
+		trx.len = part->offset + part->size - off;
+	
+		/* Update the trx crc32 */
+		for (i = (u32) &(((struct trx_header *)NULL)->flag_version); i <= trx.len; i += sizeof(buf)) {
+			if (mtd->read(mtd, off + i, sizeof(buf), &len, buf) || len != sizeof(buf))
+				return 0;
+			crc = crc32_le(crc, buf, min(sizeof(buf), trx.len - i));
+		}
+		trx.crc32 = crc;
+
+		/* read first eraseblock from the trx */
+		block = kmalloc(mtd->erasesize, GFP_KERNEL);
+		trx2 = (struct trx_header *) block;
+		if (mtd->read(mtd, off, mtd->erasesize, &len, block) || len != mtd->erasesize) {
+			printk("Error accessing the first trx eraseblock\n");
+			return 0;
+		}
+		
+		printk("Updating TRX offsets and length:\n");
+		printk("old trx = [0x%08x, 0x%08x, 0x%08x], len=0x%08x crc32=0x%08x\n", trx2->offsets[0], trx2->offsets[1], trx2->offsets[2], trx2->len, trx2->crc32);
+		printk("new trx = [0x%08x, 0x%08x, 0x%08x], len=0x%08x crc32=0x%08x\n",   trx.offsets[0],   trx.offsets[1],   trx.offsets[2],   trx.len, trx.crc32);
+
+		/* Write updated trx header to the flash */
+		memcpy(block, &trx, sizeof(trx));
+		if (mtd->unlock)
+			mtd->unlock(mtd, off, mtd->erasesize);
+		erase_write(mtd, off, mtd->erasesize, block);
+		if (mtd->sync)
+			mtd->sync(mtd);
+		kfree(block);
+		printk("Done\n");
+	}
+	
+	return part->size;
+}
+
+struct mtd_partition * __init
+init_mtd_partitions(struct mtd_info *mtd, size_t size)
+{
+	int cfe_size;
+
+	if ((cfe_size = find_cfe_size(mtd,size)) < 0)
+		return NULL;
+
+	/* boot loader */
+	bcm47xx_parts[0].offset = 0;
+	bcm47xx_parts[0].size   = cfe_size;
+
+	/* nvram */
+	if (cfe_size != 384 * 1024) {
+		bcm47xx_parts[3].offset = size - ROUNDUP(NVRAM_SPACE, mtd->erasesize);
+		bcm47xx_parts[3].size   = ROUNDUP(NVRAM_SPACE, mtd->erasesize);
+	} else {
+		/* nvram (old 128kb config partition on netgear wgt634u) */
+		bcm47xx_parts[3].offset = bcm47xx_parts[0].size;
+		bcm47xx_parts[3].size   = ROUNDUP(NVRAM_SPACE, mtd->erasesize);
+	}
+
+	/* linux (kernel and rootfs) */
+	if (cfe_size != 384 * 1024) {
+		bcm47xx_parts[1].offset = bcm47xx_parts[0].size;
+		bcm47xx_parts[1].size   = bcm47xx_parts[3].offset - 
+			bcm47xx_parts[1].offset;
+	} else {
+		/* do not count the elf loader, which is on one block */
+		bcm47xx_parts[1].offset = bcm47xx_parts[0].size + 
+			bcm47xx_parts[3].size + mtd->erasesize;
+		bcm47xx_parts[1].size   = size - 
+			bcm47xx_parts[0].size - 
+			(2*bcm47xx_parts[3].size) - 
+			mtd->erasesize;
+	}
+
+	/* find and size rootfs */
+	find_root(mtd,size,&bcm47xx_parts[2]);
+	bcm47xx_parts[2].size = size - bcm47xx_parts[2].offset - bcm47xx_parts[3].size;
+
+	return bcm47xx_parts;
+}
+#endif
+
+int __init init_bcm47xx_map(void)
+{
+#ifdef CONFIG_SSB
+	struct ssb_mipscore *mcore = &ssb_bcm47xx.mipscore;
+#endif
+	size_t size;
+	int ret = 0;
+#ifdef CONFIG_MTD_PARTITIONS
+	struct mtd_partition *parts;
+	int i;
+#endif
+
+#ifdef CONFIG_SSB
+	u32 window = mcore->flash_window;
+	u32 window_size = mcore->flash_window_size;
+
+	printk("flash init: 0x%08x 0x%08x\n", window, window_size);
+	bcm47xx_map.phys = window;
+	bcm47xx_map.size = window_size;
+	bcm47xx_map.bankwidth = mcore->flash_buswidth;
+	bcm47xx_map.virt = ioremap_nocache(window, window_size);
+#else
+	printk("flash init: 0x%08x 0x%08x\n", WINDOW_ADDR, WINDOW_SIZE);
+	bcm47xx_map.virt = ioremap_nocache(WINDOW_ADDR, WINDOW_SIZE);
+#endif
+
+	if (!bcm47xx_map.virt) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+
+	simple_map_init(&bcm47xx_map);
+	
+	if (!(bcm47xx_mtd = do_map_probe("cfi_probe", &bcm47xx_map))) {
+		printk("Failed to do_map_probe\n");
+		iounmap((void *)bcm47xx_map.virt);
+		return -ENXIO;
+	}
+
+	/* override copy_from routine */
+ 	bcm47xx_map.copy_from = bcm47xx_map_copy_from;
+
+	bcm47xx_mtd->owner = THIS_MODULE;
+
+	size = bcm47xx_mtd->size;
+
+	printk(KERN_NOTICE "Flash device: 0x%x at 0x%x\n", size, WINDOW_ADDR);
+
+#ifdef CONFIG_MTD_PARTITIONS
+	parts = init_mtd_partitions(bcm47xx_mtd, size);
+	for (i = 0; parts[i].name; i++);
+	ret = add_mtd_partitions(bcm47xx_mtd, parts, i);
+	if (ret) {
+		printk(KERN_ERR "Flash: add_mtd_partitions failed\n");
+		goto fail;
+	}
+#endif
+	return 0;
+
+ fail:
+	if (bcm47xx_mtd)
+		map_destroy(bcm47xx_mtd);
+	if (bcm47xx_map.virt)
+		iounmap((void *)bcm47xx_map.virt);
+	bcm47xx_map.virt = 0;
+	return ret;
+}
+
+void __exit cleanup_bcm47xx_map(void)
+{
+#ifdef CONFIG_MTD_PARTITIONS
+	del_mtd_partitions(bcm47xx_mtd);
+#endif
+	map_destroy(bcm47xx_mtd);
+	iounmap((void *)bcm47xx_map.virt);
+}
+
+module_init(init_bcm47xx_map);
+module_exit(cleanup_bcm47xx_map);
diff -Nru linux-2.6.30.5/drivers/mtd/mtdchar.c linux-2.6.30.5-wrt/drivers/mtd/mtdchar.c
--- linux-2.6.30.5/drivers/mtd/mtdchar.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/mtd/mtdchar.c	2009-09-06 18:43:48.350677830 +0200
@@ -17,6 +17,7 @@
 
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/compatmac.h>
+#include <linux/mtd/partitions.h>
 
 #include <asm/uaccess.h>
 
@@ -750,6 +751,13 @@
 		file->f_pos = 0;
 		break;
 	}
+#ifdef CONFIG_MTD_PARTITIONS
+	case MTDREFRESH:
+	{
+		ret = refresh_mtd_partitions(mtd);
+		break;
+	}
+#endif
 
 	default:
 		ret = -ENOTTY;
diff -Nru linux-2.6.30.5/drivers/mtd/mtdpart.c linux-2.6.30.5-wrt/drivers/mtd/mtdpart.c
--- linux-2.6.30.5/drivers/mtd/mtdpart.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/mtd/mtdpart.c	2009-09-06 18:43:48.346667558 +0200
@@ -18,6 +18,8 @@
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
 #include <linux/mtd/compatmac.h>
+#include <linux/root_dev.h>
+#include <linux/magic.h>
 
 /* Our partition linked list */
 static LIST_HEAD(mtd_partitions);
@@ -37,7 +39,7 @@
  * the pointer to that structure with this macro.
  */
 #define PART(x)  ((struct mtd_part *)(x))
-
+#define IS_PART(mtd) (mtd->read == part_read)
 
 /*
  * MTD methods which simply translate the effective address and pass through
@@ -512,6 +514,155 @@
 	return slave;
 }
 
+#ifdef CONFIG_MTD_ROOTFS_SPLIT
+#define ROOTFS_SPLIT_NAME "rootfs_data"
+#define ROOTFS_REMOVED_NAME "<removed>"
+
+struct squashfs_super_block {
+	__le32 s_magic;
+	__le32 pad0[9];
+	__le64 bytes_used;
+};
+
+
+static int split_squashfs(struct mtd_info *master, int offset, int *split_offset)
+{
+	struct squashfs_super_block sb;
+	int len, ret;
+
+	ret = master->read(master, offset, sizeof(sb), &len, (void *) &sb);
+	if (ret || (len != sizeof(sb))) {
+		printk(KERN_ALERT "split_squashfs: error occured while reading "
+			"from \"%s\"\n", master->name);
+		return -EINVAL;
+	}
+
+	if (SQUASHFS_MAGIC != le32_to_cpu(sb.s_magic) ) {
+		printk(KERN_ALERT "split_squashfs: no squashfs found in \"%s\"\n",
+			master->name);
+		*split_offset = 0;
+		return 0;
+	}
+
+	if (le64_to_cpu((sb.bytes_used)) <= 0) {
+		printk(KERN_ALERT "split_squashfs: squashfs is empty in \"%s\"\n",
+			master->name);
+		*split_offset = 0;
+		return 0;
+	}
+
+	len = (u32) le64_to_cpu(sb.bytes_used);
+	len += (offset & 0x000fffff);
+	len +=  (master->erasesize - 1);
+	len &= ~(master->erasesize - 1);
+	len -= (offset & 0x000fffff);
+	*split_offset = offset + len;
+
+	return 0;
+}
+
+static int split_rootfs_data(struct mtd_info *master, struct mtd_info *rpart, const struct mtd_partition *part,
+		int index)
+{
+	struct mtd_partition *dpart;
+	struct mtd_part *slave = NULL;
+	int split_offset = 0;
+	int ret;
+
+	ret = split_squashfs(master, part->offset, &split_offset);
+	if (ret)
+		return ret;
+
+	if (split_offset <= 0)
+		return 0;
+
+	dpart = kmalloc(sizeof(*part)+sizeof(ROOTFS_SPLIT_NAME)+1, GFP_KERNEL);
+	if (dpart == NULL) {
+		printk(KERN_INFO "split_squashfs: no memory for partition \"%s\"\n",
+			ROOTFS_SPLIT_NAME);
+		return -ENOMEM;
+	}
+
+	memcpy(dpart, part, sizeof(*part));
+	dpart->name = (unsigned char *)&dpart[1];
+	strcpy(dpart->name, ROOTFS_SPLIT_NAME);
+
+	dpart->size -= split_offset - dpart->offset;
+	dpart->offset = split_offset;
+
+	if (dpart == NULL)
+		return 1;
+
+	printk(KERN_INFO "mtd: partition \"%s\" created automatically, ofs=%llX, len=%llX \n",
+		ROOTFS_SPLIT_NAME, dpart->offset, dpart->size);
+
+	slave = add_one_partition(master, dpart, index, split_offset);
+	if (!slave) {
+		kfree(dpart);
+		return -ENOMEM;
+	}
+	rpart->split = &slave->mtd;
+
+	return 0;
+}
+
+static int refresh_rootfs_split(struct mtd_info *mtd)
+{
+	struct mtd_partition tpart;
+	struct mtd_part *part;
+	char *name;
+	int index = 0;
+	int offset, size;
+	int ret;
+
+	part = PART(mtd);
+
+	/* check for the new squashfs offset first */
+	ret = split_squashfs(part->master, part->offset, &offset);
+	if (ret)
+		return ret;
+
+	if ((offset > 0) && !mtd->split) {
+		printk(KERN_INFO "%s: creating new split partition for \"%s\"\n", __func__, mtd->name);
+		/* if we don't have a rootfs split partition, create a new one */
+		tpart.name = (char *) mtd->name;
+		tpart.size = mtd->size;
+		tpart.offset = part->offset;
+
+		/* find the index of the last partition */
+		if (!list_empty(&mtd_partitions))
+			index = list_first_entry(&mtd_partitions, struct mtd_part, list)->index + 1;
+
+		return split_rootfs_data(part->master, &part->mtd, &tpart, index);
+	} else if ((offset > 0) && mtd->split) {
+		/* update the offsets of the existing partition */
+		size = mtd->size + part->offset - offset;
+
+		part = PART(mtd->split);
+		part->offset = offset;
+		part->mtd.size = size;
+		printk(KERN_INFO "%s: %s partition \"" ROOTFS_SPLIT_NAME "\", offset: 0x%06x (0x%06x)\n",
+			__func__, (!strcmp(part->mtd.name, ROOTFS_SPLIT_NAME) ? "updating" : "creating"),
+			(u32) part->offset, (u32) part->mtd.size);
+		name = kmalloc(sizeof(ROOTFS_SPLIT_NAME) + 1, GFP_KERNEL);
+		strcpy(name, ROOTFS_SPLIT_NAME);
+		part->mtd.name = name;
+	} else if ((offset <= 0) && mtd->split) {
+		printk(KERN_INFO "%s: removing partition \"%s\"\n", __func__, mtd->split->name);
+
+		/* mark existing partition as removed */
+		part = PART(mtd->split);
+		name = kmalloc(sizeof(ROOTFS_SPLIT_NAME) + 1, GFP_KERNEL);
+		strcpy(name, ROOTFS_REMOVED_NAME);
+		part->mtd.name = name;
+		part->offset = 0;
+		part->mtd.size = 0;
+	}
+
+	return 0;
+}
+#endif /* CONFIG_MTD_ROOTFS_SPLIT */
+
 /*
  * This function, given a master MTD object and a partition table, creates
  * and registers slave MTD objects which are bound to the master according to
@@ -527,14 +678,29 @@
 {
 	struct mtd_part *slave;
 	uint64_t cur_offset = 0;
-	int i;
+	int i, j, ret;
 
 	printk(KERN_NOTICE "Creating %d MTD partitions on \"%s\":\n", nbparts, master->name);
 
-	for (i = 0; i < nbparts; i++) {
-		slave = add_one_partition(master, parts + i, i, cur_offset);
+	for (i = 0, j = 0; i < nbparts; i++) {
+		slave = add_one_partition(master, parts + i, j++, cur_offset);
 		if (!slave)
 			return -ENOMEM;
+
+		if (!strcmp(parts[i].name, "rootfs") && slave->registered) {
+#ifdef CONFIG_MTD_ROOTFS_ROOT_DEV
+			if (ROOT_DEV == 0) {
+				printk(KERN_NOTICE "mtd: partition \"rootfs\" "
+					"set to be root filesystem\n");
+				ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, slave->mtd.index);
+			}
+#endif
+#ifdef CONFIG_MTD_ROOTFS_SPLIT
+			ret = split_rootfs_data(master, &slave->mtd, &parts[i], j);
+			if (ret == 0)
+				j++;
+#endif
+		}
 		cur_offset = slave->offset + slave->mtd.size;
 	}
 
@@ -542,6 +708,32 @@
 }
 EXPORT_SYMBOL(add_mtd_partitions);
 
+int refresh_mtd_partitions(struct mtd_info *mtd)
+{
+	int ret = 0;
+
+	if (IS_PART(mtd)) {
+		struct mtd_part *part;
+		struct mtd_info *master;
+
+		part = PART(mtd);
+		master = part->master;
+		if (master->refresh_device)
+			ret = master->refresh_device(master);
+	}
+
+	if (!ret && mtd->refresh_device)
+		ret = mtd->refresh_device(mtd);
+
+#ifdef CONFIG_MTD_ROOTFS_SPLIT
+	if (!ret && IS_PART(mtd) && !strcmp(mtd->name, "rootfs"))
+		refresh_rootfs_split(mtd);
+#endif
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(refresh_mtd_partitions);
+
 static DEFINE_SPINLOCK(part_parser_lock);
 static LIST_HEAD(part_parsers);
 
diff -Nru linux-2.6.30.5/drivers/mtd/nand/nand_ecc.c linux-2.6.30.5-wrt/drivers/mtd/nand/nand_ecc.c
--- linux-2.6.30.5/drivers/mtd/nand/nand_ecc.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/mtd/nand/nand_ecc.c	2009-09-06 18:43:48.358667468 +0200
@@ -492,8 +492,7 @@
 	if ((bitsperbyte[b0] + bitsperbyte[b1] + bitsperbyte[b2]) == 1)
 		return 1;	/* error in ecc data; no action needed */
 
-	printk(KERN_ERR "uncorrectable error : ");
-	return -1;
+	return -EBADMSG;
 }
 EXPORT_SYMBOL(nand_correct_data);
 
diff -Nru linux-2.6.30.5/drivers/mtd/nand/plat_nand.c linux-2.6.30.5-wrt/drivers/mtd/nand/plat_nand.c
--- linux-2.6.30.5/drivers/mtd/nand/plat_nand.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/mtd/nand/plat_nand.c	2009-09-06 18:43:48.354667544 +0200
@@ -71,7 +71,18 @@
 	platform_set_drvdata(pdev, data);
 
 	/* Scan to find existance of the device */
-	if (nand_scan(&data->mtd, 1)) {
+	if (nand_scan_ident(&data->mtd, 1)) {
+		res = -ENXIO;
+		goto out;
+	}
+
+	if (pdata->chip.chip_fixup) {
+		res = pdata->chip.chip_fixup(&data->mtd);
+		if (res)
+			goto out;
+	}
+
+	if (nand_scan_tail(&data->mtd)) {
 		res = -ENXIO;
 		goto out;
 	}
diff -Nru linux-2.6.30.5/drivers/mtd/redboot.c linux-2.6.30.5-wrt/drivers/mtd/redboot.c
--- linux-2.6.30.5/drivers/mtd/redboot.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/mtd/redboot.c	2009-09-06 18:43:48.350677830 +0200
@@ -11,6 +11,8 @@
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
 
+#define BOARD_CONFIG_PART		"boardconfig"
+
 struct fis_image_desc {
     unsigned char name[16];      // Null terminated name
     uint32_t	  flash_base;    // Address within FLASH of image
@@ -41,6 +43,7 @@
                              struct mtd_partition **pparts,
                              unsigned long fis_origin)
 {
+	unsigned long max_offset = 0;
 	int nrparts = 0;
 	struct fis_image_desc *buf;
 	struct mtd_partition *parts;
@@ -209,14 +212,14 @@
 		}
 	}
 #endif
-	parts = kzalloc(sizeof(*parts)*nrparts + nulllen + namelen, GFP_KERNEL);
+	parts = kzalloc(sizeof(*parts) * (nrparts + 1) + nulllen + namelen + sizeof(BOARD_CONFIG_PART), GFP_KERNEL);
 
 	if (!parts) {
 		ret = -ENOMEM;
 		goto out;
 	}
 
-	nullname = (char *)&parts[nrparts];
+	nullname = (char *)&parts[nrparts + 1];
 #ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED
 	if (nulllen > 0) {
 		strcpy(nullname, nullstring);
@@ -235,6 +238,8 @@
 	}
 #endif
 	for ( ; i<nrparts; i++) {
+		if(max_offset < buf[i].flash_base + buf[i].size)
+			max_offset = buf[i].flash_base + buf[i].size;
 		parts[i].size = fl->img->size;
 		parts[i].offset = fl->img->flash_base;
 		parts[i].name = names;
@@ -249,18 +254,33 @@
 #endif
 		names += strlen(names)+1;
 
-#ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED
 		if(fl->next && fl->img->flash_base + fl->img->size + master->erasesize <= fl->next->img->flash_base) {
-			i++;
-			parts[i].offset = parts[i-1].size + parts[i-1].offset;
-			parts[i].size = fl->next->img->flash_base - parts[i].offset;
-			parts[i].name = nullname;
-		}
+			if (!strcmp(parts[i].name, "rootfs")) {
+				parts[i].size = fl->next->img->flash_base;
+				parts[i].size &= ~(master->erasesize - 1);
+				parts[i].size -= parts[i].offset;
+#ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED
+				nrparts--;
+			} else {
+				i++;
+				parts[i].offset = parts[i-1].size + parts[i-1].offset;
+				parts[i].size = fl->next->img->flash_base - parts[i].offset;
+				parts[i].name = nullname;
 #endif
+			}
+		}
 		tmp_fl = fl;
 		fl = fl->next;
 		kfree(tmp_fl);
 	}
+	if(master->size - max_offset >= master->erasesize)
+	{
+		parts[nrparts].size = master->size - max_offset;
+		parts[nrparts].offset = max_offset;
+		parts[nrparts].name = names;
+		strcpy(names, BOARD_CONFIG_PART);
+		nrparts++;
+	}
 	ret = nrparts;
 	*pparts = parts;
  out:
diff -Nru linux-2.6.30.5/drivers/net/Kconfig linux-2.6.30.5-wrt/drivers/net/Kconfig
--- linux-2.6.30.5/drivers/net/Kconfig	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/net/Kconfig	2009-09-06 18:43:48.382672077 +0200
@@ -119,6 +119,129 @@
 	  To compile this driver as a module, choose M here: the module
 	  will be called eql.  If unsure, say N.
 
+config IMQ
+	tristate "IMQ (intermediate queueing device) support"
+	depends on NETDEVICES && NETFILTER
+	---help---
+	  The IMQ device(s) is used as placeholder for QoS queueing
+	  disciplines. Every packet entering/leaving the IP stack can be
+	  directed through the IMQ device where it's enqueued/dequeued to the
+	  attached qdisc. This allows you to treat network devices as classes
+	  and distribute bandwidth among them. Iptables is used to specify
+	  through which IMQ device, if any, packets travel.
+
+	  More information at: http://www.linuximq.net/
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called imq.  If unsure, say N.
+
+choice
+	prompt "IMQ behavior (PRE/POSTROUTING)"
+	depends on IMQ
+	default IMQ_BEHAVIOR_AB
+	help
+
+		This settings defines how IMQ behaves in respect to its
+		hooking in PREROUTING and POSTROUTING.
+
+		IMQ can work in any of the following ways:
+
+		    PREROUTING   |      POSTROUTING
+		-----------------|-------------------
+		#1  After NAT    |      After NAT
+		#2  After NAT    |      Before NAT
+		#3  Before NAT   |      After NAT
+		#4  Before NAT   |      Before NAT
+
+		The default behavior is to hook before NAT on PREROUTING
+		and after NAT on POSTROUTING (#3).
+
+		This settings are specially usefull when trying to use IMQ
+		to shape NATed clients.
+
+		More information can be found at: www.linuximq.net
+
+		If not sure leave the default settings alone.
+
+config IMQ_BEHAVIOR_AA
+	bool "IMQ AA"
+	help
+		This settings defines how IMQ behaves in respect to its
+		hooking in PREROUTING and POSTROUTING.
+
+		Choosing this option will make IMQ hook like this:
+
+		PREROUTING:   After NAT
+		POSTROUTING:  After NAT
+
+		More information can be found at: www.linuximq.net
+
+		If not sure leave the default settings alone.
+
+config IMQ_BEHAVIOR_AB
+	bool "IMQ AB"
+	help
+		This settings defines how IMQ behaves in respect to its
+		hooking in PREROUTING and POSTROUTING.
+
+		Choosing this option will make IMQ hook like this:
+
+		PREROUTING:   After NAT
+		POSTROUTING:  Before NAT
+
+		More information can be found at: www.linuximq.net
+
+		If not sure leave the default settings alone.
+
+config IMQ_BEHAVIOR_BA
+	bool "IMQ BA"
+	help
+		This settings defines how IMQ behaves in respect to its
+		hooking in PREROUTING and POSTROUTING.
+
+		Choosing this option will make IMQ hook like this:
+
+		PREROUTING:   Before NAT
+		POSTROUTING:  After NAT
+
+		More information can be found at: www.linuximq.net
+
+		If not sure leave the default settings alone.
+
+config IMQ_BEHAVIOR_BB
+	bool "IMQ BB"
+	help
+		This settings defines how IMQ behaves in respect to its
+		hooking in PREROUTING and POSTROUTING.
+
+		Choosing this option will make IMQ hook like this:
+
+		PREROUTING:   Before NAT
+		POSTROUTING:  Before NAT
+
+		More information can be found at: www.linuximq.net
+
+		If not sure leave the default settings alone.
+
+endchoice
+
+config IMQ_NUM_DEVS
+
+	int "Number of IMQ devices"
+	range 2 16
+	depends on IMQ
+	default "16"
+	help
+
+		This settings defines how many IMQ devices will be
+		created.
+
+		The default value is 16.
+
+		More information can be found at: www.linuximq.net
+
+		If not sure leave the default settings alone.
+
 config TUN
 	tristate "Universal TUN/TAP device driver support"
 	select CRC32
diff -Nru linux-2.6.30.5/drivers/net/Makefile linux-2.6.30.5-wrt/drivers/net/Makefile
--- linux-2.6.30.5/drivers/net/Makefile	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/net/Makefile	2009-09-06 18:43:48.382672077 +0200
@@ -152,6 +152,7 @@
 obj-$(CONFIG_XEN_NETDEV_FRONTEND) += xen-netfront.o
 
 obj-$(CONFIG_DUMMY) += dummy.o
+obj-$(CONFIG_IMQ) += imq.o
 obj-$(CONFIG_IFB) += ifb.o
 obj-$(CONFIG_MACVLAN) += macvlan.o
 obj-$(CONFIG_DE600) += de600.o
diff -Nru linux-2.6.30.5/drivers/net/b44.c linux-2.6.30.5-wrt/drivers/net/b44.c
--- linux-2.6.30.5/drivers/net/b44.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/net/b44.c	2009-09-06 18:48:23.514666979 +0200
@@ -339,7 +339,7 @@
 		}
 	}
 
-	return 0;
+	return err;
 }
 
 static void __b44_set_flow_ctrl(struct b44 *bp, u32 pause_flags)
@@ -815,7 +815,7 @@
 			struct sk_buff *copy_skb;
 
 			b44_recycle_rx(bp, cons, bp->rx_prod);
-			copy_skb = dev_alloc_skb(len + 2);
+			copy_skb = netdev_alloc_skb(bp->dev, len + 2);
 			if (copy_skb == NULL)
 				goto drop_it_no_recycle;
 
@@ -2220,6 +2220,10 @@
 	 */
 	b44_chip_reset(bp, B44_CHIP_RESET_FULL);
 
+	/* do a phy reset to test if there is an active phy */
+	if (b44_phy_reset(bp) < 0)
+		bp->phy_addr = B44_PHY_ADDR_NO_PHY;
+
 	printk(KERN_INFO "%s: Broadcom 44xx/47xx 10/100BaseT Ethernet %pM\n",
 	       dev->name, dev->dev_addr);
 
diff -Nru linux-2.6.30.5/drivers/net/imq.c linux-2.6.30.5-wrt/drivers/net/imq.c
--- linux-2.6.30.5/drivers/net/imq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/drivers/net/imq.c	2009-09-06 18:43:48.378666801 +0200
@@ -0,0 +1,571 @@
+/*
+ *             Pseudo-driver for the intermediate queue device.
+ *
+ *             This program is free software; you can redistribute it and/or
+ *             modify it under the terms of the GNU General Public License
+ *             as published by the Free Software Foundation; either version
+ *             2 of the License, or (at your option) any later version.
+ *
+ * Authors:    Patrick McHardy, <kaber@trash.net>
+ *
+ *            The first version was written by Martin Devera, <devik@cdi.cz>
+ *
+ * Credits:    Jan Rafaj <imq2t@cedric.vabo.cz>
+ *              - Update patch to 2.4.21
+ *             Sebastian Strollo <sstrollo@nortelnetworks.com>
+ *              - Fix "Dead-loop on netdevice imq"-issue
+ *             Marcel Sebek <sebek64@post.cz>
+ *              - Update to 2.6.2-rc1
+ *
+ *	       After some time of inactivity there is a group taking care
+ *	       of IMQ again: http://www.linuximq.net
+ *
+ *
+ *	       2004/06/30 - New version of IMQ patch to kernels <=2.6.7
+ *             including the following changes:
+ *
+ *	       - Correction of ipv6 support "+"s issue (Hasso Tepper)
+ *	       - Correction of imq_init_devs() issue that resulted in
+ *	       kernel OOPS unloading IMQ as module (Norbert Buchmuller)
+ *	       - Addition of functionality to choose number of IMQ devices
+ *	       during kernel config (Andre Correa)
+ *	       - Addition of functionality to choose how IMQ hooks on
+ *	       PRE and POSTROUTING (after or before NAT) (Andre Correa)
+ *	       - Cosmetic corrections (Norbert Buchmuller) (Andre Correa)
+ *
+ *
+ *             2005/12/16 - IMQ versions between 2.6.7 and 2.6.13 were
+ *             released with almost no problems. 2.6.14-x was released
+ *             with some important changes: nfcache was removed; After
+ *             some weeks of trouble we figured out that some IMQ fields
+ *             in skb were missing in skbuff.c - skb_clone and copy_skb_header.
+ *             These functions are correctly patched by this new patch version.
+ *
+ *             Thanks for all who helped to figure out all the problems with
+ *             2.6.14.x: Patrick McHardy, Rune Kock, VeNoMouS, Max CtRiX,
+ *             Kevin Shanahan, Richard Lucassen, Valery Dachev (hopefully
+ *             I didn't forget anybody). I apologize again for my lack of time.
+ *
+ *
+ *             2008/06/17 - 2.6.25 - Changed imq.c to use qdisc_run() instead
+ *             of qdisc_restart() and moved qdisc_run() to tasklet to avoid
+ *             recursive locking. New initialization routines to fix 'rmmod' not
+ *             working anymore. Used code from ifb.c. (Jussi Kivilinna)
+ *
+ *             2008/08/06 - 2.6.26 - (JK)
+ *              - Replaced tasklet with 'netif_schedule()'.
+ *              - Cleaned up and added comments for imq_nf_queue().
+ *
+ *             2009/04/12
+ *              - Add skb_save_cb/skb_restore_cb helper functions for backuping
+ *                control buffer. This is needed because qdisc-layer on kernels
+ *                2.6.27 and newer overwrite control buffer. (Jussi Kivilinna)
+ *              - Add better locking for IMQ device. Hopefully this will solve
+ *                SMP issues. (Jussi Kivilinna)
+ *              - Port to 2.6.27
+ *              - Port to 2.6.28
+ *              - Port to 2.6.29 + fix rmmod not working
+ *
+ *             2009/04/20 - (Jussi Kivilinna)
+ *              - Use netdevice feature flags to avoid extra packet handling
+ *                by core networking layer and possibly increase performance.
+ *
+ *	       Also, many thanks to pablo Sebastian Greco for making the initial
+ *	       patch and to those who helped the testing.
+ *
+ *             More info at: http://www.linuximq.net/ (Andre Correa)
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/moduleparam.h>
+#include <linux/list.h>
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/rtnetlink.h>
+#include <linux/if_arp.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter_ipv4.h>
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+	#include <linux/netfilter_ipv6.h>
+#endif
+#include <linux/imq.h>
+#include <net/pkt_sched.h>
+#include <net/netfilter/nf_queue.h>
+
+static nf_hookfn imq_nf_hook;
+
+static struct nf_hook_ops imq_ingress_ipv4 = {
+	.hook		= imq_nf_hook,
+	.owner		= THIS_MODULE,
+	.pf		= PF_INET,
+	.hooknum	= NF_INET_PRE_ROUTING,
+#if defined(CONFIG_IMQ_BEHAVIOR_BA) || defined(CONFIG_IMQ_BEHAVIOR_BB)
+	.priority	= NF_IP_PRI_MANGLE + 1
+#else
+	.priority	= NF_IP_PRI_NAT_DST + 1
+#endif
+};
+
+static struct nf_hook_ops imq_egress_ipv4 = {
+	.hook		= imq_nf_hook,
+	.owner		= THIS_MODULE,
+	.pf		= PF_INET,
+	.hooknum	= NF_INET_POST_ROUTING,
+#if defined(CONFIG_IMQ_BEHAVIOR_AA) || defined(CONFIG_IMQ_BEHAVIOR_BA)
+	.priority	= NF_IP_PRI_LAST
+#else
+	.priority	= NF_IP_PRI_NAT_SRC - 1
+#endif
+};
+
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+static struct nf_hook_ops imq_ingress_ipv6 = {
+	.hook		= imq_nf_hook,
+	.owner		= THIS_MODULE,
+	.pf		= PF_INET6,
+	.hooknum	= NF_INET_PRE_ROUTING,
+#if defined(CONFIG_IMQ_BEHAVIOR_BA) || defined(CONFIG_IMQ_BEHAVIOR_BB)
+	.priority	= NF_IP6_PRI_MANGLE + 1
+#else
+	.priority	= NF_IP6_PRI_NAT_DST + 1
+#endif
+};
+
+static struct nf_hook_ops imq_egress_ipv6 = {
+	.hook		= imq_nf_hook,
+	.owner		= THIS_MODULE,
+	.pf		= PF_INET6,
+	.hooknum	= NF_INET_POST_ROUTING,
+#if defined(CONFIG_IMQ_BEHAVIOR_AA) || defined(CONFIG_IMQ_BEHAVIOR_BA)
+	.priority	= NF_IP6_PRI_LAST
+#else
+	.priority	= NF_IP6_PRI_NAT_SRC - 1
+#endif
+};
+#endif
+
+#if defined(CONFIG_IMQ_NUM_DEVS)
+static unsigned int numdevs = CONFIG_IMQ_NUM_DEVS;
+#else
+static unsigned int numdevs = IMQ_MAX_DEVS;
+#endif
+
+static DEFINE_SPINLOCK(imq_nf_queue_lock);
+
+static struct net_device *imq_devs_cache[IMQ_MAX_DEVS];
+
+
+static struct net_device_stats *imq_get_stats(struct net_device *dev)
+{
+	return &dev->stats;
+}
+
+/* called for packets kfree'd in qdiscs at places other than enqueue */
+static void imq_skb_destructor(struct sk_buff *skb)
+{
+	struct nf_queue_entry *entry = skb->nf_queue_entry;
+
+	if (entry) {
+		nf_queue_entry_release_refs(entry);
+		kfree(entry);
+	}
+
+	skb_restore_cb(skb); /* kfree backup */
+}
+
+static void imq_nf_reinject(struct nf_queue_entry *entry, unsigned int verdict)
+{
+	int status;
+
+	if (!entry->next_outfn) {
+		spin_lock_bh(&imq_nf_queue_lock);
+		nf_reinject(entry, verdict);
+		spin_unlock_bh(&imq_nf_queue_lock);
+		return;
+	}
+
+	rcu_read_lock();
+	local_bh_disable();
+	status = entry->next_outfn(entry, entry->next_queuenum);
+	local_bh_enable();
+	if (status < 0) {
+		nf_queue_entry_release_refs(entry);
+		kfree_skb(entry->skb);
+		kfree(entry);
+	}
+
+	rcu_read_unlock();
+}
+
+static int imq_dev_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	dev->stats.tx_bytes += skb->len;
+	dev->stats.tx_packets++;
+
+	skb->imq_flags = 0;
+	skb->destructor = NULL;
+
+	skb_restore_cb(skb); /* restore skb->cb */
+
+	dev->trans_start = jiffies;
+	imq_nf_reinject(skb->nf_queue_entry, NF_ACCEPT);
+	return 0;
+}
+
+static int imq_nf_queue(struct nf_queue_entry *entry, unsigned queue_num)
+{
+	struct net_device *dev;
+	struct sk_buff *skb_orig, *skb, *skb_shared;
+	struct Qdisc *q;
+	struct netdev_queue *txq;
+	int users, index;
+	int retval = -EINVAL;
+
+	index = entry->skb->imq_flags & IMQ_F_IFMASK;
+	if (unlikely(index > numdevs - 1)) {
+		if (net_ratelimit())
+			printk(KERN_WARNING
+			       "IMQ: invalid device specified, highest is %u\n",
+			       numdevs - 1);
+		retval = -EINVAL;
+		goto out;
+	}
+
+	/* check for imq device by index from cache */
+	dev = imq_devs_cache[index];
+	if (unlikely(!dev)) {
+		char buf[8];
+
+		/* get device by name and cache result */
+		snprintf(buf, sizeof(buf), "imq%d", index);
+		dev = dev_get_by_name(&init_net, buf);
+		if (!dev) {
+			/* not found ?!*/
+			BUG();
+			retval = -ENODEV;
+			goto out;
+		}
+
+		imq_devs_cache[index] = dev;
+		dev_put(dev);
+	}
+
+	if (unlikely(!(dev->flags & IFF_UP))) {
+		entry->skb->imq_flags = 0;
+		imq_nf_reinject(entry, NF_ACCEPT);
+		retval = 0;
+		goto out;
+	}
+	dev->last_rx = jiffies;
+
+	skb = entry->skb;
+	skb_orig = NULL;
+
+	/* skb has owner? => make clone */
+	if (unlikely(skb->destructor)) {
+		skb_orig = skb;
+		skb = skb_clone(skb, GFP_ATOMIC);
+		if (!skb) {
+			retval = -ENOMEM;
+			goto out;
+		}
+		entry->skb = skb;
+	}
+
+	skb->nf_queue_entry = entry;
+
+	dev->stats.rx_bytes += skb->len;
+	dev->stats.rx_packets++;
+
+	txq = dev_pick_tx(dev, skb);
+
+	q = rcu_dereference(txq->qdisc);
+	if (unlikely(!q->enqueue))
+		goto packet_not_eaten_by_imq_dev;
+
+	spin_lock_bh(qdisc_lock(q));
+
+	users = atomic_read(&skb->users);
+
+	skb_shared = skb_get(skb); /* increase reference count by one */
+	skb_save_cb(skb_shared); /* backup skb->cb, as qdisc layer will
+					overwrite it */
+	qdisc_enqueue_root(skb_shared, q); /* might kfree_skb */
+
+	if (likely(atomic_read(&skb_shared->users) == users + 1)) {
+		kfree_skb(skb_shared); /* decrease reference count by one */
+
+		skb->destructor = &imq_skb_destructor;
+
+		/* cloned? */
+		if (skb_orig)
+			kfree_skb(skb_orig); /* free original */
+
+		spin_unlock_bh(qdisc_lock(q));
+
+		/* schedule qdisc dequeue */
+		__netif_schedule(q);
+
+		retval = 0;
+		goto out;
+	} else {
+		skb_restore_cb(skb_shared); /* restore skb->cb */
+		/* qdisc dropped packet and decreased skb reference count of
+		 * skb, so we don't really want to and try refree as that would
+		 * actually destroy the skb. */
+		spin_unlock_bh(qdisc_lock(q));
+		goto packet_not_eaten_by_imq_dev;
+	}
+
+packet_not_eaten_by_imq_dev:
+	/* cloned? restore original */
+	if (skb_orig) {
+		kfree_skb(skb);
+		entry->skb = skb_orig;
+	}
+	retval = -1;
+out:
+	return retval;
+}
+
+static struct nf_queue_handler nfqh = {
+	.name  = "imq",
+	.outfn = imq_nf_queue,
+};
+
+static unsigned int imq_nf_hook(unsigned int hook, struct sk_buff *pskb,
+				const struct net_device *indev,
+				const struct net_device *outdev,
+				int (*okfn)(struct sk_buff *))
+{
+	if (pskb->imq_flags & IMQ_F_ENQUEUE)
+		return NF_QUEUE;
+
+	return NF_ACCEPT;
+}
+
+static int imq_close(struct net_device *dev)
+{
+	netif_stop_queue(dev);
+	return 0;
+}
+
+static int imq_open(struct net_device *dev)
+{
+	netif_start_queue(dev);
+	return 0;
+}
+
+static const struct net_device_ops imq_netdev_ops = {
+	.ndo_open		= imq_open,
+	.ndo_stop		= imq_close,
+	.ndo_start_xmit		= imq_dev_xmit,
+	.ndo_get_stats		= imq_get_stats,
+};
+
+static void imq_setup(struct net_device *dev)
+{
+	dev->netdev_ops		= &imq_netdev_ops;
+	dev->type               = ARPHRD_VOID;
+	dev->mtu                = 16000;
+	dev->tx_queue_len       = 11000;
+	dev->flags              = IFF_NOARP;
+	dev->features           = NETIF_F_SG | NETIF_F_FRAGLIST |
+				  NETIF_F_GSO | NETIF_F_HW_CSUM |
+				  NETIF_F_HIGHDMA;
+}
+
+static int imq_validate(struct nlattr *tb[], struct nlattr *data[])
+{
+	int ret = 0;
+
+	if (tb[IFLA_ADDRESS]) {
+		if (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN) {
+			ret = -EINVAL;
+			goto end;
+		}
+		if (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS]))) {
+			ret = -EADDRNOTAVAIL;
+			goto end;
+		}
+	}
+	return 0;
+end:
+	printk(KERN_WARNING "IMQ: imq_validate failed (%d)\n", ret);
+	return ret;
+}
+
+static struct rtnl_link_ops imq_link_ops __read_mostly = {
+	.kind		= "imq",
+	.priv_size	= 0,
+	.setup		= imq_setup,
+	.validate	= imq_validate,
+};
+
+static int __init imq_init_hooks(void)
+{
+	int err;
+
+	nf_register_queue_imq_handler(&nfqh);
+
+	err = nf_register_hook(&imq_ingress_ipv4);
+	if (err)
+		goto err1;
+
+	err = nf_register_hook(&imq_egress_ipv4);
+	if (err)
+		goto err2;
+
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+	err = nf_register_hook(&imq_ingress_ipv6);
+	if (err)
+		goto err3;
+
+	err = nf_register_hook(&imq_egress_ipv6);
+	if (err)
+		goto err4;
+#endif
+
+	return 0;
+
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+err4:
+	nf_unregister_hook(&imq_ingress_ipv6);
+err3:
+	nf_unregister_hook(&imq_egress_ipv4);
+#endif
+err2:
+	nf_unregister_hook(&imq_ingress_ipv4);
+err1:
+	nf_unregister_queue_imq_handler();
+	return err;
+}
+
+static int __init imq_init_one(int index)
+{
+	struct net_device *dev;
+	int ret;
+
+	dev = alloc_netdev(0, "imq%d", imq_setup);
+	if (!dev)
+		return -ENOMEM;
+
+	ret = dev_alloc_name(dev, dev->name);
+	if (ret < 0)
+		goto fail;
+
+	dev->rtnl_link_ops = &imq_link_ops;
+	ret = register_netdevice(dev);
+	if (ret < 0)
+		goto fail;
+
+	return 0;
+fail:
+	free_netdev(dev);
+	return ret;
+}
+
+static int __init imq_init_devs(void)
+{
+	int err, i;
+
+	if (numdevs < 1 || numdevs > IMQ_MAX_DEVS) {
+		printk(KERN_ERR "IMQ: numdevs has to be betweed 1 and %u\n",
+		       IMQ_MAX_DEVS);
+		return -EINVAL;
+	}
+
+	rtnl_lock();
+	err = __rtnl_link_register(&imq_link_ops);
+
+	for (i = 0; i < numdevs && !err; i++)
+		err = imq_init_one(i);
+
+	if (err) {
+		__rtnl_link_unregister(&imq_link_ops);
+		memset(imq_devs_cache, 0, sizeof(imq_devs_cache));
+	}
+	rtnl_unlock();
+
+	return err;
+}
+
+static int __init imq_init_module(void)
+{
+	int err;
+
+#if defined(CONFIG_IMQ_NUM_DEVS)
+	BUILD_BUG_ON(CONFIG_IMQ_NUM_DEVS > 16);
+	BUILD_BUG_ON(CONFIG_IMQ_NUM_DEVS < 2);
+	BUILD_BUG_ON(CONFIG_IMQ_NUM_DEVS - 1 > IMQ_F_IFMASK);
+#endif
+
+	err = imq_init_devs();
+	if (err) {
+		printk(KERN_ERR "IMQ: Error trying imq_init_devs(net)\n");
+		return err;
+	}
+
+	err = imq_init_hooks();
+	if (err) {
+		printk(KERN_ERR "IMQ: Error trying imq_init_hooks()\n");
+		rtnl_link_unregister(&imq_link_ops);
+		memset(imq_devs_cache, 0, sizeof(imq_devs_cache));
+		return err;
+	}
+
+	printk(KERN_INFO "IMQ driver loaded successfully.\n");
+
+#if defined(CONFIG_IMQ_BEHAVIOR_BA) || defined(CONFIG_IMQ_BEHAVIOR_BB)
+	printk(KERN_INFO "\tHooking IMQ before NAT on PREROUTING.\n");
+#else
+	printk(KERN_INFO "\tHooking IMQ after NAT on PREROUTING.\n");
+#endif
+#if defined(CONFIG_IMQ_BEHAVIOR_AB) || defined(CONFIG_IMQ_BEHAVIOR_BB)
+	printk(KERN_INFO "\tHooking IMQ before NAT on POSTROUTING.\n");
+#else
+	printk(KERN_INFO "\tHooking IMQ after NAT on POSTROUTING.\n");
+#endif
+
+	return 0;
+}
+
+static void __exit imq_unhook(void)
+{
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+	nf_unregister_hook(&imq_ingress_ipv6);
+	nf_unregister_hook(&imq_egress_ipv6);
+#endif
+	nf_unregister_hook(&imq_ingress_ipv4);
+	nf_unregister_hook(&imq_egress_ipv4);
+
+	nf_unregister_queue_imq_handler();
+}
+
+static void __exit imq_cleanup_devs(void)
+{
+	rtnl_link_unregister(&imq_link_ops);
+	memset(imq_devs_cache, 0, sizeof(imq_devs_cache));
+}
+
+static void __exit imq_exit_module(void)
+{
+	imq_unhook();
+	imq_cleanup_devs();
+	printk(KERN_INFO "IMQ driver unloaded successfully.\n");
+}
+
+module_init(imq_init_module);
+module_exit(imq_exit_module);
+
+module_param(numdevs, int, 0);
+MODULE_PARM_DESC(numdevs, "number of IMQ devices (how many imq* devices will "
+			"be created)");
+MODULE_AUTHOR("http://www.linuximq.net");
+MODULE_DESCRIPTION("Pseudo-driver for the intermediate queue device. See "
+			"http://www.linuximq.net/ for more information.");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_RTNL_LINK("imq");
+
diff -Nru linux-2.6.30.5/drivers/net/phy/Kconfig linux-2.6.30.5-wrt/drivers/net/phy/Kconfig
--- linux-2.6.30.5/drivers/net/phy/Kconfig	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/net/phy/Kconfig	2009-09-06 18:44:06.787166740 +0200
@@ -13,6 +13,12 @@
 
 if PHYLIB
 
+config SWCONFIG
+	tristate "Switch configuration API"
+	---help---
+	  Switch configuration API using netlink. This allows
+	  you to configure the VLAN features of certain switches.
+
 comment "MII PHY device drivers"
 
 config MARVELL_PHY
@@ -82,6 +88,26 @@
 	---help---
 	  Supports the LSI ET1011C PHY.
 
+config ADM6996_PHY
+	tristate "Driver for ADM6996 switches"
+	---help---
+	  Currently supports the ADM6996F switch
+
+config MVSWITCH_PHY
+	tristate "Driver for Marvell 88E6060 switches"
+
+config IP175C_PHY
+	tristate "Driver for IC+ IP175C/IP178C switches"
+	select SWCONFIG
+
+config AR8216_PHY
+	tristate "Driver for Atheros AR8216 switches"
+	select SWCONFIG
+
+config RTL8306_PHY
+	tristate "Driver for Realtek RTL8306S switches"
+	select SWCONFIG
+
 config FIXED_PHY
 	bool "Driver for MDIO Bus/PHY emulation with fixed speed/link PHYs"
 	depends on PHYLIB=y
diff -Nru linux-2.6.30.5/drivers/net/phy/Makefile linux-2.6.30.5-wrt/drivers/net/phy/Makefile
--- linux-2.6.30.5/drivers/net/phy/Makefile	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/net/phy/Makefile	2009-09-06 18:44:06.787166740 +0200
@@ -3,6 +3,7 @@
 libphy-objs			:= phy.o phy_device.o mdio_bus.o
 
 obj-$(CONFIG_PHYLIB)		+= libphy.o
+obj-$(CONFIG_SWCONFIG)		+= swconfig.o
 obj-$(CONFIG_MARVELL_PHY)	+= marvell.o
 obj-$(CONFIG_DAVICOM_PHY)	+= davicom.o
 obj-$(CONFIG_CICADA_PHY)	+= cicada.o
@@ -12,7 +13,12 @@
 obj-$(CONFIG_VITESSE_PHY)	+= vitesse.o
 obj-$(CONFIG_BROADCOM_PHY)	+= broadcom.o
 obj-$(CONFIG_ICPLUS_PHY)	+= icplus.o
+obj-$(CONFIG_ADM6996_PHY)	+= adm6996.o
+obj-$(CONFIG_MVSWITCH_PHY)	+= mvswitch.o
+obj-$(CONFIG_IP175C_PHY)	+= ip175c.o
 obj-$(CONFIG_REALTEK_PHY)	+= realtek.o
+obj-$(CONFIG_AR8216_PHY)	+= ar8216.o
+obj-$(CONFIG_RTL8306_PHY)	+= rtl8306.o
 obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
 obj-$(CONFIG_FIXED_PHY)		+= fixed.o
 obj-$(CONFIG_MDIO_BITBANG)	+= mdio-bitbang.o
diff -Nru linux-2.6.30.5/drivers/net/phy/ar8216.c linux-2.6.30.5-wrt/drivers/net/phy/ar8216.c
--- linux-2.6.30.5/drivers/net/phy/ar8216.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/drivers/net/phy/ar8216.c	2009-09-06 18:43:20.906698817 +0200
@@ -0,0 +1,651 @@
+/*
+ * ar8216.c: AR8216 switch driver
+ *
+ * Copyright (C) 2009 Felix Fietkau <nbd@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/if.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/if_ether.h>
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <linux/netlink.h>
+#include <linux/bitops.h>
+#include <net/genetlink.h>
+#include <linux/switch.h>
+#include <linux/delay.h>
+#include <linux/phy.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include "ar8216.h"
+
+
+struct ar8216_priv {
+	struct switch_dev dev;
+	struct phy_device *phy;
+	u32 (*read)(struct ar8216_priv *priv, int reg);
+	void (*write)(struct ar8216_priv *priv, int reg, u32 val);
+	const struct net_device_ops *ndo_old;
+	struct net_device_ops ndo;
+
+	/* all fields below are cleared on reset */
+	bool vlan;
+	u8 vlan_id[AR8216_NUM_VLANS];
+	u8 vlan_table[AR8216_NUM_VLANS];
+	u8 vlan_tagged;
+	u16 pvid[AR8216_NUM_PORTS];
+};
+static struct switch_dev athdev;
+
+#define to_ar8216(_dev) container_of(_dev, struct ar8216_priv, dev)
+
+static inline void
+split_addr(u32 regaddr, u16 *r1, u16 *r2, u16 *page)
+{
+	regaddr >>= 1;
+	*r1 = regaddr & 0x1e;
+
+	regaddr >>= 5;
+	*r2 = regaddr & 0x7;
+
+	regaddr >>= 3;
+	*page = regaddr & 0x1ff;
+}
+
+static u32
+ar8216_mii_read(struct ar8216_priv *priv, int reg)
+{
+	struct phy_device *phy = priv->phy;
+	u16 r1, r2, page;
+	u16 lo, hi;
+
+	split_addr((u32) reg, &r1, &r2, &page);
+	phy->bus->write(phy->bus, 0x18, 0, page);
+	msleep(1); /* wait for the page switch to propagate */
+	lo = phy->bus->read(phy->bus, 0x10 | r2, r1);
+	hi = phy->bus->read(phy->bus, 0x10 | r2, r1 + 1);
+
+	return (hi << 16) | lo;
+}
+
+static void
+ar8216_mii_write(struct ar8216_priv *priv, int reg, u32 val)
+{
+	struct phy_device *phy = priv->phy;
+	u16 r1, r2, r3;
+	u16 lo, hi;
+
+	split_addr((u32) reg, &r1, &r2, &r3);
+	phy->bus->write(phy->bus, 0x18, 0, r3);
+	msleep(1); /* wait for the page switch to propagate */
+
+	lo = val & 0xffff;
+	hi = (u16) (val >> 16);
+	phy->bus->write(phy->bus, 0x10 | r2, r1 + 1, hi);
+	phy->bus->write(phy->bus, 0x10 | r2, r1, lo);
+}
+
+static u32
+ar8216_rmw(struct ar8216_priv *priv, int reg, u32 mask, u32 val)
+{
+	u32 v;
+
+	v = priv->read(priv, reg);
+	v &= ~mask;
+	v |= val;
+	priv->write(priv, reg, v);
+
+	return v;
+}
+
+static int
+ar8216_set_vlan(struct switch_dev *dev, const struct switch_attr *attr,
+                struct switch_val *val)
+{
+	struct ar8216_priv *priv = to_ar8216(dev);
+	priv->vlan = !!val->value.i;
+	return 0;
+}
+
+static int
+ar8216_get_vlan(struct switch_dev *dev, const struct switch_attr *attr,
+                struct switch_val *val)
+{
+	struct ar8216_priv *priv = to_ar8216(dev);
+	val->value.i = priv->vlan;
+	return 0;
+}
+
+
+static int
+ar8216_set_pvid(struct switch_dev *dev, int port, int vlan)
+{
+	struct ar8216_priv *priv = to_ar8216(dev);
+	priv->pvid[port] = vlan;
+	return 0;
+}
+
+static int
+ar8216_get_pvid(struct switch_dev *dev, int port, int *vlan)
+{
+	struct ar8216_priv *priv = to_ar8216(dev);
+	*vlan = priv->pvid[port];
+	return 0;
+}
+
+static int
+ar8216_set_vid(struct switch_dev *dev, const struct switch_attr *attr,
+                struct switch_val *val)
+{
+	struct ar8216_priv *priv = to_ar8216(dev);
+	priv->vlan_id[val->port_vlan] = val->value.i;
+	return 0;
+}
+
+static int
+ar8216_get_vid(struct switch_dev *dev, const struct switch_attr *attr,
+                struct switch_val *val)
+{
+	struct ar8216_priv *priv = to_ar8216(dev);
+	val->value.i = priv->vlan_id[val->port_vlan];
+	return 0;
+}
+
+
+static int
+ar8216_mangle_tx(struct sk_buff *skb, struct net_device *dev)
+{
+	struct ar8216_priv *priv = dev->phy_ptr;
+	unsigned char *buf;
+
+    if (unlikely(!priv))
+        goto error;
+
+	if (!priv->vlan)
+		goto send;
+
+	if (unlikely(skb_headroom(skb) < 2)) {
+		if (pskb_expand_head(skb, 2, 0, GFP_ATOMIC) < 0)
+			goto error;
+	}
+
+	buf = skb_push(skb, 2);
+	buf[0] = 0x10;
+	buf[1] = 0x80;
+
+send:
+	return priv->ndo_old->ndo_start_xmit(skb, dev);
+
+error:
+	dev_kfree_skb_any(skb);
+	return 0;
+}
+
+static int
+ar8216_mangle_rx(struct sk_buff *skb, int napi)
+{
+	struct ar8216_priv *priv;
+	struct net_device *dev;
+	unsigned char *buf;
+	int port, vlan;
+
+	dev = skb->dev;
+	if (!dev)
+		goto error;
+
+	priv = dev->phy_ptr;
+	if (!priv)
+		goto error;
+
+	/* don't strip the header if vlan mode is disabled */
+	if (!priv->vlan)
+		goto recv;
+
+	/* strip header, get vlan id */
+	buf = skb->data;
+	skb_pull(skb, 2);
+
+	/* check for vlan header presence */
+	if ((buf[12 + 2] != 0x81) || (buf[13 + 2] != 0x00))
+		goto recv;
+
+	port = buf[0] & 0xf;
+
+	/* no need to fix up packets coming from a tagged source */
+	if (priv->vlan_tagged & (1 << port))
+		goto recv;
+
+	/* lookup port vid from local table, the switch passes an invalid vlan id */
+	vlan = priv->pvid[port];
+
+	buf[14 + 2] &= 0xf0;
+	buf[14 + 2] |= vlan >> 8;
+	buf[15 + 2] = vlan & 0xff;
+
+recv:
+	skb->protocol = eth_type_trans(skb, skb->dev);
+
+	if (napi)
+		return netif_receive_skb(skb);
+	else
+		return netif_rx(skb);
+
+error:
+	/* no vlan? eat the packet! */
+	dev_kfree_skb_any(skb);
+	return 0;
+}
+
+static int
+ar8216_netif_rx(struct sk_buff *skb)
+{
+	return ar8216_mangle_rx(skb, 0);
+}
+
+static int
+ar8216_netif_receive_skb(struct sk_buff *skb)
+{
+	return ar8216_mangle_rx(skb, 1);
+}
+
+
+static struct switch_attr ar8216_globals[] = {
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "enable_vlan",
+		.description = "Enable VLAN mode",
+		.set = ar8216_set_vlan,
+		.get = ar8216_get_vlan,
+		.max = 1
+	},
+};
+
+static struct switch_attr ar8216_port[] = {
+};
+
+static struct switch_attr ar8216_vlan[] = {
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "pvid",
+		.description = "VLAN ID",
+		.set = ar8216_set_vid,
+		.get = ar8216_get_vid,
+		.max = 4095,
+	},
+};
+
+
+static int
+ar8216_get_ports(struct switch_dev *dev, struct switch_val *val)
+{
+	struct ar8216_priv *priv = to_ar8216(dev);
+	u8 ports = priv->vlan_table[val->port_vlan];
+	int i;
+
+	val->len = 0;
+	for (i = 0; i < AR8216_NUM_PORTS; i++) {
+		struct switch_port *p;
+
+		if (!(ports & (1 << i)))
+			continue;
+
+		p = &val->value.ports[val->len++];
+		p->id = i;
+		if (priv->vlan_tagged & (1 << i))
+			p->flags = (1 << SWITCH_PORT_FLAG_TAGGED);
+		else
+			p->flags = 0;
+	}
+	return 0;
+}
+
+static int
+ar8216_set_ports(struct switch_dev *dev, struct switch_val *val)
+{
+	struct ar8216_priv *priv = to_ar8216(dev);
+	u8 *vt = &priv->vlan_table[val->port_vlan];
+	int i, j;
+
+	*vt = 0;
+	for (i = 0; i < val->len; i++) {
+		struct switch_port *p = &val->value.ports[i];
+
+		if (p->flags & (1 << SWITCH_PORT_FLAG_TAGGED))
+			priv->vlan_tagged |= (1 << p->id);
+		else {
+			priv->vlan_tagged &= ~(1 << p->id);
+			priv->pvid[p->id] = val->port_vlan;
+
+			/* make sure that an untagged port does not
+			 * appear in other vlans */
+			for (j = 0; j < AR8216_NUM_VLANS; j++) {
+				if (j == val->port_vlan)
+					continue;
+				priv->vlan_table[j] &= ~(1 << p->id);
+			}
+		}
+
+		*vt |= 1 << p->id;
+	}
+	return 0;
+}
+
+static int
+ar8216_wait_bit(struct ar8216_priv *priv, int reg, u32 mask, u32 val)
+{
+	int timeout = 20;
+
+	while ((priv->read(priv, reg) & mask) != val) {
+		if (timeout-- <= 0) {
+			printk(KERN_ERR "ar8216: timeout waiting for operation to complete\n");
+			return 1;
+		}
+	}
+	return 0;
+}
+
+static void
+ar8216_vtu_op(struct ar8216_priv *priv, u32 op, u32 val)
+{
+	if (ar8216_wait_bit(priv, AR8216_REG_VTU, AR8216_VTU_ACTIVE, 0))
+		return;
+	if ((op & AR8216_VTU_OP) == AR8216_VTU_OP_LOAD) {
+		val &= AR8216_VTUDATA_MEMBER;
+		val |= AR8216_VTUDATA_VALID;
+		priv->write(priv, AR8216_REG_VTU_DATA, val);
+	}
+	op |= AR8216_VTU_ACTIVE;
+	priv->write(priv, AR8216_REG_VTU, op);
+}
+
+static int
+ar8216_hw_apply(struct switch_dev *dev)
+{
+	struct ar8216_priv *priv = to_ar8216(dev);
+	u8 portmask[AR8216_NUM_PORTS];
+	int i, j;
+
+	/* flush all vlan translation unit entries */
+	ar8216_vtu_op(priv, AR8216_VTU_OP_FLUSH, 0);
+
+	memset(portmask, 0, sizeof(portmask));
+	if (priv->vlan) {
+		/* calculate the port destination masks and load vlans
+		 * into the vlan translation unit */
+		for (j = 0; j < AR8216_NUM_VLANS; j++) {
+			u8 vp = priv->vlan_table[j];
+
+			if (!vp)
+				continue;
+
+			for (i = 0; i < AR8216_NUM_PORTS; i++) {
+				u8 mask = (1 << i);
+				if (vp & mask)
+					portmask[i] |= vp & ~mask;
+			}
+
+			if (!priv->vlan_table[j])
+				continue;
+
+			ar8216_vtu_op(priv,
+				AR8216_VTU_OP_LOAD |
+				(priv->vlan_id[j] << AR8216_VTU_VID_S),
+				priv->vlan_table[j]);
+		}
+	} else {
+		/* vlan disabled:
+		 * isolate all ports, but connect them to the cpu port */
+		for (i = 0; i < AR8216_NUM_PORTS; i++) {
+			if (i == AR8216_PORT_CPU)
+				continue;
+
+			portmask[i] = 1 << AR8216_PORT_CPU;
+			portmask[AR8216_PORT_CPU] |= (1 << i);
+		}
+	}
+
+	/* update the port destination mask registers and tag settings */
+	for (i = 0; i < AR8216_NUM_PORTS; i++) {
+		int egress, ingress;
+		int pvid;
+
+		if (priv->vlan) {
+			pvid = priv->vlan_id[priv->pvid[i]];
+		} else {
+			pvid = i;
+		}
+
+		if (priv->vlan && (priv->vlan_tagged & (1 << i))) {
+			egress = AR8216_OUT_ADD_VLAN;
+		} else {
+			egress = AR8216_OUT_STRIP_VLAN;
+		}
+		ingress = AR8216_IN_SECURE;
+
+		ar8216_rmw(priv, AR8216_REG_PORT_CTRL(i),
+			AR8216_PORT_CTRL_LEARN | AR8216_PORT_CTRL_VLAN_MODE |
+			AR8216_PORT_CTRL_SINGLE_VLAN | AR8216_PORT_CTRL_STATE |
+			AR8216_PORT_CTRL_HEADER | AR8216_PORT_CTRL_LEARN_LOCK,
+			AR8216_PORT_CTRL_LEARN |
+			  (priv->vlan && i == AR8216_PORT_CPU ?
+			   AR8216_PORT_CTRL_HEADER : 0) |
+			  (egress << AR8216_PORT_CTRL_VLAN_MODE_S) |
+			  (AR8216_PORT_STATE_FORWARD << AR8216_PORT_CTRL_STATE_S));
+
+		ar8216_rmw(priv, AR8216_REG_PORT_VLAN(i),
+			AR8216_PORT_VLAN_DEST_PORTS | AR8216_PORT_VLAN_MODE |
+			  AR8216_PORT_VLAN_DEFAULT_ID,
+			(portmask[i] << AR8216_PORT_VLAN_DEST_PORTS_S) |
+			  (ingress << AR8216_PORT_VLAN_MODE_S) |
+			  (pvid << AR8216_PORT_VLAN_DEFAULT_ID_S));
+	}
+
+	return 0;
+}
+
+static int
+ar8216_reset_switch(struct switch_dev *dev)
+{
+	struct ar8216_priv *priv = to_ar8216(dev);
+	int i;
+
+	memset(&priv->vlan, 0, sizeof(struct ar8216_priv) -
+		offsetof(struct ar8216_priv, vlan));
+	for (i = 0; i < AR8216_NUM_VLANS; i++) {
+		priv->vlan_id[i] = i;
+	}
+	for (i = 0; i < AR8216_NUM_PORTS; i++) {
+		/* Enable port learning and tx */
+		priv->write(priv, AR8216_REG_PORT_CTRL(i),
+			AR8216_PORT_CTRL_LEARN |
+			(4 << AR8216_PORT_CTRL_STATE_S));
+
+		priv->write(priv, AR8216_REG_PORT_VLAN(i), 0);
+
+		/* Configure all PHYs */
+		if (i == AR8216_PORT_CPU) {
+			priv->write(priv, AR8216_REG_PORT_STATUS(i),
+				AR8216_PORT_STATUS_LINK_UP |
+				AR8216_PORT_STATUS_SPEED |
+				AR8216_PORT_STATUS_TXMAC |
+				AR8216_PORT_STATUS_RXMAC |
+				AR8216_PORT_STATUS_DUPLEX);
+		} else {
+			priv->write(priv, AR8216_REG_PORT_STATUS(i),
+				AR8216_PORT_STATUS_LINK_AUTO);
+		}
+	}
+	/* XXX: undocumented magic from atheros, required! */
+	priv->write(priv, 0x38, 0xc000050e);
+
+	ar8216_rmw(priv, AR8216_REG_GLOBAL_CTRL,
+		AR8216_GCTRL_MTU, 1518 + 8 + 2);
+
+	return ar8216_hw_apply(dev);
+}
+
+static int
+ar8216_config_init(struct phy_device *pdev)
+{
+	struct ar8216_priv *priv;
+	struct net_device *dev = pdev->attached_dev;
+	int ret;
+
+	printk("%s: AR8216 PHY driver attached.\n", pdev->attached_dev->name);
+	pdev->supported = ADVERTISED_100baseT_Full;
+	pdev->advertising = ADVERTISED_100baseT_Full;
+
+	priv = kzalloc(sizeof(struct ar8216_priv), GFP_KERNEL);
+	if (priv == NULL)
+		return -ENOMEM;
+
+	priv->phy = pdev;
+	priv->read = ar8216_mii_read;
+	priv->write = ar8216_mii_write;
+	memcpy(&priv->dev, &athdev, sizeof(struct switch_dev));
+	pdev->priv = priv;
+	if ((ret = register_switch(&priv->dev, pdev->attached_dev)) < 0) {
+		kfree(priv);
+		goto done;
+	}
+
+	ret = ar8216_reset_switch(&priv->dev);
+	if (ret)
+		goto done;
+
+	dev->phy_ptr = priv;
+	pdev->pkt_align = 2;
+	pdev->netif_receive_skb = ar8216_netif_receive_skb;
+	pdev->netif_rx = ar8216_netif_rx;
+
+	priv->ndo_old = dev->netdev_ops;
+	memcpy(&priv->ndo, priv->ndo_old, sizeof(struct net_device_ops));
+	priv->ndo.ndo_start_xmit = ar8216_mangle_tx;
+	dev->netdev_ops = &priv->ndo;
+
+done:
+	return ret;
+}
+
+static int
+ar8216_read_status(struct phy_device *phydev)
+{
+	struct ar8216_priv *priv = phydev->priv;
+
+	phydev->speed = SPEED_100;
+	phydev->duplex = DUPLEX_FULL;
+	phydev->state = PHY_UP;
+
+	/* flush the address translation unit */
+	if (ar8216_wait_bit(priv, AR8216_REG_ATU, AR8216_ATU_ACTIVE, 0))
+		return -ETIMEDOUT;
+
+	priv->write(priv, AR8216_REG_ATU, AR8216_ATU_OP_FLUSH);
+
+	return 0;
+}
+
+static int
+ar8216_config_aneg(struct phy_device *phydev)
+{
+	return 0;
+}
+
+static int
+ar8216_probe(struct phy_device *pdev)
+{
+	struct ar8216_priv priv;
+
+	u8 id, rev;
+	u32 val;
+
+	priv.phy = pdev;
+	val = ar8216_mii_read(&priv, AR8216_REG_CTRL);
+	rev = val & 0xff;
+	id = (val >> 8) & 0xff;
+	if ((id != 1) || (rev != 1))
+		return -ENODEV;
+
+	return 0;
+}
+
+static void
+ar8216_remove(struct phy_device *pdev)
+{
+	struct ar8216_priv *priv = pdev->priv;
+	struct net_device *dev = pdev->attached_dev;
+
+	if (!priv)
+		return;
+
+	if (priv->ndo_old && dev)
+		dev->netdev_ops = priv->ndo_old;
+	unregister_switch(&priv->dev);
+	kfree(priv);
+}
+
+/* template */
+static struct switch_dev athdev = {
+	.name = "Atheros AR8216",
+	.cpu_port = AR8216_PORT_CPU,
+	.ports = AR8216_NUM_PORTS,
+	.vlans = AR8216_NUM_VLANS,
+	.attr_global = {
+		.attr = ar8216_globals,
+		.n_attr = ARRAY_SIZE(ar8216_globals),
+	},
+	.attr_port = {
+		.attr = ar8216_port,
+		.n_attr = ARRAY_SIZE(ar8216_port),
+	},
+	.attr_vlan = {
+		.attr = ar8216_vlan,
+		.n_attr = ARRAY_SIZE(ar8216_vlan),
+	},
+	.get_port_pvid = ar8216_get_pvid,
+	.set_port_pvid = ar8216_set_pvid,
+	.get_vlan_ports = ar8216_get_ports,
+	.set_vlan_ports = ar8216_set_ports,
+	.apply_config = ar8216_hw_apply,
+	.reset_switch = ar8216_reset_switch,
+};
+
+static struct phy_driver ar8216_driver = {
+	.name		= "Atheros AR8216",
+	.features	= PHY_BASIC_FEATURES,
+	.probe		= ar8216_probe,
+	.remove		= ar8216_remove,
+	.config_init	= &ar8216_config_init,
+	.config_aneg	= &ar8216_config_aneg,
+	.read_status	= &ar8216_read_status,
+	.driver		= { .owner = THIS_MODULE },
+};
+
+int __init
+ar8216_init(void)
+{
+	return phy_driver_register(&ar8216_driver);
+}
+
+void __exit
+ar8216_exit(void)
+{
+	phy_driver_unregister(&ar8216_driver);
+}
+
+module_init(ar8216_init);
+module_exit(ar8216_exit);
+MODULE_LICENSE("GPL");
+
diff -Nru linux-2.6.30.5/drivers/net/phy/mvswitch.c linux-2.6.30.5-wrt/drivers/net/phy/mvswitch.c
--- linux-2.6.30.5/drivers/net/phy/mvswitch.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/drivers/net/phy/mvswitch.c	2009-09-06 18:43:20.906698817 +0200
@@ -0,0 +1,470 @@
+/*
+ * Marvell 88E6060 switch driver
+ * Copyright (c) 2008 Felix Fietkau <nbd@openwrt.org>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of the GNU General Public License v2 as published by the
+ * Free Software Foundation
+ */
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/unistd.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/mii.h>
+#include <linux/ethtool.h>
+#include <linux/phy.h>
+#include <linux/if_vlan.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include "mvswitch.h"
+
+/* Undefine this to use trailer mode instead.
+ * I don't know if header mode works with all chips */
+#define HEADER_MODE	1
+
+MODULE_DESCRIPTION("Marvell 88E6060 Switch driver");
+MODULE_AUTHOR("Felix Fietkau");
+MODULE_LICENSE("GPL");
+
+#define MVSWITCH_MAGIC 0x88E6060
+
+struct mvswitch_priv {
+	const struct net_device_ops *ndo_old;
+	struct net_device_ops ndo;
+	struct vlan_group *grp;
+	u8 vlans[16];
+};
+
+#define to_mvsw(_phy) ((struct mvswitch_priv *) (_phy)->priv)
+
+static inline u16
+r16(struct phy_device *phydev, int addr, int reg)
+{
+	return phydev->bus->read(phydev->bus, addr, reg);
+}
+
+static inline void
+w16(struct phy_device *phydev, int addr, int reg, u16 val)
+{
+	phydev->bus->write(phydev->bus, addr, reg, val);
+}
+
+
+static int
+mvswitch_mangle_tx(struct sk_buff *skb, struct net_device *dev)
+{
+	struct mvswitch_priv *priv;
+	char *buf = NULL;
+	u16 vid;
+
+	priv = dev->phy_ptr;
+	if (unlikely(!priv))
+		goto error;
+
+	if (unlikely(skb->len < 16))
+		goto error;
+
+#ifdef HEADER_MODE
+	if (__vlan_hwaccel_get_tag(skb, &vid))
+		goto error;
+
+	if (skb_cloned(skb) || (skb->len <= 62) || (skb_headroom(skb) < MV_HEADER_SIZE)) {
+		if (pskb_expand_head(skb, MV_HEADER_SIZE, (skb->len < 62 ? 62 - skb->len : 0), GFP_ATOMIC))
+			goto error_expand;
+		if (skb->len < 62)
+			skb->len = 62;
+	}
+	buf = skb_push(skb, MV_HEADER_SIZE);
+#else
+	if (__vlan_get_tag(skb, &vid))
+		goto error;
+
+	if (unlikely((vid > 15 || !priv->vlans[vid])))
+		goto error;
+
+	if (skb->len <= 64) {
+		if (pskb_expand_head(skb, 0, 64 + MV_TRAILER_SIZE - skb->len, GFP_ATOMIC))
+			goto error_expand;
+
+		buf = skb->data + 64;
+		skb->len = 64 + MV_TRAILER_SIZE;
+	} else {
+		if (skb_cloned(skb) || unlikely(skb_tailroom(skb) < 4)) {
+			if (pskb_expand_head(skb, 0, 4, GFP_ATOMIC))
+				goto error_expand;
+		}
+		buf = skb_put(skb, 4);
+	}
+
+	/* move the ethernet header 4 bytes forward, overwriting the vlan tag */
+	memmove(skb->data + 4, skb->data, 12);
+	skb->data += 4;
+	skb->len -= 4;
+	skb->mac_header += 4;
+#endif
+
+	if (!buf)
+		goto error;
+
+
+#ifdef HEADER_MODE
+	/* prepend the tag */
+	*((__be16 *) buf) = cpu_to_be16(
+		((vid << MV_HEADER_VLAN_S) & MV_HEADER_VLAN_M) |
+		((priv->vlans[vid] << MV_HEADER_PORTS_S) & MV_HEADER_PORTS_M)
+	);
+#else
+	/* append the tag */
+	*((__be32 *) buf) = cpu_to_be32((
+		(MV_TRAILER_OVERRIDE << MV_TRAILER_FLAGS_S) |
+		((priv->vlans[vid] & MV_TRAILER_PORTS_M) << MV_TRAILER_PORTS_S)
+	));
+#endif
+
+	return priv->ndo_old->ndo_start_xmit(skb, dev);
+
+error_expand:
+	if (net_ratelimit())
+		printk("%s: failed to expand/update skb for the switch\n", dev->name);
+
+error:
+	/* any errors? drop the packet! */
+	dev_kfree_skb_any(skb);
+	return 0;
+}
+
+static int
+mvswitch_mangle_rx(struct sk_buff *skb, int napi)
+{
+	struct mvswitch_priv *priv;
+	struct net_device *dev;
+	int vlan = -1;
+	unsigned char *buf;
+	int i;
+
+	dev = skb->dev;
+	if (!dev)
+		goto error;
+
+	priv = dev->phy_ptr;
+	if (!priv)
+		goto error;
+
+	if (!priv->grp)
+		goto error;
+
+#ifdef HEADER_MODE
+	buf = skb->data;
+	skb_pull(skb, MV_HEADER_SIZE);
+#else
+	buf = skb->data + skb->len - MV_TRAILER_SIZE;
+	if (buf[0] != 0x80)
+		goto error;
+#endif
+
+	/* look for the vlan matching the incoming port */
+	for (i = 0; i < ARRAY_SIZE(priv->vlans); i++) {
+		if ((1 << buf[1]) & priv->vlans[i])
+			vlan = i;
+	}
+
+	if (vlan == -1)
+		goto error;
+
+	skb->protocol = eth_type_trans(skb, skb->dev);
+
+	if (napi)
+		return vlan_hwaccel_receive_skb(skb, priv->grp, vlan);
+	else
+		return vlan_hwaccel_rx(skb, priv->grp, vlan);
+
+error:
+	/* no vlan? eat the packet! */
+	dev_kfree_skb_any(skb);
+	return 0;
+}
+
+
+static int
+mvswitch_netif_rx(struct sk_buff *skb)
+{
+	return mvswitch_mangle_rx(skb, 0);
+}
+
+static int
+mvswitch_netif_receive_skb(struct sk_buff *skb)
+{
+	return mvswitch_mangle_rx(skb, 1);
+}
+
+
+static void
+mvswitch_vlan_rx_register(struct net_device *dev, struct vlan_group *grp)
+{
+	struct mvswitch_priv *priv = dev->phy_ptr;
+	priv->grp = grp;
+}
+
+
+static int
+mvswitch_wait_mask(struct phy_device *pdev, int addr, int reg, u16 mask, u16 val)
+{
+	int i = 100;
+	u16 r;
+
+	do {
+		r = r16(pdev, addr, reg) & mask;
+		if (r == val)
+			return 0;
+	} while(--i > 0);
+	return -ETIMEDOUT;
+}
+
+static int
+mvswitch_config_init(struct phy_device *pdev)
+{
+	struct mvswitch_priv *priv = to_mvsw(pdev);
+	struct net_device *dev = pdev->attached_dev;
+	u8 vlmap = 0;
+	int i;
+
+	if (!dev)
+		return -EINVAL;
+
+	printk("%s: Marvell 88E6060 PHY driver attached.\n", dev->name);
+	pdev->supported = ADVERTISED_100baseT_Full;
+	pdev->advertising = ADVERTISED_100baseT_Full;
+	dev->phy_ptr = priv;
+	dev->irq = PHY_POLL;
+#ifdef HEADER_MODE
+	dev->flags |= IFF_PROMISC;
+#endif
+
+	/* initialize default vlans */
+	for (i = 0; i < MV_PORTS; i++)
+		priv->vlans[(i == MV_WANPORT ? 2 : 1)] |= (1 << i);
+
+	/* before entering reset, disable all ports */
+	for (i = 0; i < MV_PORTS; i++)
+		w16(pdev, MV_PORTREG(CONTROL, i), 0x00);
+
+	msleep(2); /* wait for the status change to settle in */
+
+	/* put the ATU in reset */
+	w16(pdev, MV_SWITCHREG(ATU_CTRL), MV_ATUCTL_RESET);
+
+	i = mvswitch_wait_mask(pdev, MV_SWITCHREG(ATU_CTRL), MV_ATUCTL_RESET, 0);
+	if (i < 0) {
+		printk("%s: Timeout waiting for the switch to reset.\n", dev->name);
+		return i;
+	}
+
+	/* set the ATU flags */
+	w16(pdev, MV_SWITCHREG(ATU_CTRL),
+		MV_ATUCTL_NO_LEARN |
+		MV_ATUCTL_ATU_1K |
+		MV_ATUCTL_AGETIME(MV_ATUCTL_AGETIME_MIN) /* minimum without disabling ageing */
+	);
+
+	/* initialize the cpu port */
+	w16(pdev, MV_PORTREG(CONTROL, MV_CPUPORT),
+#ifdef HEADER_MODE
+		MV_PORTCTRL_HEADER |
+#else
+		MV_PORTCTRL_RXTR |
+		MV_PORTCTRL_TXTR |
+#endif
+		MV_PORTCTRL_ENABLED
+	);
+	/* wait for the phy change to settle in */
+	msleep(2);
+	for (i = 0; i < MV_PORTS; i++) {
+		u8 pvid = 0;
+		int j;
+
+		vlmap = 0;
+
+		/* look for the matching vlan */
+		for (j = 0; j < ARRAY_SIZE(priv->vlans); j++) {
+			if (priv->vlans[j] & (1 << i)) {
+				vlmap = priv->vlans[j];
+				pvid = j;
+			}
+		}
+		/* leave port unconfigured if it's not part of a vlan */
+		if (!vlmap)
+			continue;
+
+		/* add the cpu port to the allowed destinations list */
+		vlmap |= (1 << MV_CPUPORT);
+
+		/* take port out of its own vlan destination map */
+		vlmap &= ~(1 << i);
+
+		/* apply vlan settings */
+		w16(pdev, MV_PORTREG(VLANMAP, i),
+			MV_PORTVLAN_PORTS(vlmap) |
+			MV_PORTVLAN_ID(i)
+		);
+
+		/* re-enable port */
+		w16(pdev, MV_PORTREG(CONTROL, i),
+			MV_PORTCTRL_ENABLED
+		);
+	}
+
+	w16(pdev, MV_PORTREG(VLANMAP, MV_CPUPORT),
+		MV_PORTVLAN_ID(MV_CPUPORT)
+	);
+
+	/* set the port association vector */
+	for (i = 0; i <= MV_PORTS; i++) {
+		w16(pdev, MV_PORTREG(ASSOC, i),
+			MV_PORTASSOC_PORTS(1 << i)
+		);
+	}
+
+	/* init switch control */
+	w16(pdev, MV_SWITCHREG(CTRL),
+		MV_SWITCHCTL_MSIZE |
+		MV_SWITCHCTL_DROP
+	);
+
+	/* hook into the tx function */
+	priv->ndo_old = dev->netdev_ops;
+	memcpy(&priv->ndo, priv->ndo_old, sizeof(struct net_device_ops));
+	priv->ndo.ndo_start_xmit = mvswitch_mangle_tx;
+	priv->ndo.ndo_vlan_rx_register = mvswitch_vlan_rx_register;
+	dev->netdev_ops = &priv->ndo;
+
+	pdev->pkt_align = 2;
+	pdev->netif_receive_skb = mvswitch_netif_receive_skb;
+	pdev->netif_rx = mvswitch_netif_rx;
+#ifdef HEADER_MODE
+	dev->features |= NETIF_F_HW_VLAN_RX | NETIF_F_HW_VLAN_TX;
+#else
+	dev->features |= NETIF_F_HW_VLAN_RX;
+#endif
+
+	return 0;
+}
+
+static int
+mvswitch_read_status(struct phy_device *pdev)
+{
+	pdev->speed = SPEED_100;
+	pdev->duplex = DUPLEX_FULL;
+	pdev->state = PHY_UP;
+
+	/* XXX ugly workaround: we can't force the switch
+	 * to gracefully handle hosts moving from one port to another,
+	 * so we have to regularly clear the ATU database */
+
+	/* wait for the ATU to become available */
+	mvswitch_wait_mask(pdev, MV_SWITCHREG(ATU_OP), MV_ATUOP_INPROGRESS, 0);
+
+	/* flush the ATU */
+	w16(pdev, MV_SWITCHREG(ATU_OP),
+		MV_ATUOP_INPROGRESS |
+		MV_ATUOP_FLUSH_ALL
+	);
+
+	/* wait for operation to complete */
+	mvswitch_wait_mask(pdev, MV_SWITCHREG(ATU_OP), MV_ATUOP_INPROGRESS, 0);
+
+	return 0;
+}
+
+static int
+mvswitch_config_aneg(struct phy_device *phydev)
+{
+	return 0;
+}
+
+static void
+mvswitch_remove(struct phy_device *pdev)
+{
+	struct mvswitch_priv *priv = to_mvsw(pdev);
+	struct net_device *dev = pdev->attached_dev;
+
+	/* restore old netdev ops */
+	if (priv->ndo_old && dev)
+		dev->netdev_ops = priv->ndo_old;
+	dev->vlan_rx_register = NULL;
+	dev->vlan_rx_kill_vid = NULL;
+	dev->phy_ptr = NULL;
+	dev->features &= ~NETIF_F_HW_VLAN_RX;
+	kfree(priv);
+}
+
+static int
+mvswitch_probe(struct phy_device *pdev)
+{
+	struct mvswitch_priv *priv;
+
+	priv = kzalloc(sizeof(struct mvswitch_priv), GFP_KERNEL);
+	if (priv == NULL)
+		return -ENOMEM;
+
+	pdev->priv = priv;
+
+	return 0;
+}
+
+static int
+mvswitch_fixup(struct phy_device *dev)
+{
+	u16 reg;
+
+	if (dev->addr != 0x10)
+		return 0;
+
+	reg = dev->bus->read(dev->bus, MV_PORTREG(IDENT, 0)) & MV_IDENT_MASK;
+	if (reg != MV_IDENT_VALUE)
+		return 0;
+
+	dev->phy_id = MVSWITCH_MAGIC;
+	return 0;
+}
+
+
+static struct phy_driver mvswitch_driver = {
+	.name		= "Marvell 88E6060",
+	.phy_id		= MVSWITCH_MAGIC,
+	.phy_id_mask	= 0xffffffff,
+	.features	= PHY_BASIC_FEATURES,
+	.probe		= &mvswitch_probe,
+	.remove		= &mvswitch_remove,
+	.config_init	= &mvswitch_config_init,
+	.config_aneg	= &mvswitch_config_aneg,
+	.read_status	= &mvswitch_read_status,
+	.driver		= { .owner = THIS_MODULE,},
+};
+
+static int __init
+mvswitch_init(void)
+{
+	phy_register_fixup_for_id(PHY_ANY_ID, mvswitch_fixup);
+	return phy_driver_register(&mvswitch_driver);
+}
+
+static void __exit
+mvswitch_exit(void)
+{
+	phy_driver_unregister(&mvswitch_driver);
+}
+
+module_init(mvswitch_init);
+module_exit(mvswitch_exit);
diff -Nru linux-2.6.30.5/drivers/net/phy/phy.c linux-2.6.30.5-wrt/drivers/net/phy/phy.c
--- linux-2.6.30.5/drivers/net/phy/phy.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/net/phy/phy.c	2009-09-06 18:44:06.775166732 +0200
@@ -299,6 +299,50 @@
 }
 EXPORT_SYMBOL(phy_ethtool_gset);
 
+int phy_ethtool_ioctl(struct phy_device *phydev, void *useraddr)
+{
+	u32 cmd;
+	int tmp;
+	struct ethtool_cmd ecmd = { ETHTOOL_GSET };
+	struct ethtool_value edata = { ETHTOOL_GLINK };
+
+	if (get_user(cmd, (u32 *) useraddr))
+		return -EFAULT;
+
+	switch (cmd) {
+	case ETHTOOL_GSET:
+		phy_ethtool_gset(phydev, &ecmd);
+		if (copy_to_user(useraddr, &ecmd, sizeof(ecmd)))
+			return -EFAULT;
+		return 0;
+
+	case ETHTOOL_SSET:
+		if (copy_from_user(&ecmd, useraddr, sizeof(ecmd)))
+			return -EFAULT;
+		return phy_ethtool_sset(phydev, &ecmd);
+
+	case ETHTOOL_NWAY_RST:
+		/* if autoneg is off, it's an error */
+		tmp = phy_read(phydev, MII_BMCR);
+		if (tmp & BMCR_ANENABLE) {
+			tmp |= (BMCR_ANRESTART);
+			phy_write(phydev, MII_BMCR, tmp);
+			return 0;
+		}
+		return -EINVAL;
+
+	case ETHTOOL_GLINK:
+		edata.data = (phy_read(phydev,
+				MII_BMSR) & BMSR_LSTATUS) ? 1 : 0;
+		if (copy_to_user(useraddr, &edata, sizeof(edata)))
+			return -EFAULT;
+		return 0;
+	}
+
+	return -EOPNOTSUPP;
+}
+EXPORT_SYMBOL(phy_ethtool_ioctl);
+
 /**
  * phy_mii_ioctl - generic PHY MII ioctl interface
  * @phydev: the phy_device struct
@@ -355,8 +399,8 @@
 		}
 
 		phy_write(phydev, mii_data->reg_num, val);
-		
-		if (mii_data->reg_num == MII_BMCR 
+
+		if (mii_data->reg_num == MII_BMCR
 				&& val & BMCR_RESET
 				&& phydev->drv->config_init) {
 			phy_scan_fixups(phydev);
@@ -471,7 +515,7 @@
 	int idx;
 
 	idx = phy_find_setting(phydev->speed, phydev->duplex);
-	
+
 	idx++;
 
 	idx = phy_find_valid(idx, phydev->supported);
diff -Nru linux-2.6.30.5/drivers/net/phy/phy_device.c linux-2.6.30.5-wrt/drivers/net/phy/phy_device.c
--- linux-2.6.30.5/drivers/net/phy/phy_device.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/net/phy/phy_device.c	2009-09-06 18:44:06.779167612 +0200
@@ -143,6 +143,18 @@
 }
 EXPORT_SYMBOL(phy_scan_fixups);
 
+static int generic_receive_skb(struct sk_buff *skb)
+{
+	skb->protocol = eth_type_trans(skb, skb->dev);
+	return netif_receive_skb(skb);
+}
+
+static int generic_rx(struct sk_buff *skb)
+{
+	skb->protocol = eth_type_trans(skb, skb->dev);
+	return netif_rx(skb);
+}
+
 struct phy_device* phy_device_create(struct mii_bus *bus, int addr, int phy_id)
 {
 	struct phy_device *dev;
@@ -168,6 +180,8 @@
 	dev->bus = bus;
 
 	dev->state = PHY_DOWN;
+	dev->netif_receive_skb = &generic_receive_skb;
+	dev->netif_rx = &generic_rx;
 
 	mutex_init(&dev->lock);
 
diff -Nru linux-2.6.30.5/drivers/net/pppoe.c linux-2.6.30.5-wrt/drivers/net/pppoe.c
--- linux-2.6.30.5/drivers/net/pppoe.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/net/pppoe.c	2009-09-06 18:43:48.442687784 +0200
@@ -863,7 +863,7 @@
 		goto end;
 
 
-	skb = sock_wmalloc(sk, total_len + dev->hard_header_len + 32,
+	skb = sock_wmalloc(sk, total_len + dev->hard_header_len + 32 + NET_SKB_PAD,
 			   0, GFP_KERNEL);
 	if (!skb) {
 		error = -ENOMEM;
@@ -871,7 +871,7 @@
 	}
 
 	/* Reserve space for headers. */
-	skb_reserve(skb, dev->hard_header_len);
+	skb_reserve(skb, dev->hard_header_len + NET_SKB_PAD);
 	skb_reset_network_header(skb);
 
 	skb->dev = dev;
diff -Nru linux-2.6.30.5/drivers/net/tg3.c linux-2.6.30.5-wrt/drivers/net/tg3.c
--- linux-2.6.30.5/drivers/net/tg3.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/net/tg3.c	2009-09-06 18:48:23.506688463 +0200
@@ -41,6 +41,7 @@
 #include <linux/prefetch.h>
 #include <linux/dma-mapping.h>
 #include <linux/firmware.h>
+#include <linux/ssb/ssb_driver_gige.h>
 
 #include <net/checksum.h>
 #include <net/ip.h>
@@ -446,8 +447,9 @@
 static inline void tw32_mailbox_flush(struct tg3 *tp, u32 off, u32 val)
 {
 	tp->write32_mbox(tp, off, val);
-	if (!(tp->tg3_flags & TG3_FLAG_MBOX_WRITE_REORDER) &&
-	    !(tp->tg3_flags2 & TG3_FLG2_ICH_WORKAROUND))
+	if ((tp->tg3_flags3 & TG3_FLG3_FLUSH_POSTED_WRITES) ||
+	    (!(tp->tg3_flags & TG3_FLAG_MBOX_WRITE_REORDER) &&
+	     !(tp->tg3_flags2 & TG3_FLG2_ICH_WORKAROUND)))
 		tp->read32_mbox(tp, off);
 }
 
@@ -457,7 +459,7 @@
 	writel(val, mbox);
 	if (tp->tg3_flags & TG3_FLAG_TXD_MBOX_HWBUG)
 		writel(val, mbox);
-	if (tp->tg3_flags & TG3_FLAG_MBOX_WRITE_REORDER)
+	if ((tp->tg3_flags & TG3_FLAG_MBOX_WRITE_REORDER) || (tp->tg3_flags3 & TG3_FLG3_FLUSH_POSTED_WRITES))
 		readl(mbox);
 }
 
@@ -729,7 +731,7 @@
 
 #define PHY_BUSY_LOOPS	5000
 
-static int tg3_readphy(struct tg3 *tp, int reg, u32 *val)
+static int __tg3_readphy(struct tg3 *tp, unsigned int phy_addr, int reg, u32 *val)
 {
 	u32 frame_val;
 	unsigned int loops;
@@ -743,7 +745,7 @@
 
 	*val = 0x0;
 
-	frame_val  = ((PHY_ADDR << MI_COM_PHY_ADDR_SHIFT) &
+	frame_val  = ((phy_addr << MI_COM_PHY_ADDR_SHIFT) &
 		      MI_COM_PHY_ADDR_MASK);
 	frame_val |= ((reg << MI_COM_REG_ADDR_SHIFT) &
 		      MI_COM_REG_ADDR_MASK);
@@ -778,7 +780,12 @@
 	return ret;
 }
 
-static int tg3_writephy(struct tg3 *tp, int reg, u32 val)
+static int tg3_readphy(struct tg3 *tp, int reg, u32 *val)
+{
+	return __tg3_readphy(tp, PHY_ADDR, reg, val);
+}
+
+static int __tg3_writephy(struct tg3 *tp, unsigned int phy_addr, int reg, u32 val)
 {
 	u32 frame_val;
 	unsigned int loops;
@@ -794,7 +801,7 @@
 		udelay(80);
 	}
 
-	frame_val  = ((PHY_ADDR << MI_COM_PHY_ADDR_SHIFT) &
+	frame_val  = ((phy_addr << MI_COM_PHY_ADDR_SHIFT) &
 		      MI_COM_PHY_ADDR_MASK);
 	frame_val |= ((reg << MI_COM_REG_ADDR_SHIFT) &
 		      MI_COM_REG_ADDR_MASK);
@@ -827,6 +834,11 @@
 	return ret;
 }
 
+static int tg3_writephy(struct tg3 *tp, int reg, u32 val)
+{
+	return __tg3_writephy(tp, PHY_ADDR, reg, val);
+}
+
 static int tg3_bmcr_reset(struct tg3 *tp)
 {
 	u32 phy_control;
@@ -2262,6 +2274,9 @@
 {
 	int ret;
 
+	if (tp->tg3_flags3 & TG3_FLG3_IS_SSB_CORE)
+		return -ENODEV;
+
 	if (!(tp->tg3_flags & TG3_FLAG_NVRAM))
 		return tg3_nvram_read_using_eeprom(tp, offset, val);
 
@@ -2595,8 +2610,10 @@
 	tg3_frob_aux_power(tp);
 
 	/* Workaround for unstable PLL clock */
-	if ((GET_CHIP_REV(tp->pci_chip_rev_id) == CHIPREV_5750_AX) ||
-	    (GET_CHIP_REV(tp->pci_chip_rev_id) == CHIPREV_5750_BX)) {
+	if ((tp->phy_id & PHY_ID_MASK != PHY_ID_BCM5750_2) &&
+				/* !!! FIXME !!! */
+	    ((GET_CHIP_REV(tp->pci_chip_rev_id) == CHIPREV_5750_AX) ||
+	    (GET_CHIP_REV(tp->pci_chip_rev_id) == CHIPREV_5750_BX))) {
 		u32 val = tr32(0x7d00);
 
 		val &= ~((1 << 16) | (1 << 4) | (1 << 2) | (1 << 1) | 1);
@@ -3088,6 +3105,14 @@
 
 		tg3_phy_copper_begin(tp);
 
+		if (tp->tg3_flags3 & TG3_FLG3_ROBOSWITCH) {
+			current_link_up = 1;
+			current_speed = SPEED_1000; //FIXME
+			current_duplex = DUPLEX_FULL;
+			tp->link_config.active_speed = current_speed;
+			tp->link_config.active_duplex = current_duplex;
+		}
+
 		tg3_readphy(tp, MII_BMSR, &tmp);
 		if (!tg3_readphy(tp, MII_BMSR, &tmp) &&
 		    (tmp & BMSR_LSTATUS))
@@ -6000,6 +6025,11 @@
 	int i;
 	u32 val;
 
+	if (tp->tg3_flags3 & TG3_FLG3_IS_SSB_CORE) {
+		/* We don't use firmware. */
+		return 0;
+	}
+
 	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5906) {
 		/* Wait up to 20ms for init done. */
 		for (i = 0; i < 200; i++) {
@@ -6256,6 +6286,14 @@
 		tw32(0x5000, 0x400);
 	}
 
+	if (tp->tg3_flags3 & TG3_FLG3_IS_SSB_CORE) {
+		/* BCM4785: In order to avoid repercussions from using potentially
+		 * defective internal ROM, stop the Rx RISC CPU, which is not
+		 * required. */
+		tg3_stop_fw(tp);
+		tg3_halt_cpu(tp, RX_CPU_BASE);
+	}
+
 	tw32(GRC_MODE, tp->grc_mode);
 
 	if (tp->pci_chip_rev_id == CHIPREV_ID_5705_A0) {
@@ -6406,9 +6444,12 @@
 		return -ENODEV;
 	}
 
-	/* Clear firmware's nvram arbitration. */
-	if (tp->tg3_flags & TG3_FLAG_NVRAM)
-		tw32(NVRAM_SWARB, SWARB_REQ_CLR0);
+	if (!(tp->tg3_flags3 & TG3_FLG3_IS_SSB_CORE)) {
+		/* Clear firmware's nvram arbitration. */
+		if (tp->tg3_flags & TG3_FLAG_NVRAM)
+			tw32(NVRAM_SWARB, SWARB_REQ_CLR0);
+	}
+
 	return 0;
 }
 
@@ -6471,6 +6512,11 @@
 	const __be32 *fw_data;
 	int err, i;
 
+	if (tp->tg3_flags3 & TG3_FLG3_IS_SSB_CORE) {
+		/* We don't use firmware. */
+		return 0;
+	}
+
 	fw_data = (void *)tp->fw->data;
 
 	/* Firmware blob starts with version numbers, followed by
@@ -6530,6 +6576,11 @@
 	unsigned long cpu_base, cpu_scratch_base, cpu_scratch_size;
 	int err, i;
 
+	if (tp->tg3_flags3 & TG3_FLG3_IS_SSB_CORE) {
+		/* We don't use firmware. */
+		return 0;
+	}
+
 	if (tp->tg3_flags2 & TG3_FLG2_HW_TSO)
 		return 0;
 
@@ -7435,6 +7486,11 @@
 
 	spin_lock(&tp->lock);
 
+	if (tp->tg3_flags3 & TG3_FLG3_FLUSH_POSTED_WRITES) {
+		/* BCM4785: Flush posted writes from GbE to host memory. */
+		tr32(HOSTCC_MODE);
+	}
+
 	if (!(tp->tg3_flags & TG3_FLAG_TAGGED_STATUS)) {
 		/* All of this garbage is because when using non-tagged
 		 * IRQ status the mailbox/status_block protocol the chip
@@ -9201,6 +9257,11 @@
 	__be32 *buf;
 	int i, j, k, err = 0, size;
 
+	if (tp->tg3_flags3 & TG3_FLG3_IS_SSB_CORE) {
+		/* We don't have NVRAM. */
+		return 0;
+	}
+
 	if (tg3_nvram_read(tp, 0, &magic) != 0)
 		return -EIO;
 
@@ -9994,7 +10055,7 @@
 			return -EAGAIN;
 
 		spin_lock_bh(&tp->lock);
-		err = tg3_readphy(tp, data->reg_num & 0x1f, &mii_regval);
+		err = __tg3_readphy(tp, data->phy_id & 0x1f, data->reg_num & 0x1f, &mii_regval);
 		spin_unlock_bh(&tp->lock);
 
 		data->val_out = mii_regval;
@@ -10013,7 +10074,7 @@
 			return -EAGAIN;
 
 		spin_lock_bh(&tp->lock);
-		err = tg3_writephy(tp, data->reg_num & 0x1f, data->val_in);
+		err = __tg3_writephy(tp, data->phy_id & 0x1f, data->reg_num & 0x1f, data->val_in);
 		spin_unlock_bh(&tp->lock);
 
 		return err;
@@ -10601,6 +10662,12 @@
 /* Chips other than 5700/5701 use the NVRAM for fetching info. */
 static void __devinit tg3_nvram_init(struct tg3 *tp)
 {
+	if (tp->tg3_flags3 & TG3_FLG3_IS_SSB_CORE) {
+		/* No NVRAM and EEPROM on the SSB Broadcom GigE core. */
+		tp->tg3_flags &= ~(TG3_FLAG_NVRAM | TG3_FLAG_NVRAM_BUFFERED);
+		return;
+	}
+
 	tw32_f(GRC_EEPROM_ADDR,
 	     (EEPROM_ADDR_FSM_RESET |
 	      (EEPROM_DEFAULT_CLOCK_PERIOD <<
@@ -10859,6 +10926,9 @@
 {
 	int ret;
 
+	if (tp->tg3_flags3 & TG3_FLG3_IS_SSB_CORE)
+		return -ENODEV;
+
 	if (tp->tg3_flags & TG3_FLAG_EEPROM_WRITE_PROT) {
 		tw32_f(GRC_LOCAL_CTRL, tp->grc_local_ctrl &
 		       ~GRC_LCLCTRL_GPIO_OUTPUT1);
@@ -12063,7 +12133,6 @@
 		tp->write32 = tg3_write_flush_reg32;
 	}
 
-
 	if ((tp->tg3_flags & TG3_FLAG_TXD_MBOX_HWBUG) ||
 	    (tp->tg3_flags & TG3_FLAG_MBOX_WRITE_REORDER)) {
 		tp->write32_tx_mbox = tg3_write32_tx_mbox;
@@ -12099,6 +12168,11 @@
 	      GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5701)))
 		tp->tg3_flags |= TG3_FLAG_SRAM_USE_CONFIG;
 
+	if (tp->tg3_flags3 & TG3_FLG3_FLUSH_POSTED_WRITES) {
+		tp->write32_tx_mbox = tg3_write_flush_reg32;
+		tp->write32_rx_mbox = tg3_write_flush_reg32;
+	}
+
 	/* Get eeprom hw config before calling tg3_set_power_state().
 	 * In particular, the TG3_FLG2_IS_NIC flag must be
 	 * determined before calling tg3_set_power_state() so that
@@ -12474,6 +12548,10 @@
 	}
 
 	if (!is_valid_ether_addr(&dev->dev_addr[0])) {
+		if (tp->tg3_flags3 & TG3_FLG3_IS_SSB_CORE)
+			ssb_gige_get_macaddr(tp->pdev, &dev->dev_addr[0]);
+	}
+	if (!is_valid_ether_addr(&dev->dev_addr[0])) {
 #ifdef CONFIG_SPARC
 		if (!tg3_get_default_macaddr_sparc(tp))
 			return 0;
@@ -12965,6 +13043,7 @@
 	case PHY_ID_BCM5704:	return "5704";
 	case PHY_ID_BCM5705:	return "5705";
 	case PHY_ID_BCM5750:	return "5750";
+	case PHY_ID_BCM5750_2:	return "5750-2";
 	case PHY_ID_BCM5752:	return "5752";
 	case PHY_ID_BCM5714:	return "5714";
 	case PHY_ID_BCM5780:	return "5780";
@@ -13175,6 +13254,13 @@
 		tp->msg_enable = tg3_debug;
 	else
 		tp->msg_enable = TG3_DEF_MSG_ENABLE;
+	if (pdev_is_ssb_gige_core(pdev)) {
+		tp->tg3_flags3 |= TG3_FLG3_IS_SSB_CORE;
+		if (ssb_gige_must_flush_posted_writes(pdev))
+			tp->tg3_flags3 |= TG3_FLG3_FLUSH_POSTED_WRITES;
+		if (ssb_gige_have_roboswitch(pdev))
+			tp->tg3_flags3 |= TG3_FLG3_ROBOSWITCH;
+	}
 
 	/* The word/byte swap controls here control register access byte
 	 * swapping.  DMA data byte swapping is controlled in the GRC_MODE
diff -Nru linux-2.6.30.5/drivers/net/tg3.h linux-2.6.30.5-wrt/drivers/net/tg3.h
--- linux-2.6.30.5/drivers/net/tg3.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/net/tg3.h	2009-09-06 18:48:23.506688463 +0200
@@ -1849,6 +1849,9 @@
 #define  NIC_SRAM_RGMII_STD_IBND_DISABLE 0x00000004
 #define  NIC_SRAM_RGMII_EXT_IBND_RX_EN	 0x00000008
 #define  NIC_SRAM_RGMII_EXT_IBND_TX_EN	 0x00000010
+#define TG3_FLG3_IS_SSB_CORE		0x00000800
+#define TG3_FLG3_FLUSH_POSTED_WRITES	0x00001000
+#define TG3_FLG3_ROBOSWITCH		0x00002000
 
 #define NIC_SRAM_RX_MINI_BUFFER_DESC	0x00001000
 
@@ -2695,6 +2698,7 @@
 #define PHY_ID_BCM5714			0x60008340
 #define PHY_ID_BCM5780			0x60008350
 #define PHY_ID_BCM5755			0xbc050cc0
+#define PHY_ID_BCM5750_2		0xbc050cd0
 #define PHY_ID_BCM5787			0xbc050ce0
 #define PHY_ID_BCM5756			0xbc050ed0
 #define PHY_ID_BCM5784			0xbc050fa0
@@ -2739,7 +2743,7 @@
 	 (X) == PHY_ID_BCM5780 || (X) == PHY_ID_BCM5787 || \
 	 (X) == PHY_ID_BCM5755 || (X) == PHY_ID_BCM5756 || \
 	 (X) == PHY_ID_BCM5906 || (X) == PHY_ID_BCM5761 || \
-	 (X) == PHY_ID_BCM8002)
+	 (X) == PHY_ID_BCM8002 || (X) == PHY_ID_BCM5750_2)
 
 	struct tg3_hw_stats		*hw_stats;
 	dma_addr_t			stats_mapping;
diff -Nru linux-2.6.30.5/drivers/net/wireless/hostap/hostap.h linux-2.6.30.5-wrt/drivers/net/wireless/hostap/hostap.h
--- linux-2.6.30.5/drivers/net/wireless/hostap/hostap.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/net/wireless/hostap/hostap.h	2009-09-06 18:44:06.799166831 +0200
@@ -90,6 +90,7 @@
 extern const struct ethtool_ops prism2_ethtool_ops;
 
 int hostap_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd);
+int hostap_restore_power(struct net_device *dev);
 
 
 #endif /* HOSTAP_H */
diff -Nru linux-2.6.30.5/drivers/net/wireless/hostap/hostap_ap.c linux-2.6.30.5-wrt/drivers/net/wireless/hostap/hostap_ap.c
--- linux-2.6.30.5/drivers/net/wireless/hostap/hostap_ap.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/net/wireless/hostap/hostap_ap.c	2009-09-06 18:44:06.799166831 +0200
@@ -2335,13 +2335,13 @@
 		addr[count].sa_family = ARPHRD_ETHER;
 		memcpy(addr[count].sa_data, sta->addr, ETH_ALEN);
 		if (sta->last_rx_silence == 0)
-			qual[count].qual = sta->last_rx_signal < 27 ?
-				0 : (sta->last_rx_signal - 27) * 92 / 127;
+                        qual[count].qual = (sta->last_rx_signal - 156) == 0 ?
+                                0 : (sta->last_rx_signal - 156) * 92 / 64;
 		else
-			qual[count].qual = sta->last_rx_signal -
-				sta->last_rx_silence - 35;
-		qual[count].level = HFA384X_LEVEL_TO_dBm(sta->last_rx_signal);
-		qual[count].noise = HFA384X_LEVEL_TO_dBm(sta->last_rx_silence);
+                        qual[count].qual = (sta->last_rx_signal -
+                                sta->last_rx_silence) * 92 / 64;
+                qual[count].level = sta->last_rx_signal;
+                qual[count].noise = sta->last_rx_silence;
 		qual[count].updated = sta->last_rx_updated;
 
 		sta->last_rx_updated = IW_QUAL_DBM;
@@ -2407,13 +2407,13 @@
 		memset(&iwe, 0, sizeof(iwe));
 		iwe.cmd = IWEVQUAL;
 		if (sta->last_rx_silence == 0)
-			iwe.u.qual.qual = sta->last_rx_signal < 27 ?
-				0 : (sta->last_rx_signal - 27) * 92 / 127;
+	                iwe.u.qual.qual = (sta->last_rx_signal -156) == 0 ?
+	                        0 : (sta->last_rx_signal - 156) * 92 / 64;
 		else
-			iwe.u.qual.qual = sta->last_rx_signal -
-				sta->last_rx_silence - 35;
-		iwe.u.qual.level = HFA384X_LEVEL_TO_dBm(sta->last_rx_signal);
-		iwe.u.qual.noise = HFA384X_LEVEL_TO_dBm(sta->last_rx_silence);
+                        iwe.u.qual.qual = (sta->last_rx_signal -
+                                sta->last_rx_silence) * 92 / 64;
+                iwe.u.qual.level = sta->last_rx_signal;
+                iwe.u.qual.noise = sta->last_rx_silence;
 		iwe.u.qual.updated = sta->last_rx_updated;
 		iwe.len = IW_EV_QUAL_LEN;
 		current_ev = iwe_stream_add_event(info, current_ev, end_buf,
diff -Nru linux-2.6.30.5/drivers/net/wireless/hostap/hostap_config.h linux-2.6.30.5-wrt/drivers/net/wireless/hostap/hostap_config.h
--- linux-2.6.30.5/drivers/net/wireless/hostap/hostap_config.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/net/wireless/hostap/hostap_config.h	2009-09-06 18:44:06.799166831 +0200
@@ -45,4 +45,9 @@
  */
 /* #define PRISM2_NO_STATION_MODES */
 
+/* Enable TX power Setting functions
+ * (min att = -128 , max att =  127)
+ */
+#define RAW_TXPOWER_SETTING
+
 #endif /* HOSTAP_CONFIG_H */
diff -Nru linux-2.6.30.5/drivers/net/wireless/hostap/hostap_hw.c linux-2.6.30.5-wrt/drivers/net/wireless/hostap/hostap_hw.c
--- linux-2.6.30.5/drivers/net/wireless/hostap/hostap_hw.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/net/wireless/hostap/hostap_hw.c	2009-09-06 18:44:06.799166831 +0200
@@ -932,6 +932,7 @@
 			prism2_hw_reset(dev);
 	}
 
+	hostap_restore_power(dev);
 	return res;
 }
 
diff -Nru linux-2.6.30.5/drivers/net/wireless/hostap/hostap_info.c linux-2.6.30.5-wrt/drivers/net/wireless/hostap/hostap_info.c
--- linux-2.6.30.5/drivers/net/wireless/hostap/hostap_info.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/net/wireless/hostap/hostap_info.c	2009-09-06 18:44:06.799166831 +0200
@@ -431,6 +431,11 @@
 	}
 
 	/* Get BSSID if we have a valid AP address */
+
+	if ( val == HFA384X_LINKSTATUS_CONNECTED ||
+	     val == HFA384X_LINKSTATUS_DISCONNECTED )
+			hostap_restore_power(local->dev);
+
 	if (connected) {
 		netif_carrier_on(local->dev);
 		netif_carrier_on(local->ddev);
diff -Nru linux-2.6.30.5/drivers/net/wireless/hostap/hostap_ioctl.c linux-2.6.30.5-wrt/drivers/net/wireless/hostap/hostap_ioctl.c
--- linux-2.6.30.5/drivers/net/wireless/hostap/hostap_ioctl.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/net/wireless/hostap/hostap_ioctl.c	2009-09-06 18:44:06.799166831 +0200
@@ -1475,23 +1475,20 @@
 		val = 255;
 
 	tmp = val;
-	tmp >>= 2;
 
-	return -12 - tmp;
+	return tmp;
 }
 
 static u16 prism2_txpower_dBm_to_hfa386x(int val)
 {
 	signed char tmp;
 
-	if (val > 20)
-		return 128;
-	else if (val < -43)
+	if (val > 127)
 		return 127;
+	else if (val < -128)
+		return 128;
 
 	tmp = val;
-	tmp = -12 - tmp;
-	tmp <<= 2;
 
 	return (unsigned char) tmp;
 }
@@ -4055,3 +4052,35 @@
 
 	return ret;
 }
+
+/* BUG FIX: Restore power setting value when lost due to F/W bug */
+
+int hostap_restore_power(struct net_device *dev)
+{
+        struct hostap_interface *iface = netdev_priv(dev);
+       local_info_t *local = iface->local;
+
+       u16 val;
+       int ret = 0;
+
+       if (local->txpower_type == PRISM2_TXPOWER_OFF) {
+                       val = 0xff; /* use all standby and sleep modes */
+                       ret = local->func->cmd(dev, HFA384X_CMDCODE_WRITEMIF,
+                                              HFA386X_CR_A_D_TEST_MODES2,
+                                              &val, NULL);
+       }
+
+#ifdef RAW_TXPOWER_SETTING
+       if (local->txpower_type == PRISM2_TXPOWER_FIXED) {
+               val = HFA384X_TEST_CFG_BIT_ALC;
+               local->func->cmd(dev, HFA384X_CMDCODE_TEST |
+                                (HFA384X_TEST_CFG_BITS << 8), 0, &val, NULL);
+               val = prism2_txpower_dBm_to_hfa386x(local->txpower);
+               ret = (local->func->cmd(dev, HFA384X_CMDCODE_WRITEMIF,
+                            HFA386X_CR_MANUAL_TX_POWER, &val, NULL));
+       }
+#endif /* RAW_TXPOWER_SETTING */
+       return (ret ? -EOPNOTSUPP : 0);
+}
+
+EXPORT_SYMBOL(hostap_restore_power);
diff -Nru linux-2.6.30.5/drivers/pci/Kconfig linux-2.6.30.5-wrt/drivers/pci/Kconfig
--- linux-2.6.30.5/drivers/pci/Kconfig	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/pci/Kconfig	2009-09-06 18:43:48.334667043 +0200
@@ -51,6 +51,12 @@
 
 	  When in doubt, say N.
 
+config PCI_DISABLE_COMMON_QUIRKS
+	bool "PCI disable common quirks"
+	depends on PCI
+	help
+	  If you don't know what to do here, say N.
+
 config HT_IRQ
 	bool "Interrupts on hypertransport devices"
 	default y
diff -Nru linux-2.6.30.5/drivers/pci/quirks.c linux-2.6.30.5-wrt/drivers/pci/quirks.c
--- linux-2.6.30.5/drivers/pci/quirks.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/pci/quirks.c	2009-09-06 18:43:48.334667043 +0200
@@ -98,6 +98,7 @@
 }
 DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, quirk_resource_alignment);
 
+#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
 /* The Mellanox Tavor device gives false positive parity errors
  * Mark this device with a broken_parity_status, to allow
  * PCI scanning code to "skip" this now blacklisted device.
@@ -1859,7 +1860,9 @@
 	}
 }
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_NCR, PCI_DEVICE_ID_NCR_53C810, fixup_rev1_53c810);
+#endif /* !CONFIG_PCI_DISABLE_COMMON_QUIRKS */
 
+#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
 /* Enable 1k I/O space granularity on the Intel P64H2 */
 static void __devinit quirk_p64h2_1k_io(struct pci_dev *dev)
 {
@@ -2463,6 +2466,7 @@
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x10e7, quirk_i82576_sriov);
 
 #endif	/* CONFIG_PCI_IOV */
+#endif /* !CONFIG_PCI_DISABLE_COMMON_QUIRKS */
 
 static void pci_do_fixups(struct pci_dev *dev, struct pci_fixup *f,
 			  struct pci_fixup *end)
diff -Nru linux-2.6.30.5/drivers/rtc/Kconfig linux-2.6.30.5-wrt/drivers/rtc/Kconfig
--- linux-2.6.30.5/drivers/rtc/Kconfig	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/rtc/Kconfig	2009-09-06 18:44:06.787166740 +0200
@@ -526,6 +526,15 @@
 	  If you say yes here you get support for the RTC subsystem of the
 	  NXP PCF50633 used in embedded systems.
 
+config RTC_DRV_RTC7301
+	tristate "Epson RTC-7301 SF/DG"
+	help
+	  If you say Y here you will get support for the
+	  Epson RTC-7301 SF/DG RTC chips.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called rtc-7301.
+
 comment "on-CPU RTC drivers"
 
 config RTC_DRV_OMAP
diff -Nru linux-2.6.30.5/drivers/rtc/Makefile linux-2.6.30.5-wrt/drivers/rtc/Makefile
--- linux-2.6.30.5/drivers/rtc/Makefile	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/rtc/Makefile	2009-09-06 18:44:06.787166740 +0200
@@ -62,6 +62,7 @@
 obj-$(CONFIG_RTC_DRV_RS5C313)	+= rtc-rs5c313.o
 obj-$(CONFIG_RTC_DRV_RS5C348)	+= rtc-rs5c348.o
 obj-$(CONFIG_RTC_DRV_RS5C372)	+= rtc-rs5c372.o
+obj-$(CONFIG_RTC_DRV_RTC7301)	+= rtc-rtc7301.o
 obj-$(CONFIG_RTC_DRV_RX8581)	+= rtc-rx8581.o
 obj-$(CONFIG_RTC_DRV_S35390A)	+= rtc-s35390a.o
 obj-$(CONFIG_RTC_DRV_S3C)	+= rtc-s3c.o
diff -Nru linux-2.6.30.5/drivers/rtc/rtc-rtc7301.c linux-2.6.30.5-wrt/drivers/rtc/rtc-rtc7301.c
--- linux-2.6.30.5/drivers/rtc/rtc-rtc7301.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/drivers/rtc/rtc-rtc7301.c	2009-09-06 18:44:06.787166740 +0200
@@ -0,0 +1,219 @@
+/*
+ * Driver for Epson RTC-7301SF/DG
+ *
+ * Copyright (C) 2009 Jose Vasconcellos
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/rtc.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/bcd.h>
+
+#define RTC_NAME "rtc7301"
+#define RTC_VERSION "0.1"
+
+/* Epson RTC-7301 register addresses */
+#define RTC7301_SEC		0x00
+#define RTC7301_SEC10		0x01
+#define RTC7301_MIN		0x02
+#define RTC7301_MIN10		0x03
+#define RTC7301_HOUR		0x04
+#define RTC7301_HOUR10		0x05
+#define RTC7301_WEEKDAY		0x06
+#define RTC7301_DAY		0x07
+#define RTC7301_DAY10		0x08
+#define RTC7301_MON		0x09
+#define RTC7301_MON10		0x0A
+#define RTC7301_YEAR		0x0B
+#define RTC7301_YEAR10		0x0C
+#define RTC7301_YEAR100		0x0D
+#define RTC7301_YEAR1000	0x0E
+#define RTC7301_CTRLREG		0x0F
+
+static uint8_t __iomem *rtc7301_base;
+
+#define read_reg(offset) (readb(rtc7301_base + offset) & 0xf)
+#define write_reg(offset, data) writeb(data, rtc7301_base + (offset))
+
+#define rtc7301_isbusy() (read_reg(RTC7301_CTRLREG) & 1)
+
+static void rtc7301_init_settings(void)
+{
+	int i;
+
+	write_reg(RTC7301_CTRLREG, 2);
+	write_reg(RTC7301_YEAR1000, 2);
+	udelay(122);
+
+	/* bank 1 */
+	write_reg(RTC7301_CTRLREG, 6);
+	for (i=0; i<15; i++)
+		write_reg(i, 0);
+
+	/* bank 2 */
+	write_reg(RTC7301_CTRLREG, 14);
+	for (i=0; i<15; i++)
+		write_reg(i, 0);
+	write_reg(RTC7301_CTRLREG, 0);
+}
+
+static int rtc7301_get_datetime(struct device *dev, struct rtc_time *dt)
+{
+	int cnt;
+	uint8_t buf[16];
+
+	cnt = 0;
+	while (rtc7301_isbusy()) {
+		udelay(244);
+		if (cnt++ > 100) {
+			dev_err(dev, "%s: timeout error %x\n", __func__, rtc7301_base[RTC7301_CTRLREG]);
+			return -EIO;
+		}
+	}
+
+	for (cnt=0; cnt<16; cnt++)
+		buf[cnt] = read_reg(cnt);
+
+	if (buf[RTC7301_SEC10] & 8) {
+		dev_err(dev, "%s: RTC not set\n", __func__);
+		return -EINVAL;
+	}
+
+	memset(dt, 0, sizeof(*dt));
+
+	dt->tm_sec =  buf[RTC7301_SEC] + buf[RTC7301_SEC10]*10;
+	dt->tm_min =  buf[RTC7301_MIN] + buf[RTC7301_MIN10]*10;
+	dt->tm_hour = buf[RTC7301_HOUR] + buf[RTC7301_HOUR10]*10;
+
+	dt->tm_mday = buf[RTC7301_DAY] + buf[RTC7301_DAY10]*10;
+	dt->tm_mon =  buf[RTC7301_MON] + buf[RTC7301_MON10]*10 - 1;
+	dt->tm_year = buf[RTC7301_YEAR] + buf[RTC7301_YEAR10]*10 +
+		      buf[RTC7301_YEAR100]*100 +
+		      ((buf[RTC7301_YEAR1000] & 3)*1000) - 1900;
+
+	/* the rtc device may contain illegal values on power up
+	 * according to the data sheet. make sure they are valid.
+	 */
+
+	return rtc_valid_tm(dt);
+}
+
+static int rtc7301_set_datetime(struct device *dev, struct rtc_time *dt)
+{
+	int data;
+
+	data = dt->tm_year + 1900;
+	if (data >= 2100 || data < 1900)
+		return -EINVAL;
+
+	write_reg(RTC7301_CTRLREG, 2);
+       	udelay(122);
+
+	data = bin2bcd(dt->tm_sec);
+	write_reg(RTC7301_SEC, data);
+	write_reg(RTC7301_SEC10, (data >> 4));
+
+	data = bin2bcd(dt->tm_min);
+	write_reg(RTC7301_MIN, data );
+	write_reg(RTC7301_MIN10, (data >> 4));
+
+	data = bin2bcd(dt->tm_hour);
+	write_reg(RTC7301_HOUR, data);
+	write_reg(RTC7301_HOUR10, (data >> 4));
+
+	data = bin2bcd(dt->tm_mday);
+	write_reg(RTC7301_DAY, data);
+	write_reg(RTC7301_DAY10, (data>> 4));
+
+	data = bin2bcd(dt->tm_mon + 1);
+	write_reg(RTC7301_MON, data);
+	write_reg(RTC7301_MON10, (data >> 4));
+
+	data = bin2bcd(dt->tm_year % 100);
+	write_reg(RTC7301_YEAR, data);
+	write_reg(RTC7301_YEAR10, (data >> 4));
+	data = bin2bcd((1900 + dt->tm_year) / 100);
+	write_reg(RTC7301_YEAR100, data);
+
+	data = bin2bcd(dt->tm_wday);
+	write_reg(RTC7301_WEEKDAY, data);
+
+	write_reg(RTC7301_CTRLREG, 0);
+
+	return 0;
+}
+
+static const struct rtc_class_ops rtc7301_rtc_ops = {
+	.read_time	= rtc7301_get_datetime,
+	.set_time	= rtc7301_set_datetime,
+};
+
+static int __devinit rtc7301_probe(struct platform_device *pdev)
+{
+	struct rtc_device *rtc;
+	struct resource *res;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENOENT;
+
+	rtc7301_base = ioremap_nocache(res->start, 0x1000 /*res->end - res->start + 1*/);
+	if (!rtc7301_base)
+		return -EINVAL;
+
+	rtc = rtc_device_register(RTC_NAME, &pdev->dev,
+				&rtc7301_rtc_ops, THIS_MODULE);
+	if (IS_ERR(rtc)) {
+		iounmap(rtc7301_base);
+		return PTR_ERR(rtc);
+	}
+
+	platform_set_drvdata(pdev, rtc);
+
+	rtc7301_init_settings();
+	return 0;
+}
+
+static int __devexit rtc7301_remove(struct platform_device *pdev)
+{
+	struct rtc_device *rtc = platform_get_drvdata(pdev);
+
+	if (rtc)
+		rtc_device_unregister(rtc);
+	if (rtc7301_base)
+		iounmap(rtc7301_base);
+	return 0;
+}
+
+static struct platform_driver rtc7301_driver = {
+	.driver = {
+		.name	= RTC_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe	= rtc7301_probe,
+	.remove = __devexit_p(rtc7301_remove),
+};
+
+static __init int rtc7301_init(void)
+{
+	return platform_driver_register(&rtc7301_driver);
+}
+module_init(rtc7301_init);
+
+static __exit void rtc7301_exit(void)
+{
+	platform_driver_unregister(&rtc7301_driver);
+}
+module_exit(rtc7301_exit);
+
+MODULE_DESCRIPTION("Epson 7301 RTC driver");
+MODULE_AUTHOR("Jose Vasconcellos <jvasco@verizon.net>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" RTC_NAME);
+MODULE_VERSION(RTC_VERSION);
diff -Nru linux-2.6.30.5/drivers/spi/Kconfig linux-2.6.30.5-wrt/drivers/spi/Kconfig
--- linux-2.6.30.5/drivers/spi/Kconfig	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/spi/Kconfig	2009-09-06 18:44:06.807166783 +0200
@@ -116,6 +116,15 @@
 	  GPIO operations, you should be able to leverage that for better
 	  speed with a custom version of this driver; see the source code.
 
+config SPI_GPIO_OLD
+	tristate "Old GPIO API based bitbanging SPI controller (DEPRECATED)"
+	depends on SPI_MASTER && GENERIC_GPIO
+	select SPI_BITBANG
+	help
+	  This code is deprecated. Please use the new mainline SPI-GPIO driver.
+
+	  If unsure, say N.
+
 config SPI_IMX
 	tristate "Freescale iMX SPI controller"
 	depends on ARCH_IMX && EXPERIMENTAL
diff -Nru linux-2.6.30.5/drivers/spi/Makefile linux-2.6.30.5-wrt/drivers/spi/Makefile
--- linux-2.6.30.5/drivers/spi/Makefile	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/spi/Makefile	2009-09-06 18:44:06.807166783 +0200
@@ -17,6 +17,7 @@
 obj-$(CONFIG_SPI_AU1550)		+= au1550_spi.o
 obj-$(CONFIG_SPI_BUTTERFLY)		+= spi_butterfly.o
 obj-$(CONFIG_SPI_GPIO)			+= spi_gpio.o
+obj-$(CONFIG_SPI_GPIO_OLD)		+= spi_gpio_old.o
 obj-$(CONFIG_SPI_IMX)			+= spi_imx.o
 obj-$(CONFIG_SPI_LM70_LLP)		+= spi_lm70llp.o
 obj-$(CONFIG_SPI_PXA2XX)		+= pxa2xx_spi.o
diff -Nru linux-2.6.30.5/drivers/spi/spi_gpio.c linux-2.6.30.5-wrt/drivers/spi/spi_gpio.c
--- linux-2.6.30.5/drivers/spi/spi_gpio.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/spi/spi_gpio.c	2009-09-06 18:44:06.803167207 +0200
@@ -21,6 +21,7 @@
 #include <linux/init.h>
 #include <linux/platform_device.h>
 #include <linux/gpio.h>
+#include <linux/delay.h>
 
 #include <linux/spi/spi.h>
 #include <linux/spi/spi_bitbang.h>
@@ -69,6 +70,7 @@
  *		#define	SPI_MOSI_GPIO	120
  *		#define	SPI_SCK_GPIO	121
  *		#define	SPI_N_CHIPSEL	4
+ *		#undef NEED_SPIDELAY
  *		#include "spi_gpio.c"
  */
 
@@ -76,6 +78,7 @@
 #define DRIVER_NAME	"spi_gpio"
 
 #define GENERIC_BITBANG	/* vs tight inlines */
+#define NEED_SPIDELAY	1
 
 /* all functions referencing these symbols must define pdata */
 #define SPI_MISO_GPIO	((pdata)->miso)
@@ -120,12 +123,20 @@
 #undef pdata
 
 /*
- * NOTE:  this clocks "as fast as we can".  It "should" be a function of the
- * requested device clock.  Software overhead means we usually have trouble
- * reaching even one Mbit/sec (except when we can inline bitops), so for now
- * we'll just assume we never need additional per-bit slowdowns.
+ * NOTE:  to clock "as fast as we can", set spi_device.max_speed_hz
+ * and spi_transfer.speed_hz to 0.
+ * Otherwise this is a function of the requested device clock.
+ * Software overhead means we usually have trouble
+ * reaching even one Mbit/sec (except when we can inline bitops). So on small
+ * embedded devices with fast SPI slaves you usually don't need a delay.
  */
-#define spidelay(nsecs)	do {} while (0)
+static inline void spidelay(unsigned nsecs)
+{
+#ifdef NEED_SPIDELAY
+	if (unlikely(nsecs))
+		ndelay(nsecs);
+#endif /* NEED_SPIDELAY */
+}
 
 #define	EXPAND_BITBANG_TXRX
 #include <linux/spi/spi_bitbang.h>
@@ -218,7 +229,7 @@
 	spi_bitbang_cleanup(spi);
 }
 
-static int __init spi_gpio_alloc(unsigned pin, const char *label, bool is_in)
+static int __devinit spi_gpio_alloc(unsigned pin, const char *label, bool is_in)
 {
 	int value;
 
@@ -232,7 +243,7 @@
 	return value;
 }
 
-static int __init
+static int __devinit
 spi_gpio_request(struct spi_gpio_platform_data *pdata, const char *label)
 {
 	int value;
@@ -261,7 +272,7 @@
 	return value;
 }
 
-static int __init spi_gpio_probe(struct platform_device *pdev)
+static int __devinit spi_gpio_probe(struct platform_device *pdev)
 {
 	int				status;
 	struct spi_master		*master;
@@ -317,7 +328,7 @@
 	return status;
 }
 
-static int __exit spi_gpio_remove(struct platform_device *pdev)
+static int __devexit spi_gpio_remove(struct platform_device *pdev)
 {
 	struct spi_gpio			*spi_gpio;
 	struct spi_gpio_platform_data	*pdata;
@@ -344,12 +355,13 @@
 static struct platform_driver spi_gpio_driver = {
 	.driver.name	= DRIVER_NAME,
 	.driver.owner	= THIS_MODULE,
-	.remove		= __exit_p(spi_gpio_remove),
+	.probe		= spi_gpio_probe,
+	.remove		= __devexit_p(spi_gpio_remove),
 };
 
 static int __init spi_gpio_init(void)
 {
-	return platform_driver_probe(&spi_gpio_driver, spi_gpio_probe);
+	return platform_driver_register(&spi_gpio_driver);
 }
 module_init(spi_gpio_init);
 
diff -Nru linux-2.6.30.5/drivers/spi/spi_gpio_old.c linux-2.6.30.5-wrt/drivers/spi/spi_gpio_old.c
--- linux-2.6.30.5/drivers/spi/spi_gpio_old.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/drivers/spi/spi_gpio_old.c	2009-09-06 18:44:06.807166783 +0200
@@ -0,0 +1,251 @@
+/*
+ * Bitbanging SPI bus driver using GPIO API
+ *
+ * Copyright (c) 2008 Piotr Skamruk
+ * Copyright (c) 2008 Michael Buesch
+ *
+ * based on spi_s3c2410_gpio.c
+ *   Copyright (c) 2006 Ben Dooks
+ *   Copyright (c) 2006 Simtec Electronics
+ * and on i2c-gpio.c
+ *   Copyright (C) 2007 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_bitbang.h>
+#include <linux/spi/spi_gpio_old.h>
+#include <linux/gpio.h>
+#include <asm/atomic.h>
+
+
+struct spi_gpio {
+	struct spi_bitbang bitbang;
+	struct spi_gpio_platform_data *info;
+	struct platform_device *pdev;
+	struct spi_board_info bi;
+};
+
+
+static inline struct spi_gpio *spidev_to_sg(struct spi_device *dev)
+{
+	return dev->controller_data;
+}
+
+static inline void setsck(struct spi_device *dev, int val)
+{
+	struct spi_gpio *sp = spidev_to_sg(dev);
+	gpio_set_value(sp->info->pin_clk, val ? 1 : 0);
+}
+
+static inline void setmosi(struct spi_device *dev, int val)
+{
+	struct spi_gpio *sp = spidev_to_sg(dev);
+	gpio_set_value(sp->info->pin_mosi, val ? 1 : 0);
+}
+
+static inline u32 getmiso(struct spi_device *dev)
+{
+	struct spi_gpio *sp = spidev_to_sg(dev);
+	return gpio_get_value(sp->info->pin_miso) ? 1 : 0;
+}
+
+static inline void do_spidelay(struct spi_device *dev, unsigned nsecs)
+{
+	struct spi_gpio *sp = spidev_to_sg(dev);
+
+	if (!sp->info->no_spi_delay)
+		ndelay(nsecs);
+}
+
+#define spidelay(nsecs) do {					\
+	/* Steal the spi_device pointer from our caller.	\
+	 * The bitbang-API should probably get fixed here... */	\
+	do_spidelay(spi, nsecs);				\
+  } while (0)
+
+#define EXPAND_BITBANG_TXRX
+#include <linux/spi/spi_bitbang.h>
+
+static u32 spi_gpio_txrx_mode0(struct spi_device *spi,
+			       unsigned nsecs, u32 word, u8 bits)
+{
+	return bitbang_txrx_be_cpha0(spi, nsecs, 0, word, bits);
+}
+
+static u32 spi_gpio_txrx_mode1(struct spi_device *spi,
+			       unsigned nsecs, u32 word, u8 bits)
+{
+	return bitbang_txrx_be_cpha1(spi, nsecs, 0, word, bits);
+}
+
+static u32 spi_gpio_txrx_mode2(struct spi_device *spi,
+			       unsigned nsecs, u32 word, u8 bits)
+{
+	return bitbang_txrx_be_cpha0(spi, nsecs, 1, word, bits);
+}
+
+static u32 spi_gpio_txrx_mode3(struct spi_device *spi,
+			       unsigned nsecs, u32 word, u8 bits)
+{
+	return bitbang_txrx_be_cpha1(spi, nsecs, 1, word, bits);
+}
+
+static void spi_gpio_chipselect(struct spi_device *dev, int on)
+{
+	struct spi_gpio *sp = spidev_to_sg(dev);
+
+	if (sp->info->cs_activelow)
+		on = !on;
+	gpio_set_value(sp->info->pin_cs, on ? 1 : 0);
+}
+
+static int spi_gpio_probe(struct platform_device *pdev)
+{
+	struct spi_master *master;
+	struct spi_gpio_platform_data *pdata;
+	struct spi_gpio *sp;
+	struct spi_device *spidev;
+	int err;
+
+	pdata = pdev->dev.platform_data;
+	if (!pdata)
+		return -ENXIO;
+
+	err = -ENOMEM;
+	master = spi_alloc_master(&pdev->dev, sizeof(struct spi_gpio));
+	if (!master)
+		goto err_alloc_master;
+
+	sp = spi_master_get_devdata(master);
+	platform_set_drvdata(pdev, sp);
+	sp->info = pdata;
+
+	err = gpio_request(pdata->pin_clk, "spi_clock");
+	if (err)
+		goto err_request_clk;
+	err = gpio_request(pdata->pin_mosi, "spi_mosi");
+	if (err)
+		goto err_request_mosi;
+	err = gpio_request(pdata->pin_miso, "spi_miso");
+	if (err)
+		goto err_request_miso;
+	err = gpio_request(pdata->pin_cs, "spi_cs");
+	if (err)
+		goto err_request_cs;
+
+	sp->bitbang.master = spi_master_get(master);
+	sp->bitbang.master->bus_num = -1;
+	sp->bitbang.master->num_chipselect = 1;
+	sp->bitbang.chipselect = spi_gpio_chipselect;
+	sp->bitbang.txrx_word[SPI_MODE_0] = spi_gpio_txrx_mode0;
+	sp->bitbang.txrx_word[SPI_MODE_1] = spi_gpio_txrx_mode1;
+	sp->bitbang.txrx_word[SPI_MODE_2] = spi_gpio_txrx_mode2;
+	sp->bitbang.txrx_word[SPI_MODE_3] = spi_gpio_txrx_mode3;
+
+	gpio_direction_output(pdata->pin_clk, 0);
+	gpio_direction_output(pdata->pin_mosi, 0);
+	gpio_direction_output(pdata->pin_cs,
+			      pdata->cs_activelow ? 1 : 0);
+	gpio_direction_input(pdata->pin_miso);
+
+	err = spi_bitbang_start(&sp->bitbang);
+	if (err)
+		goto err_no_bitbang;
+	err = pdata->boardinfo_setup(&sp->bi, master,
+				     pdata->boardinfo_setup_data);
+	if (err)
+		goto err_bi_setup;
+	sp->bi.controller_data = sp;
+	spidev = spi_new_device(master, &sp->bi);
+	if (!spidev)
+		goto err_new_dev;
+
+	return 0;
+
+err_new_dev:
+err_bi_setup:
+	spi_bitbang_stop(&sp->bitbang);
+err_no_bitbang:
+	spi_master_put(sp->bitbang.master);
+	gpio_free(pdata->pin_cs);
+err_request_cs:
+	gpio_free(pdata->pin_miso);
+err_request_miso:
+	gpio_free(pdata->pin_mosi);
+err_request_mosi:
+	gpio_free(pdata->pin_clk);
+err_request_clk:
+	kfree(master);
+
+err_alloc_master:
+	return err;
+}
+
+static int __devexit spi_gpio_remove(struct platform_device *pdev)
+{
+	struct spi_gpio *sp;
+	struct spi_gpio_platform_data *pdata;
+
+	pdata = pdev->dev.platform_data;
+	sp = platform_get_drvdata(pdev);
+
+	gpio_free(pdata->pin_clk);
+	gpio_free(pdata->pin_mosi);
+	gpio_free(pdata->pin_miso);
+	gpio_free(pdata->pin_cs);
+	spi_bitbang_stop(&sp->bitbang);
+	spi_master_put(sp->bitbang.master);
+
+	return 0;
+}
+
+static struct platform_driver spi_gpio_driver = {
+	.driver		= {
+		.name	= SPI_GPIO_PLATDEV_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= spi_gpio_probe,
+	.remove		= __devexit_p(spi_gpio_remove),
+};
+
+int spi_gpio_next_id(void)
+{
+	static atomic_t counter = ATOMIC_INIT(-1);
+
+	return atomic_inc_return(&counter);
+}
+EXPORT_SYMBOL(spi_gpio_next_id);
+
+static int __init spi_gpio_init(void)
+{
+	int err;
+
+	err = platform_driver_register(&spi_gpio_driver);
+	if (err)
+		printk(KERN_ERR "spi-gpio: register failed: %d\n", err);
+
+	return err;
+}
+module_init(spi_gpio_init);
+
+static void __exit spi_gpio_exit(void)
+{
+	platform_driver_unregister(&spi_gpio_driver);
+}
+module_exit(spi_gpio_exit);
+
+MODULE_AUTHOR("Piot Skamruk <piotr.skamruk at gmail.com>");
+MODULE_AUTHOR("Michael Buesch");
+MODULE_DESCRIPTION("Platform independent GPIO bitbanging SPI driver");
+MODULE_LICENSE("GPL v2");
diff -Nru linux-2.6.30.5/drivers/ssb/Kconfig linux-2.6.30.5-wrt/drivers/ssb/Kconfig
--- linux-2.6.30.5/drivers/ssb/Kconfig	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/ssb/Kconfig	2009-09-06 18:47:53.795177672 +0200
@@ -49,7 +49,7 @@
 config SSB_B43_PCI_BRIDGE
 	bool
 	depends on SSB_PCIHOST
-	default n
+	default y
 
 config SSB_PCMCIAHOST_POSSIBLE
 	bool
@@ -126,6 +126,8 @@
 config SSB_EMBEDDED
 	bool
 	depends on SSB_DRIVER_MIPS
+	select USB_EHCI_HCD_SSB
+	select USB_OHCI_HCD_SSB
 	default y
 
 config SSB_DRIVER_EXTIF
diff -Nru linux-2.6.30.5/drivers/ssb/driver_chipcommon.c linux-2.6.30.5-wrt/drivers/ssb/driver_chipcommon.c
--- linux-2.6.30.5/drivers/ssb/driver_chipcommon.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/ssb/driver_chipcommon.c	2009-09-06 18:47:53.787167198 +0200
@@ -258,6 +258,8 @@
 void ssb_chipco_get_clockcpu(struct ssb_chipcommon *cc,
                              u32 *plltype, u32 *n, u32 *m)
 {
+	if ((chipco_read32(cc, SSB_CHIPCO_CHIPID) & SSB_CHIPCO_IDMASK) == 0x5354)
+		return;
 	*n = chipco_read32(cc, SSB_CHIPCO_CLOCK_N);
 	*plltype = (cc->capabilities & SSB_CHIPCO_CAP_PLLT);
 	switch (*plltype) {
@@ -281,6 +283,8 @@
 void ssb_chipco_get_clockcontrol(struct ssb_chipcommon *cc,
 				 u32 *plltype, u32 *n, u32 *m)
 {
+	if ((chipco_read32(cc, SSB_CHIPCO_CHIPID) & SSB_CHIPCO_IDMASK) == 0x5354)
+		return;
 	*n = chipco_read32(cc, SSB_CHIPCO_CLOCK_N);
 	*plltype = (cc->capabilities & SSB_CHIPCO_CAP_PLLT);
 	switch (*plltype) {
diff -Nru linux-2.6.30.5/drivers/ssb/driver_mipscore.c linux-2.6.30.5-wrt/drivers/ssb/driver_mipscore.c
--- linux-2.6.30.5/drivers/ssb/driver_mipscore.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/ssb/driver_mipscore.c	2009-09-06 18:48:23.530699264 +0200
@@ -49,29 +49,54 @@
 
 static inline u32 ssb_irqflag(struct ssb_device *dev)
 {
-	return ssb_read32(dev, SSB_TPSFLAG) & SSB_TPSFLAG_BPFLAG;
+	u32 tpsflag = ssb_read32(dev, SSB_TPSFLAG);
+	if (tpsflag)
+		return ssb_read32(dev, SSB_TPSFLAG) & SSB_TPSFLAG_BPFLAG;
+	else
+		/* not irq supported */
+		return 0x3f;
+}
+
+static struct ssb_device *find_device(struct ssb_device *rdev, int irqflag)
+{
+	struct ssb_bus *bus = rdev->bus;
+	int i;
+	for (i = 0; i < bus->nr_devices; i++) {
+		struct ssb_device *dev;
+		dev = &(bus->devices[i]);
+		if (ssb_irqflag(dev) == irqflag)
+			return dev;
+	}
+	return NULL;
 }
 
 /* Get the MIPS IRQ assignment for a specified device.
  * If unassigned, 0 is returned.
+ * If disabled, 5 is returned.
+ * If not supported, 6 is returned.
  */
 unsigned int ssb_mips_irq(struct ssb_device *dev)
 {
 	struct ssb_bus *bus = dev->bus;
+	struct ssb_device *mdev = bus->mipscore.dev;
 	u32 irqflag;
 	u32 ipsflag;
 	u32 tmp;
 	unsigned int irq;
 
 	irqflag = ssb_irqflag(dev);
+	if (irqflag == 0x3f)
+		return 6;
 	ipsflag = ssb_read32(bus->mipscore.dev, SSB_IPSFLAG);
 	for (irq = 1; irq <= 4; irq++) {
 		tmp = ((ipsflag & ipsflag_irq_mask[irq]) >> ipsflag_irq_shift[irq]);
 		if (tmp == irqflag)
 			break;
 	}
-	if (irq	== 5)
-		irq = 0;
+	if (irq	== 5) {
+		if ((1 << irqflag) & ssb_read32(mdev, SSB_INTVEC))
+			irq = 0;
+	}
 
 	return irq;
 }
@@ -97,25 +122,56 @@
 	struct ssb_device *mdev = bus->mipscore.dev;
 	u32 irqflag = ssb_irqflag(dev);
 
+	BUG_ON(oldirq == 6);
+
 	dev->irq = irq + 2;
 
-	ssb_dprintk(KERN_INFO PFX
-		    "set_irq: core 0x%04x, irq %d => %d\n",
-		    dev->id.coreid, oldirq, irq);
 	/* clear the old irq */
 	if (oldirq == 0)
 		ssb_write32(mdev, SSB_INTVEC, (~(1 << irqflag) & ssb_read32(mdev, SSB_INTVEC)));
-	else
+	else if (oldirq != 5)
 		clear_irq(bus, oldirq);
 
 	/* assign the new one */
 	if (irq == 0) {
 		ssb_write32(mdev, SSB_INTVEC, ((1 << irqflag) | ssb_read32(mdev, SSB_INTVEC)));
 	} else {
+		u32 ipsflag = ssb_read32(mdev, SSB_IPSFLAG);
+		if ((ipsflag & ipsflag_irq_mask[irq]) != ipsflag_irq_mask[irq]) {
+			u32 oldipsflag = (ipsflag & ipsflag_irq_mask[irq]) >> ipsflag_irq_shift[irq];
+			struct ssb_device *olddev = find_device(dev, oldipsflag);
+			if (olddev)
+				set_irq(olddev, 0);
+		}
 		irqflag <<= ipsflag_irq_shift[irq];
-		irqflag |= (ssb_read32(mdev, SSB_IPSFLAG) & ~ipsflag_irq_mask[irq]);
+		irqflag |= (ipsflag & ~ipsflag_irq_mask[irq]);
 		ssb_write32(mdev, SSB_IPSFLAG, irqflag);
 	}
+	ssb_dprintk(KERN_INFO PFX
+		    "set_irq: core 0x%04x, irq %d => %d\n",
+		    dev->id.coreid, oldirq+2, irq+2);
+}
+
+static void print_irq(struct ssb_device *dev, unsigned int irq)
+{
+	int i;
+	static const char *irq_name[] = {"2(S)", "3", "4", "5", "6", "D", "I"};
+	ssb_dprintk(KERN_INFO PFX
+		"core 0x%04x, irq :", dev->id.coreid);
+	for (i = 0; i <= 6; i++) {
+		ssb_dprintk(" %s%s", irq_name[i], i==irq?"*":" ");
+	}
+	ssb_dprintk("\n");
+}
+
+static void dump_irq(struct ssb_bus *bus)
+{
+	int i;
+	for (i = 0; i < bus->nr_devices; i++) {
+		struct ssb_device *dev;
+		dev = &(bus->devices[i]);
+		print_irq(dev, ssb_mips_irq(dev));
+	}
 }
 
 static void ssb_mips_serial_init(struct ssb_mipscore *mcore)
@@ -161,6 +217,8 @@
 
 	if ((pll_type == SSB_PLLTYPE_5) || (bus->chip_id == 0x5365)) {
 		rate = 200000000;
+	} else if (bus->chip_id == 0x5354) {
+		rate = 240000000;
 	} else {
 		rate = ssb_calc_clock_rate(pll_type, n, m);
 	}
@@ -195,18 +253,26 @@
 	else if (bus->chipco.dev)
 		ssb_chipco_timing_init(&bus->chipco, ns);
 
+	dump_irq(bus);
 	/* Assign IRQs to all cores on the bus, start with irq line 2, because serial usually takes 1 */
 	for (irq = 2, i = 0; i < bus->nr_devices; i++) {
+		int mips_irq;
 		dev = &(bus->devices[i]);
-		dev->irq = ssb_mips_irq(dev) + 2;
+		mips_irq = ssb_mips_irq(dev);
+		if (mips_irq > 4)
+			dev->irq = 0;
+		else
+			dev->irq = mips_irq + 2;
+		if (dev->irq > 5)
+			continue;
 		switch (dev->id.coreid) {
 		case SSB_DEV_USB11_HOST:
 			/* shouldn't need a separate irq line for non-4710, most of them have a proper
 			 * external usb controller on the pci */
 			if ((bus->chip_id == 0x4710) && (irq <= 4)) {
 				set_irq(dev, irq++);
-				break;
 			}
+			break;
 			/* fallthrough */
 		case SSB_DEV_PCI:
 		case SSB_DEV_ETHERNET:
@@ -220,6 +286,8 @@
 			}
 		}
 	}
+	ssb_dprintk(KERN_INFO PFX "after irq reconfiguration\n");
+	dump_irq(bus);
 
 	ssb_mips_serial_init(mcore);
 	ssb_mips_flash_detect(mcore);
diff -Nru linux-2.6.30.5/drivers/ssb/main.c linux-2.6.30.5-wrt/drivers/ssb/main.c
--- linux-2.6.30.5/drivers/ssb/main.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/ssb/main.c	2009-09-06 18:47:53.787167198 +0200
@@ -1010,6 +1010,8 @@
 
 	if (bus->chip_id == 0x5365) {
 		rate = 100000000;
+	} else if (bus->chip_id == 0x5354) {
+		rate = 120000000;
 	} else {
 		rate = ssb_calc_clock_rate(plltype, clkctl_n, clkctl_m);
 		if (plltype == SSB_PLLTYPE_3) /* 25Mhz, 2 dividers */
diff -Nru linux-2.6.30.5/drivers/usb/host/Kconfig linux-2.6.30.5-wrt/drivers/usb/host/Kconfig
--- linux-2.6.30.5/drivers/usb/host/Kconfig	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/usb/host/Kconfig	2009-09-06 18:47:53.791214951 +0200
@@ -106,6 +106,19 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called oxu210hp-hcd.
 
+config USB_EHCI_HCD_SSB
+	bool "EHCI support for Broadcom SSB EHCI core"
+	depends on USB_EHCI_HCD && SSB && EXPERIMENTAL
+	default n
+	---help---
+	  Support for the Sonics Silicon Backplane (SSB) attached
+	  Broadcom USB EHCI core.
+
+	  This device is present in some embedded devices with
+	  Broadcom based SSB bus.
+
+	  If unsure, say N.
+
 config USB_ISP116X_HCD
 	tristate "ISP116X HCD support"
 	depends on USB
diff -Nru linux-2.6.30.5/drivers/usb/host/ehci-hcd.c linux-2.6.30.5-wrt/drivers/usb/host/ehci-hcd.c
--- linux-2.6.30.5/drivers/usb/host/ehci-hcd.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/usb/host/ehci-hcd.c	2009-09-06 18:47:53.791214951 +0200
@@ -1072,8 +1072,16 @@
 #define	PLATFORM_DRIVER		ixp4xx_ehci_driver
 #endif
 
-#if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
-    !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER)
+#ifdef CONFIG_USB_EHCI_HCD_SSB
+#include "ehci-ssb.c"
+#define SSB_EHCI_DRIVER         ssb_ehci_driver
+#endif
+
+#if !defined(PCI_DRIVER) && \
+    !defined(PLATFORM_DRIVER) && \
+    !defined(PS3_SYSTEM_BUS_DRIVER) && \
+    !defined(OF_PLATFORM_DRIVER) && \
+    !defined(SSB_EHCI_DRIVER)
 #error "missing bus glue for ehci-hcd"
 #endif
 
diff -Nru linux-2.6.30.5/drivers/usb/host/ehci-ssb.c linux-2.6.30.5-wrt/drivers/usb/host/ehci-ssb.c
--- linux-2.6.30.5/drivers/usb/host/ehci-ssb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/drivers/usb/host/ehci-ssb.c	2009-09-06 18:47:53.791214951 +0200
@@ -0,0 +1,201 @@
+/*
+ * Sonics Silicon Backplane
+ * Broadcom USB-core EHCI driver (SSB bus glue)
+ *
+ * Copyright 2007 Steven Brown <sbrown@cortland.com>
+ *
+ * Derived from the OHCI-SSB driver
+ * Copyright 2007 Michael Buesch <mb@bu3sch.de>
+ *
+ * Derived from the EHCI-PCI driver
+ * Copyright (c) 2000-2004 by David Brownell
+ *
+ * Derived from the OHCI-PCI driver
+ * Copyright 1999 Roman Weissgaerber
+ * Copyright 2000-2002 David Brownell
+ * Copyright 1999 Linus Torvalds
+ * Copyright 1999 Gregory P. Smith
+ *
+ * Derived from the USBcore related parts of Broadcom-SB
+ * Copyright 2005 Broadcom Corporation
+ *
+ * Licensed under the GNU/GPL. See COPYING for details.
+ */
+#include <linux/ssb/ssb.h>
+
+#define SSB_OHCI_TMSLOW_HOSTMODE	(1 << 29)
+
+struct ssb_ehci_device {
+	struct ehci_hcd ehci; /* _must_ be at the beginning. */
+
+	u32 enable_flags;
+};
+
+static inline
+struct ssb_ehci_device *hcd_to_ssb_ehci(struct usb_hcd *hcd)
+{
+	return (struct ssb_ehci_device *)(hcd->hcd_priv);
+}
+
+
+static int ssb_ehci_reset(struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int err;
+
+	ehci->caps = hcd->regs;
+	ehci->regs = hcd->regs +
+		HC_LENGTH(ehci_readl(ehci, &ehci->caps->hc_capbase));
+
+	dbg_hcs_params(ehci, "reset");
+	dbg_hcc_params(ehci, "reset");
+
+	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
+
+	err = ehci_halt(ehci);
+
+	if (err)
+		return err;
+
+	err = ehci_init(hcd);
+
+	if (err)
+		return err;
+
+	ehci_port_power(ehci, 0);
+
+	return err;
+}
+
+static int ssb_ehci_start(struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int err;
+
+	err = ehci_run(hcd);
+	if (err < 0) {
+		ehci_err(ehci, "can't start\n");
+		ehci_stop(hcd);
+	}
+
+	return err;
+}
+
+#ifdef CONFIG_PM
+static int ssb_ehci_hcd_suspend(struct usb_hcd *hcd, pm_message_t message)
+{
+	struct ssb_ehci_device *ehcidev = hcd_to_ssb_ehci(hcd);
+	struct ehci_hcd *ehci = &ehcidev->ehci;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ehci->lock, flags);
+
+	ehci_writel(ehci, EHCI_INTR_MIE, &ehci->regs->intrdisable);
+	ehci_readl(ehci, &ehci->regs->intrdisable); /* commit write */
+
+	/* make sure snapshot being resumed re-enumerates everything */
+	if (message.event == PM_EVENT_PRETHAW)
+		ehci_usb_reset(ehci);
+
+	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+
+	spin_unlock_irqrestore(&ehci->lock, flags);
+	return 0;
+}
+
+static int ssb_ehci_hcd_resume(struct usb_hcd *hcd)
+{
+	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+	usb_hcd_resume_root_hub(hcd);
+	return 0;
+}
+#endif /* CONFIG_PM */
+
+static const struct hc_driver ssb_ehci_hc_driver = {
+	.description		= "ssb-usb-ehci",
+	.product_desc		= "SSB EHCI Controller",
+	.hcd_priv_size		= sizeof(struct ssb_ehci_device),
+
+	.irq			= ehci_irq,
+	.flags			= HCD_MEMORY | HCD_USB2,
+
+	.reset			= ssb_ehci_reset,
+	.start			= ssb_ehci_start,
+	.stop			= ehci_stop,
+	.shutdown		= ehci_shutdown,
+
+#ifdef CONFIG_PM
+	.suspend		= ssb_ehci_hcd_suspend,
+	.resume			= ssb_ehci_hcd_resume,
+#endif
+
+	.urb_enqueue		= ehci_urb_enqueue,
+	.urb_dequeue		= ehci_urb_dequeue,
+	.endpoint_disable	= ehci_endpoint_disable,
+
+	.get_frame_number	= ehci_get_frame,
+
+	.hub_status_data	= ehci_hub_status_data,
+	.hub_control		= ehci_hub_control,
+#ifdef CONFIG_PM
+	.bus_suspend		= ehci_bus_suspend,
+	.bus_resume		= ehci_bus_resume,
+#endif
+
+};
+
+static void ssb_ehci_detach(struct ssb_device *dev, struct usb_hcd *hcd)
+{
+
+	usb_remove_hcd(hcd);
+	iounmap(hcd->regs);
+	usb_put_hcd(hcd);
+}
+EXPORT_SYMBOL_GPL(ssb_ehci_detach);
+
+static int ssb_ehci_attach(struct ssb_device *dev, struct usb_hcd **ehci_hcd)
+{
+	struct ssb_ehci_device *ehcidev;
+	struct usb_hcd *hcd;
+	int err = -ENOMEM;
+	u32 tmp, flags = 0;
+
+	hcd = usb_create_hcd(&ssb_ehci_hc_driver, dev->dev,
+		dev_name(dev->dev));
+	if (!hcd)
+		goto err_dev_disable;
+
+	ehcidev = hcd_to_ssb_ehci(hcd);
+	ehcidev->enable_flags = flags;
+	tmp = ssb_read32(dev, SSB_ADMATCH0);
+	hcd->rsrc_start = ssb_admatch_base(tmp) + 0x800; /* ehci core offset */
+	hcd->rsrc_len = 0x100; /* ehci reg block size */
+	/*
+	 * start & size modified per sbutils.c
+	 */
+	hcd->regs = ioremap_nocache(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs)
+		goto err_put_hcd;
+	err = usb_add_hcd(hcd, dev->irq, IRQF_SHARED | IRQF_DISABLED);
+	if (err)
+		goto err_iounmap;
+
+	*ehci_hcd = hcd;
+
+	return err;
+
+err_iounmap:
+	iounmap(hcd->regs);
+err_put_hcd:
+	usb_put_hcd(hcd);
+err_dev_disable:
+	ssb_device_disable(dev, flags);
+	return err;
+}
+EXPORT_SYMBOL_GPL(ssb_ehci_attach);
+
+static const struct ssb_device_id ssb_ehci_table[] = {
+	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_USB20_HOST, SSB_ANY_REV),
+	SSB_DEVTABLE_END
+};
+MODULE_DEVICE_TABLE(ssb, ssb_ehci_table);
diff -Nru linux-2.6.30.5/drivers/usb/host/ohci-ssb.c linux-2.6.30.5-wrt/drivers/usb/host/ohci-ssb.c
--- linux-2.6.30.5/drivers/usb/host/ohci-ssb.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/usb/host/ohci-ssb.c	2009-09-06 18:48:23.486730125 +0200
@@ -17,6 +17,8 @@
  */
 #include <linux/ssb/ssb.h>
 
+extern int ssb_ehci_attach(struct ssb_device *dev, struct usb_hcd **hcd);
+extern void ssb_ehci_detach(struct ssb_device *dev, struct usb_hcd *hcd);
 
 #define SSB_OHCI_TMSLOW_HOSTMODE	(1 << 29)
 
@@ -24,6 +26,7 @@
 	struct ohci_hcd ohci; /* _must_ be at the beginning. */
 
 	u32 enable_flags;
+	struct usb_hcd *ehci_hcd;
 };
 
 static inline
@@ -92,13 +95,25 @@
 static void ssb_ohci_detach(struct ssb_device *dev)
 {
 	struct usb_hcd *hcd = ssb_get_drvdata(dev);
+#ifdef CONFIG_USB_EHCI_HCD_SSB
+	struct ssb_ohci_device *ohcidev = hcd_to_ssb_ohci(hcd);
+#endif
 
 	usb_remove_hcd(hcd);
 	iounmap(hcd->regs);
 	usb_put_hcd(hcd);
+
+#ifdef CONFIG_USB_EHCI_HCD_SSB
+	/*
+	 * Also detach ehci function
+	 */
+	if (dev->id.coreid == SSB_DEV_USB20_HOST)
+		ssb_ehci_detach(dev, ohcidev->ehci_hcd);
+#endif
 	ssb_device_disable(dev, 0);
 }
 
+
 static int ssb_ohci_attach(struct ssb_device *dev)
 {
 	struct ssb_ohci_device *ohcidev;
@@ -106,10 +121,64 @@
 	int err = -ENOMEM;
 	u32 tmp, flags = 0;
 
-	if (dev->id.coreid == SSB_DEV_USB11_HOSTDEV)
+	/*
+	 * THE FOLLOWING COMMENTS PRESERVED FROM GPL SOURCE RELEASE
+	 *
+	 * The USB core requires a special bit to be set during core
+	 * reset to enable host (OHCI) mode. Resetting the SB core in
+	 * pcibios_enable_device() is a hack for compatibility with
+	 * vanilla usb-ohci so that it does not have to know about
+	 * SB. A driver that wants to use the USB core in device mode
+	 * should know about SB and should reset the bit back to 0
+	 * after calling pcibios_enable_device().
+	 */
+
+	if (dev->id.coreid == SSB_DEV_USB11_HOSTDEV) {
 		flags |= SSB_OHCI_TMSLOW_HOSTMODE;
+		ssb_device_enable(dev, flags);
+	}
+
+	/*
+	 * USB 2.0 special considerations:
+	 *
+	 * 1. Since the core supports both OHCI and EHCI functions, it must
+	 *    only be reset once.
+	 * 
+	 * 2. In addition to the standard SB reset sequence, the Host Control
+	 *    Register must be programmed to bring the USB core and various
+	 *    phy components out of reset. 
+	 */
+
+	else if (dev->id.coreid == SSB_DEV_USB20_HOST) {
+#warning FIX ME need test for core being up & exit
+		ssb_device_enable(dev, 0);
+		ssb_write32(dev, 0x200, 0x7ff);
+		udelay(1);
+		if (dev->id.revision == 1) { // bug in rev 1
+
+			/* Change Flush control reg */
+			tmp = ssb_read32(dev, 0x400);
+			tmp &= ~8;
+			ssb_write32(dev, 0x400, tmp);
+			tmp = ssb_read32(dev, 0x400);
+			printk("USB20H fcr: 0x%0x\n", tmp);
+
+			/* Change Shim control reg */
+			tmp = ssb_read32(dev, 0x304);
+			tmp &= ~0x100;
+			ssb_write32(dev, 0x304, tmp);
+			tmp = ssb_read32(dev, 0x304);
+			printk("USB20H shim: 0x%0x\n", tmp);
+		}
+	}
+	else
+		ssb_device_enable(dev, 0);
 
-	ssb_device_enable(dev, flags);
+ /*
+  * Set dma mask - 32 bit mask is just an assumption
+  */
+ if (ssb_dma_set_mask(dev, DMA_32BIT_MASK))
+   return -EOPNOTSUPP;
 
 	hcd = usb_create_hcd(&ssb_ohci_hc_driver, dev->dev,
 			dev_name(dev->dev));
@@ -130,6 +199,14 @@
 
 	ssb_set_drvdata(dev, hcd);
 
+#ifdef CONFIG_USB_EHCI_HCD_SSB
+	/*
+	 * attach ehci function in this core
+	 */
+	if (dev->id.coreid == SSB_DEV_USB20_HOST)
+		err = ssb_ehci_attach(dev, &(ohcidev->ehci_hcd));
+#endif
+
 	return err;
 
 err_iounmap:
@@ -200,6 +277,7 @@
 static const struct ssb_device_id ssb_ohci_table[] = {
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_USB11_HOSTDEV, SSB_ANY_REV),
 	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_USB11_HOST, SSB_ANY_REV),
+	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_USB20_HOST, SSB_ANY_REV),
 	SSB_DEVTABLE_END
 };
 MODULE_DEVICE_TABLE(ssb, ssb_ohci_table);
diff -Nru linux-2.6.30.5/drivers/usb/host/ohci-ssb.c.orig linux-2.6.30.5-wrt/drivers/usb/host/ohci-ssb.c.orig
--- linux-2.6.30.5/drivers/usb/host/ohci-ssb.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/drivers/usb/host/ohci-ssb.c.orig	2009-09-06 18:47:53.791214951 +0200
@@ -0,0 +1,292 @@
+/*
+ * Sonics Silicon Backplane
+ * Broadcom USB-core OHCI driver
+ *
+ * Copyright 2007 Michael Buesch <mb@bu3sch.de>
+ *
+ * Derived from the OHCI-PCI driver
+ * Copyright 1999 Roman Weissgaerber
+ * Copyright 2000-2002 David Brownell
+ * Copyright 1999 Linus Torvalds
+ * Copyright 1999 Gregory P. Smith
+ *
+ * Derived from the USBcore related parts of Broadcom-SB
+ * Copyright 2005 Broadcom Corporation
+ *
+ * Licensed under the GNU/GPL. See COPYING for details.
+ */
+#include <linux/ssb/ssb.h>
+
+extern int ssb_ehci_attach(struct ssb_device *dev, struct usb_hcd **hcd);
+extern void ssb_ehci_detach(struct ssb_device *dev, struct usb_hcd *hcd);
+
+#define SSB_OHCI_TMSLOW_HOSTMODE	(1 << 29)
+
+struct ssb_ohci_device {
+	struct ohci_hcd ohci; /* _must_ be at the beginning. */
+
+	u32 enable_flags;
+	struct usb_hcd *ehci_hcd;
+};
+
+static inline
+struct ssb_ohci_device *hcd_to_ssb_ohci(struct usb_hcd *hcd)
+{
+	return (struct ssb_ohci_device *)(hcd->hcd_priv);
+}
+
+
+static int ssb_ohci_reset(struct usb_hcd *hcd)
+{
+	struct ssb_ohci_device *ohcidev = hcd_to_ssb_ohci(hcd);
+	struct ohci_hcd *ohci = &ohcidev->ohci;
+	int err;
+
+	ohci_hcd_init(ohci);
+	err = ohci_init(ohci);
+
+	return err;
+}
+
+static int ssb_ohci_start(struct usb_hcd *hcd)
+{
+	struct ssb_ohci_device *ohcidev = hcd_to_ssb_ohci(hcd);
+	struct ohci_hcd *ohci = &ohcidev->ohci;
+	int err;
+
+	err = ohci_run(ohci);
+	if (err < 0) {
+		ohci_err(ohci, "can't start\n");
+		ohci_stop(hcd);
+	}
+
+	return err;
+}
+
+static const struct hc_driver ssb_ohci_hc_driver = {
+	.description		= "ssb-usb-ohci",
+	.product_desc		= "SSB OHCI Controller",
+	.hcd_priv_size		= sizeof(struct ssb_ohci_device),
+
+	.irq			= ohci_irq,
+	.flags			= HCD_MEMORY | HCD_USB11,
+
+	.reset			= ssb_ohci_reset,
+	.start			= ssb_ohci_start,
+	.stop			= ohci_stop,
+	.shutdown		= ohci_shutdown,
+
+	.urb_enqueue		= ohci_urb_enqueue,
+	.urb_dequeue		= ohci_urb_dequeue,
+	.endpoint_disable	= ohci_endpoint_disable,
+
+	.get_frame_number	= ohci_get_frame,
+
+	.hub_status_data	= ohci_hub_status_data,
+	.hub_control		= ohci_hub_control,
+#ifdef	CONFIG_PM
+	.bus_suspend		= ohci_bus_suspend,
+	.bus_resume		= ohci_bus_resume,
+#endif
+
+	.start_port_reset	= ohci_start_port_reset,
+};
+
+static void ssb_ohci_detach(struct ssb_device *dev)
+{
+	struct usb_hcd *hcd = ssb_get_drvdata(dev);
+#ifdef CONFIG_USB_EHCI_HCD_SSB
+	struct ssb_ohci_device *ohcidev = hcd_to_ssb_ohci(hcd);
+#endif
+
+	usb_remove_hcd(hcd);
+	iounmap(hcd->regs);
+	usb_put_hcd(hcd);
+
+#ifdef CONFIG_USB_EHCI_HCD_SSB
+	/*
+	 * Also detach ehci function
+	 */
+	if (dev->id.coreid == SSB_DEV_USB20_HOST)
+		ssb_ehci_detach(dev, ohcidev->ehci_hcd);
+#endif
+	ssb_device_disable(dev, 0);
+}
+
+
+static int ssb_ohci_attach(struct ssb_device *dev)
+{
+	struct ssb_ohci_device *ohcidev;
+	struct usb_hcd *hcd;
+	int err = -ENOMEM;
+	u32 tmp, flags = 0;
+
+	/*
+	 * THE FOLLOWING COMMENTS PRESERVED FROM GPL SOURCE RELEASE
+	 *
+	 * The USB core requires a special bit to be set during core
+	 * reset to enable host (OHCI) mode. Resetting the SB core in
+	 * pcibios_enable_device() is a hack for compatibility with
+	 * vanilla usb-ohci so that it does not have to know about
+	 * SB. A driver that wants to use the USB core in device mode
+	 * should know about SB and should reset the bit back to 0
+	 * after calling pcibios_enable_device().
+	 */
+
+	if (dev->id.coreid == SSB_DEV_USB11_HOSTDEV) {
+		flags |= SSB_OHCI_TMSLOW_HOSTMODE;
+		ssb_device_enable(dev, flags);
+	}
+
+	/*
+	 * USB 2.0 special considerations:
+	 *
+	 * 1. Since the core supports both OHCI and EHCI functions, it must
+	 *    only be reset once.
+	 * 
+	 * 2. In addition to the standard SB reset sequence, the Host Control
+	 *    Register must be programmed to bring the USB core and various
+	 *    phy components out of reset. 
+	 */
+
+	else if (dev->id.coreid == SSB_DEV_USB20_HOST) {
+#warning FIX ME need test for core being up & exit
+		ssb_device_enable(dev, 0);
+		ssb_write32(dev, 0x200, 0x7ff);
+		udelay(1);
+		if (dev->id.revision == 1) { // bug in rev 1
+
+			/* Change Flush control reg */
+			tmp = ssb_read32(dev, 0x400);
+			tmp &= ~8;
+			ssb_write32(dev, 0x400, tmp);
+			tmp = ssb_read32(dev, 0x400);
+			printk("USB20H fcr: 0x%0x\n", tmp);
+
+			/* Change Shim control reg */
+			tmp = ssb_read32(dev, 0x304);
+			tmp &= ~0x100;
+			ssb_write32(dev, 0x304, tmp);
+			tmp = ssb_read32(dev, 0x304);
+			printk("USB20H shim: 0x%0x\n", tmp);
+		}
+	}
+	else
+		ssb_device_enable(dev, 0);
+
+ /*
+  * Set dma mask - 32 bit mask is just an assumption
+  */
+ if (ssb_dma_set_mask(dev, DMA_32BIT_MASK))
+   return -EOPNOTSUPP;
+
+	hcd = usb_create_hcd(&ssb_ohci_hc_driver, dev->dev,
+			dev_name(dev->dev));
+	if (!hcd)
+		goto err_dev_disable;
+	ohcidev = hcd_to_ssb_ohci(hcd);
+	ohcidev->enable_flags = flags;
+
+	tmp = ssb_read32(dev, SSB_ADMATCH0);
+	hcd->rsrc_start = ssb_admatch_base(tmp);
+	hcd->rsrc_len = ssb_admatch_size(tmp);
+	hcd->regs = ioremap_nocache(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs)
+		goto err_put_hcd;
+	err = usb_add_hcd(hcd, dev->irq, IRQF_DISABLED | IRQF_SHARED);
+	if (err)
+		goto err_iounmap;
+
+	ssb_set_drvdata(dev, hcd);
+
+#ifdef CONFIG_USB_EHCI_HCD_SSB
+	/*
+	 * attach ehci function in this core
+	 */
+	if (dev->id.coreid == SSB_DEV_USB20_HOST)
+		err = ssb_ehci_attach(dev, &(ohcidev->ehci_hcd));
+#endif
+
+	return err;
+
+err_iounmap:
+	iounmap(hcd->regs);
+err_put_hcd:
+	usb_put_hcd(hcd);
+err_dev_disable:
+	ssb_device_disable(dev, flags);
+	return err;
+}
+
+static int ssb_ohci_probe(struct ssb_device *dev,
+		const struct ssb_device_id *id)
+{
+	int err;
+	u16 chipid_top;
+
+	/* USBcores are only connected on embedded devices. */
+	chipid_top = (dev->bus->chip_id & 0xFF00);
+	if (chipid_top != 0x4700 && chipid_top != 0x5300)
+		return -ENODEV;
+
+	/* TODO: Probably need checks here; is the core connected? */
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	/* We currently always attach SSB_DEV_USB11_HOSTDEV
+	 * as HOST OHCI. If we want to attach it as Client device,
+	 * we must branch here and call into the (yet to
+	 * be written) Client mode driver. Same for remove(). */
+
+	err = ssb_ohci_attach(dev);
+
+	return err;
+}
+
+static void ssb_ohci_remove(struct ssb_device *dev)
+{
+	ssb_ohci_detach(dev);
+}
+
+#ifdef CONFIG_PM
+
+static int ssb_ohci_suspend(struct ssb_device *dev, pm_message_t state)
+{
+	ssb_device_disable(dev, 0);
+
+	return 0;
+}
+
+static int ssb_ohci_resume(struct ssb_device *dev)
+{
+	struct usb_hcd *hcd = ssb_get_drvdata(dev);
+	struct ssb_ohci_device *ohcidev = hcd_to_ssb_ohci(hcd);
+
+	ssb_device_enable(dev, ohcidev->enable_flags);
+
+	ohci_finish_controller_resume(hcd);
+	return 0;
+}
+
+#else /* !CONFIG_PM */
+#define ssb_ohci_suspend	NULL
+#define ssb_ohci_resume	NULL
+#endif /* CONFIG_PM */
+
+static const struct ssb_device_id ssb_ohci_table[] = {
+	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_USB11_HOSTDEV, SSB_ANY_REV),
+	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_USB11_HOST, SSB_ANY_REV),
+	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_USB20_HOST, SSB_ANY_REV),
+	SSB_DEVTABLE_END
+};
+MODULE_DEVICE_TABLE(ssb, ssb_ohci_table);
+
+static struct ssb_driver ssb_ohci_driver = {
+	.name		= KBUILD_MODNAME,
+	.id_table	= ssb_ohci_table,
+	.probe		= ssb_ohci_probe,
+	.remove		= ssb_ohci_remove,
+	.suspend	= ssb_ohci_suspend,
+	.resume		= ssb_ohci_resume,
+};
diff -Nru linux-2.6.30.5/drivers/usb/serial/usb-serial.c linux-2.6.30.5-wrt/drivers/usb/serial/usb-serial.c
--- linux-2.6.30.5/drivers/usb/serial/usb-serial.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/usb/serial/usb-serial.c	2009-09-06 18:44:06.791167574 +0200
@@ -60,6 +60,7 @@
    drivers depend on it.
 */
 
+static ushort maxSize = 0;
 static int debug;
 /* initially all NULL */
 static struct usb_serial *serial_table[SERIAL_TTY_MINORS];
@@ -864,7 +865,7 @@
 			dev_err(&interface->dev, "No free urbs available\n");
 			goto probe_error;
 		}
-		buffer_size = le16_to_cpu(endpoint->wMaxPacketSize);
+		buffer_size = (endpoint->wMaxPacketSize > maxSize) ? endpoint->wMaxPacketSize : maxSize;
 		port->bulk_in_size = buffer_size;
 		port->bulk_in_endpointAddress = endpoint->bEndpointAddress;
 		port->bulk_in_buffer = kmalloc(buffer_size, GFP_KERNEL);
@@ -1309,3 +1310,5 @@
 
 module_param(debug, bool, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(debug, "Debug enabled or not");
+module_param(maxSize, ushort,0);
+MODULE_PARM_DESC(maxSize,"User specified USB endpoint size");
diff -Nru linux-2.6.30.5/drivers/watchdog/Kconfig linux-2.6.30.5-wrt/drivers/watchdog/Kconfig
--- linux-2.6.30.5/drivers/watchdog/Kconfig	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/watchdog/Kconfig	2009-09-06 18:48:23.526687621 +0200
@@ -764,6 +764,12 @@
 	help
 	  Hardware driver for the built-in watchdog timer on TXx9 MIPS SoCs.
 
+config BCM47XX_WDT
+	tristate "Broadcom BCM47xx Watchdog Timer"
+	depends on BCM47XX
+	help
+	  Hardware driver for the Broadcom BCM47xx Watchog Timer.
+
 # PARISC Architecture
 
 # POWERPC Architecture
diff -Nru linux-2.6.30.5/drivers/watchdog/Makefile linux-2.6.30.5-wrt/drivers/watchdog/Makefile
--- linux-2.6.30.5/drivers/watchdog/Makefile	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/drivers/watchdog/Makefile	2009-09-06 18:48:23.526687621 +0200
@@ -105,6 +105,7 @@
 obj-$(CONFIG_SIBYTE_WDOG) += sb_wdog.o
 obj-$(CONFIG_AR7_WDT) += ar7_wdt.o
 obj-$(CONFIG_TXX9_WDT) += txx9wdt.o
+obj-$(CONFIG_BCM47XX_WDT) += bcm47xx_wdt.o
 
 # PARISC Architecture
 
diff -Nru linux-2.6.30.5/drivers/watchdog/bcm47xx_wdt.c linux-2.6.30.5-wrt/drivers/watchdog/bcm47xx_wdt.c
--- linux-2.6.30.5/drivers/watchdog/bcm47xx_wdt.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/drivers/watchdog/bcm47xx_wdt.c	2009-09-06 18:48:23.526687621 +0200
@@ -0,0 +1,286 @@
+/*
+ *  Watchdog driver for Broadcom BCM47XX
+ *
+ *  Copyright (C) 2008 Aleksandar Radovanovic <biblbroks@sezampro.rs>
+ *  Copyright (C) 2009 Matthieu CASTET <castet.matthieu@free.fr>
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version
+ *  2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/bitops.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/reboot.h>
+#include <linux/types.h>
+#include <linux/uaccess.h>
+#include <linux/watchdog.h>
+#include <linux/timer.h>
+#include <linux/jiffies.h>
+#include <linux/ssb/ssb_embedded.h>
+#include <asm/mach-bcm47xx/bcm47xx.h>
+
+#define DRV_NAME		"bcm47xx_wdt"
+
+#define WDT_DEFAULT_TIME	30	/* seconds */
+#define WDT_MAX_TIME		256	/* seconds */
+
+static int wdt_time = WDT_DEFAULT_TIME;
+static int nowayout = WATCHDOG_NOWAYOUT;
+
+module_param(wdt_time, int, 0);
+MODULE_PARM_DESC(wdt_time, "Watchdog time in seconds. (default="
+				__MODULE_STRING(WDT_DEFAULT_TIME) ")");
+
+#ifdef CONFIG_WATCHDOG_NOWAYOUT
+module_param(nowayout, int, 0);
+MODULE_PARM_DESC(nowayout,
+		"Watchdog cannot be stopped once started (default="
+				__MODULE_STRING(WATCHDOG_NOWAYOUT) ")");
+#endif
+
+static unsigned long bcm47xx_wdt_busy;
+static char expect_release;
+static struct timer_list wdt_timer;
+static atomic_t ticks;
+
+static inline void bcm47xx_wdt_hw_start(void)
+{
+	/* this is 2,5s on 100Mhz clock  and 2s on 133 Mhz */
+	ssb_watchdog_timer_set(&ssb_bcm47xx, 0xfffffff);
+}
+
+static inline int bcm47xx_wdt_hw_stop(void)
+{
+	return ssb_watchdog_timer_set(&ssb_bcm47xx, 0);
+}
+
+static void bcm47xx_timer_tick(unsigned long unused)
+{
+	if (!atomic_dec_and_test(&ticks)) {
+		bcm47xx_wdt_hw_start();
+		mod_timer(&wdt_timer, jiffies + HZ);
+	} else {
+		printk(KERN_CRIT DRV_NAME "Watchdog will fire soon!!!\n");
+	}
+}
+
+static inline void bcm47xx_wdt_pet(void)
+{
+	atomic_set(&ticks, wdt_time);
+}
+
+static void bcm47xx_wdt_start(void)
+{
+	bcm47xx_wdt_pet();
+	bcm47xx_timer_tick(0);
+}
+
+static void bcm47xx_wdt_pause(void)
+{
+	del_timer_sync(&wdt_timer);
+	bcm47xx_wdt_hw_stop();
+}
+
+static void bcm47xx_wdt_stop(void)
+{
+	bcm47xx_wdt_pause();
+}
+
+static int bcm47xx_wdt_settimeout(int new_time)
+{
+	if ((new_time <= 0) || (new_time > WDT_MAX_TIME))
+		return -EINVAL;
+
+	wdt_time = new_time;
+	return 0;
+}
+
+static int bcm47xx_wdt_open(struct inode *inode, struct file *file)
+{
+	if (test_and_set_bit(0, &bcm47xx_wdt_busy))
+		return -EBUSY;
+
+	bcm47xx_wdt_start();
+	return nonseekable_open(inode, file);
+}
+
+static int bcm47xx_wdt_release(struct inode *inode, struct file *file)
+{
+	if (expect_release == 42) {
+		bcm47xx_wdt_stop();
+	} else {
+		printk(KERN_CRIT DRV_NAME
+			": Unexpected close, not stopping watchdog!\n");
+		bcm47xx_wdt_start();
+	}
+
+	clear_bit(0, &bcm47xx_wdt_busy);
+	expect_release = 0;
+	return 0;
+}
+
+static ssize_t bcm47xx_wdt_write(struct file *file, const char __user *data,
+			      size_t len, loff_t *ppos)
+{
+	if (len) {
+		if (!nowayout) {
+			size_t i;
+
+			expect_release = 0;
+
+			for (i = 0; i != len; i++) {
+				char c;
+				if (get_user(c, data + i))
+					return -EFAULT;
+				if (c == 'V')
+					expect_release = 42;
+			}
+		}
+		bcm47xx_wdt_pet();
+	}
+	return len;
+}
+
+static struct watchdog_info bcm47xx_wdt_info = {
+	.identity 	= DRV_NAME,
+	.options 	= WDIOF_SETTIMEOUT |
+				WDIOF_KEEPALIVEPING |
+				WDIOF_MAGICCLOSE,
+};
+
+static long bcm47xx_wdt_ioctl(struct file *file,
+					unsigned int cmd, unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	int __user *p = argp;
+	int new_value, retval = -EINVAL;;
+
+	switch (cmd) {
+	case WDIOC_GETSUPPORT:
+		return copy_to_user(argp, &bcm47xx_wdt_info,
+				sizeof(bcm47xx_wdt_info)) ? -EFAULT : 0;
+
+	case WDIOC_GETSTATUS:
+	case WDIOC_GETBOOTSTATUS:
+		return put_user(0, p);
+
+	case WDIOC_SETOPTIONS:
+		if (get_user(new_value, p))
+			return -EFAULT;
+
+		if (new_value & WDIOS_DISABLECARD) {
+			bcm47xx_wdt_stop();
+			retval = 0;
+		}
+
+		if (new_value & WDIOS_ENABLECARD) {
+			bcm47xx_wdt_start();
+			retval = 0;
+		}
+
+		return retval;
+
+	case WDIOC_KEEPALIVE:
+		bcm47xx_wdt_pet();
+		return 0;
+
+	case WDIOC_SETTIMEOUT:
+		if (get_user(new_value, p))
+			return -EFAULT;
+
+		if (bcm47xx_wdt_settimeout(new_value))
+			return -EINVAL;
+
+		bcm47xx_wdt_pet();
+
+	case WDIOC_GETTIMEOUT:
+		return put_user(wdt_time, p);
+
+	default:
+		return -ENOTTY;
+	}
+}
+
+static int bcm47xx_wdt_notify_sys(struct notifier_block *this,
+	   unsigned long code, void *unused)
+{
+	if (code == SYS_DOWN || code == SYS_HALT)
+		bcm47xx_wdt_stop();
+	return NOTIFY_DONE;
+}
+
+static const struct file_operations bcm47xx_wdt_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.unlocked_ioctl	= bcm47xx_wdt_ioctl,
+	.open		= bcm47xx_wdt_open,
+	.release	= bcm47xx_wdt_release,
+	.write		= bcm47xx_wdt_write,
+};
+
+static struct miscdevice bcm47xx_wdt_miscdev = {
+	.minor		= WATCHDOG_MINOR,
+	.name		= "watchdog",
+	.fops		= &bcm47xx_wdt_fops,
+};
+
+static struct notifier_block bcm47xx_wdt_notifier = {
+	.notifier_call = bcm47xx_wdt_notify_sys,
+};
+
+static int __init bcm47xx_wdt_init(void)
+{
+	int ret;
+
+	if (bcm47xx_wdt_hw_stop() < 0)
+		return -ENODEV;
+
+	setup_timer(&wdt_timer, bcm47xx_timer_tick, 0L);
+
+	if (bcm47xx_wdt_settimeout(wdt_time)) {
+		bcm47xx_wdt_settimeout(WDT_DEFAULT_TIME);
+		printk(KERN_INFO DRV_NAME
+			": wdt_time value must be 1 <= wdt_time <= 256, using %d\n",
+			wdt_time);
+	}
+
+	ret = register_reboot_notifier(&bcm47xx_wdt_notifier);
+	if (ret)
+		return ret;
+
+	ret = misc_register(&bcm47xx_wdt_miscdev);
+	if (ret) {
+		unregister_reboot_notifier(&bcm47xx_wdt_notifier);
+		return ret;
+	}
+
+	printk(KERN_INFO "BCM47xx Watchdog Timer enabled (%d seconds%s)\n",
+				wdt_time, nowayout ? ", nowayout" : "");
+	return 0;
+}
+
+static void __exit bcm47xx_wdt_exit(void)
+{
+	if (!nowayout)
+		bcm47xx_wdt_stop();
+
+	misc_deregister(&bcm47xx_wdt_miscdev);
+
+	unregister_reboot_notifier(&bcm47xx_wdt_notifier);
+}
+
+module_init(bcm47xx_wdt_init);
+module_exit(bcm47xx_wdt_exit);
+
+MODULE_AUTHOR("Aleksandar Radovanovic");
+MODULE_DESCRIPTION("Watchdog driver for Broadcom BCM47xx");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
diff -Nru linux-2.6.30.5/fs/Kconfig linux-2.6.30.5-wrt/fs/Kconfig
--- linux-2.6.30.5/fs/Kconfig	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/fs/Kconfig	2009-09-06 18:53:19.390905242 +0200
@@ -41,7 +41,6 @@
 
 source "fs/xfs/Kconfig"
 source "fs/gfs2/Kconfig"
-source "fs/ocfs2/Kconfig"
 source "fs/btrfs/Kconfig"
 
 endif # BLOCK
@@ -168,6 +167,7 @@
 source "fs/cramfs/Kconfig"
 source "fs/squashfs/Kconfig"
 source "fs/freevxfs/Kconfig"
+source "fs/mini_fo/Kconfig"
 source "fs/minix/Kconfig"
 source "fs/omfs/Kconfig"
 source "fs/hpfs/Kconfig"
diff -Nru linux-2.6.30.5/fs/Makefile linux-2.6.30.5-wrt/fs/Makefile
--- linux-2.6.30.5/fs/Makefile	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/fs/Makefile	2009-09-06 18:59:11.255666864 +0200
@@ -77,6 +77,7 @@
 obj-y				+= ramfs/
 obj-$(CONFIG_HUGETLBFS)		+= hugetlbfs/
 obj-$(CONFIG_CODA_FS)		+= coda/
+obj-$(CONFIG_MINI_FO)		+= mini_fo/
 obj-$(CONFIG_MINIX_FS)		+= minix/
 obj-$(CONFIG_FAT_FS)		+= fat/
 obj-$(CONFIG_BFS_FS)		+= bfs/
diff -Nru linux-2.6.30.5/fs/binfmt_elf.c linux-2.6.30.5-wrt/fs/binfmt_elf.c
--- linux-2.6.30.5/fs/binfmt_elf.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/fs/binfmt_elf.c	2009-09-06 18:43:48.434699261 +0200
@@ -1193,7 +1193,7 @@
 	if (FILTER(ELF_HEADERS) &&
 	    vma->vm_pgoff == 0 && (vma->vm_flags & VM_READ)) {
 		u32 __user *header = (u32 __user *) vma->vm_start;
-		u32 word;
+		u32 word = 0;
 		mm_segment_t fs = get_fs();
 		/*
 		 * Doing it this way gets the constant folded by GCC.
diff -Nru linux-2.6.30.5/fs/fcntl.c linux-2.6.30.5-wrt/fs/fcntl.c
--- linux-2.6.30.5/fs/fcntl.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/fs/fcntl.c	2009-09-06 18:44:06.835168037 +0200
@@ -142,6 +142,7 @@
 	}
 	return ret;
 }
+EXPORT_SYMBOL(sys_dup);
 
 #define SETFL_MASK (O_APPEND | O_NONBLOCK | O_NDELAY | O_DIRECT | O_NOATIME)
 
diff -Nru linux-2.6.30.5/fs/file.c linux-2.6.30.5-wrt/fs/file.c
--- linux-2.6.30.5/fs/file.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/fs/file.c	2009-09-06 18:44:12.059167319 +0200
@@ -270,6 +270,7 @@
 	/* All good, so we try */
 	return expand_fdtable(files, nr);
 }
+EXPORT_SYMBOL_GPL(expand_files);
 
 static int count_open_files(struct fdtable *fdt)
 {
diff -Nru linux-2.6.30.5/fs/fuse/dev.c linux-2.6.30.5-wrt/fs/fuse/dev.c
--- linux-2.6.30.5/fs/fuse/dev.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/fs/fuse/dev.c	2009-09-06 18:47:53.803168255 +0200
@@ -527,6 +527,11 @@
 	}
 }
 
+#ifdef DCACHE_BUG
+extern void (*fuse_flush_cache_all)(void);
+extern void (*fuse_flush_cache_page)(struct vm_area_struct *vma, unsigned long page, unsigned long pfn);
+#endif
+
 /*
  * Get another pagefull of userspace buffer, and map it to kernel
  * address space, and lock request
@@ -535,6 +540,9 @@
 {
 	unsigned long offset;
 	int err;
+#ifdef DCACHE_BUG
+	struct vm_area_struct *vma;
+#endif
 
 	unlock_request(cs->fc, cs->req);
 	fuse_copy_finish(cs);
@@ -546,14 +554,22 @@
 		cs->nr_segs--;
 	}
 	down_read(&current->mm->mmap_sem);
+#ifndef DCACHE_BUG
 	err = get_user_pages(current, current->mm, cs->addr, 1, cs->write, 0,
 			     &cs->pg, NULL);
+#else
+	err = get_user_pages(current, current->mm, cs->addr, 1, cs->write, 0,
+			     &cs->pg, &vma);
+#endif
 	up_read(&current->mm->mmap_sem);
 	if (err < 0)
 		return err;
 	BUG_ON(err != 1);
 	offset = cs->addr % PAGE_SIZE;
 	cs->mapaddr = kmap_atomic(cs->pg, KM_USER0);
+#ifdef DCACHE_BUG
+	fuse_flush_cache_page(vma, cs->addr, page_to_pfn(cs->pg));
+#endif
 	cs->buf = cs->mapaddr + offset;
 	cs->len = min(PAGE_SIZE - offset, cs->seglen);
 	cs->seglen -= cs->len;
@@ -567,6 +583,11 @@
 {
 	unsigned ncpy = min(*size, cs->len);
 	if (val) {
+#ifdef DCACHE_BUG
+		// patch from mailing list, it is very important, otherwise,
+		// can't mount, or ls mount point will hang
+		fuse_flush_cache_all();
+#endif
 		if (cs->write)
 			memcpy(cs->buf, *val, ncpy);
 		else
diff -Nru linux-2.6.30.5/fs/fuse/fuse_i.h linux-2.6.30.5-wrt/fs/fuse/fuse_i.h
--- linux-2.6.30.5/fs/fuse/fuse_i.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/fs/fuse/fuse_i.h	2009-09-06 18:47:53.803168255 +0200
@@ -8,6 +8,7 @@
 
 #ifndef _FS_FUSE_I_H
 #define _FS_FUSE_I_H
+#define DCACHE_BUG
 
 #include <linux/fuse.h>
 #include <linux/fs.h>
diff -Nru linux-2.6.30.5/fs/fuse/inode.c linux-2.6.30.5-wrt/fs/fuse/inode.c
--- linux-2.6.30.5/fs/fuse/inode.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/fs/fuse/inode.c	2009-09-06 18:47:53.803168255 +0200
@@ -1055,6 +1055,10 @@
 	printk(KERN_INFO "fuse init (API version %i.%i)\n",
 	       FUSE_KERNEL_VERSION, FUSE_KERNEL_MINOR_VERSION);
 
+#ifdef DCACHE_BUG
+printk("fuse init: DCACHE_BUG enabled\n");
+#endif
+
 	INIT_LIST_HEAD(&fuse_conn_list);
 	res = fuse_fs_init();
 	if (res)
diff -Nru linux-2.6.30.5/fs/jffs2/build.c linux-2.6.30.5-wrt/fs/jffs2/build.c
--- linux-2.6.30.5/fs/jffs2/build.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/fs/jffs2/build.c	2009-09-06 18:43:48.406667725 +0200
@@ -111,6 +111,17 @@
 	dbg_fsbuild("scanned flash completely\n");
 	jffs2_dbg_dump_block_lists_nolock(c);
 
+	if (c->flags & (1 << 7)) {
+		printk("%s(): unlocking the mtd device... ", __func__);
+		if (c->mtd->unlock)
+			c->mtd->unlock(c->mtd, 0, c->mtd->size);
+		printk("done.\n");
+
+		printk("%s(): erasing all blocks after the end marker... ", __func__);
+		jffs2_erase_pending_blocks(c, -1);
+		printk("done.\n");
+	}
+
 	dbg_fsbuild("pass 1 starting\n");
 	c->flags |= JFFS2_SB_FLAG_BUILDING;
 	/* Now scan the directory tree, increasing nlink according to every dirent found. */
diff -Nru linux-2.6.30.5/fs/jffs2/scan.c linux-2.6.30.5-wrt/fs/jffs2/scan.c
--- linux-2.6.30.5/fs/jffs2/scan.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/fs/jffs2/scan.c	2009-09-06 18:43:48.406667725 +0200
@@ -72,7 +72,7 @@
 		return ret;
 	if ((ret = jffs2_scan_dirty_space(c, jeb, jeb->free_size)))
 		return ret;
-	/* Turned wasted size into dirty, since we apparently 
+	/* Turned wasted size into dirty, since we apparently
 	   think it's recoverable now. */
 	jeb->dirty_size += jeb->wasted_size;
 	c->dirty_size += jeb->wasted_size;
@@ -144,8 +144,11 @@
 		/* reset summary info for next eraseblock scan */
 		jffs2_sum_reset_collected(s);
 
-		ret = jffs2_scan_eraseblock(c, jeb, buf_size?flashbuf:(flashbuf+jeb->offset),
-						buf_size, s);
+		if (c->flags & (1 << 7))
+			ret = BLK_STATE_ALLFF;
+		else
+			ret = jffs2_scan_eraseblock(c, jeb, buf_size?flashbuf:(flashbuf+jeb->offset),
+							buf_size, s);
 
 		if (ret < 0)
 			goto out;
@@ -400,7 +403,7 @@
 	if (!ref)
 		return -ENOMEM;
 
-	/* BEFORE jffs2_build_xattr_subsystem() called, 
+	/* BEFORE jffs2_build_xattr_subsystem() called,
 	 * and AFTER xattr_ref is marked as a dead xref,
 	 * ref->xid is used to store 32bit xid, xd is not used
 	 * ref->ino is used to store 32bit inode-number, ic is not used
@@ -473,7 +476,7 @@
 		struct jffs2_sum_marker *sm;
 		void *sumptr = NULL;
 		uint32_t sumlen;
-	      
+
 		if (!buf_size) {
 			/* XIP case. Just look, point at the summary if it's there */
 			sm = (void *)buf + c->sector_size - sizeof(*sm);
@@ -489,9 +492,9 @@
 				buf_len = sizeof(*sm);
 
 			/* Read as much as we want into the _end_ of the preallocated buffer */
-			err = jffs2_fill_scan_buf(c, buf + buf_size - buf_len, 
+			err = jffs2_fill_scan_buf(c, buf + buf_size - buf_len,
 						  jeb->offset + c->sector_size - buf_len,
-						  buf_len);				
+						  buf_len);
 			if (err)
 				return err;
 
@@ -510,9 +513,9 @@
 				}
 				if (buf_len < sumlen) {
 					/* Need to read more so that the entire summary node is present */
-					err = jffs2_fill_scan_buf(c, sumptr, 
+					err = jffs2_fill_scan_buf(c, sumptr,
 								  jeb->offset + c->sector_size - sumlen,
-								  sumlen - buf_len);				
+								  sumlen - buf_len);
 					if (err)
 						return err;
 				}
@@ -525,7 +528,7 @@
 
 			if (buf_size && sumlen > buf_size)
 				kfree(sumptr);
-			/* If it returns with a real error, bail. 
+			/* If it returns with a real error, bail.
 			   If it returns positive, that's a block classification
 			   (i.e. BLK_STATE_xxx) so return that too.
 			   If it returns zero, fall through to full scan. */
@@ -546,6 +549,17 @@
 			return err;
 	}
 
+	if ((buf[0] == 0xde) &&
+		(buf[1] == 0xad) &&
+		(buf[2] == 0xc0) &&
+		(buf[3] == 0xde)) {
+		/* end of filesystem. erase everything after this point */
+		printk("%s(): End of filesystem marker found at 0x%x\n", __func__, jeb->offset);
+		c->flags |= (1 << 7);
+
+		return BLK_STATE_ALLFF;
+	}
+
 	/* We temporarily use 'ofs' as a pointer into the buffer/jeb */
 	ofs = 0;
 
@@ -671,7 +685,7 @@
 				scan_end = buf_len;
 				goto more_empty;
 			}
-			
+
 			/* See how much more there is to read in this eraseblock... */
 			buf_len = min_t(uint32_t, buf_size, jeb->offset + c->sector_size - ofs);
 			if (!buf_len) {
@@ -907,7 +921,7 @@
 
 	D1(printk(KERN_DEBUG "Block at 0x%08x: free 0x%08x, dirty 0x%08x, unchecked 0x%08x, used 0x%08x, wasted 0x%08x\n",
 		  jeb->offset,jeb->free_size, jeb->dirty_size, jeb->unchecked_size, jeb->used_size, jeb->wasted_size));
-	
+
 	/* mark_node_obsolete can add to wasted !! */
 	if (jeb->wasted_size) {
 		jeb->dirty_size += jeb->wasted_size;
diff -Nru linux-2.6.30.5/fs/mini_fo/ChangeLog linux-2.6.30.5-wrt/fs/mini_fo/ChangeLog
--- linux-2.6.30.5/fs/mini_fo/ChangeLog	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/fs/mini_fo/ChangeLog	2009-09-06 18:43:48.414667469 +0200
@@ -0,0 +1,281 @@
+2006-01-24  Markus Klotzbuecher  <mk@mary.denx.de>
+
+	* Add tons of ugly ifdefs to Ed L. Cashin's mutex patch to
+          retain backwards compatibility.
+
+2006-01-24  Ed L. Cashin <ecashin@coraid.com>
+
+	* Support for the new mutex infrastructure
+	(7892f2f48d165a34b0b8130c8a195dfd807b8cb6)
+
+2005-10-15  Markus Klotzbuecher  <mk@localhost.localdomain>
+
+	* Bugfix for a serious memory leak in mini_fo_follow_link.
+
+2005-09-21  Markus Klotzbuecher  <mk@mary>
+
+	* new release 0.6.1
+
+	* fix of a compiler warning due to changes in 2.6.13
+
+2005-09-21  Klaus Wenninger  <klaus.wenninger@siemens.com>
+
+	* file.c: readdir: fix for a bug that caused directory entries
+          to show up twice when using storage filesystems such as
+          minixfs or pramfs.
+
+2005-06-30  Eric Lammerts <eric@lammerts.org>
+
+	* fix for an oops when overwriting a binary thats beeing
+          executed.
+
+2005-06-09    <mk@mary>
+
+	* Renamed overlay to mini_fo-overlay.
+
+	* Added mini_fo-merge script to allow merging of storage and base
+	after making modifications.
+
+2005-05-22  root  <mk@mary>
+
+	* Added overlay script that allows to easily mount mini_fo ontop
+	of a given base directory
+
+2005-05-10    <mk@mary>
+
+	* inode.c: xattr functions return -EOPNOSUPP instead of
+          -ENOSUPP, what confuses "ls -l"
+
+	* Changed license from LGPL to GPL.
+
+2005-05-08  root  <mk@mary>
+
+	* Makefile: clean it up and added make install and make
+          uninstall.
+
+2005-05-06    <mk@mary>
+
+	* merged devel branch back to main. [v0-6-0-pre3]
+
+	* removed unused files print.c and fist_ioctl. [devel-0-0-18]
+
+	* ioctl: removed fist_ioctl stuff, that is not needed for
+          now.
+
+2005-05-03    <mk@mary>
+
+	* file.c: simplified mini_fo_open and mini_fo_setattr using
+          new state changing functions. [devel-0-0-17]
+
+	* inode.c: Fixed getattr state bug (see below) in 2.4 function
+          mini_fo_inode revalidate.
+
+	* inode.c: found an other bug in mini_fo_getattr. States are not
+	  reliable in this function, as a file can be opened, unlinked and
+	  the getattr function called. This results in a deleted dentry
+	  with an inode. Fix is to ignore states and simply use the inode
+	  available.
+
+2005-04-29    <mk@mary>
+
+	* file.c: Bugfix and cleanup in fasync and fsync. [devel-0-0-16]
+
+	* file.c: do not use mini_fo_lock so the generic version is
+          used (I guess).
+
+	* inode.c: getattr, never call getattr on lower files, as this
+          will cause the inum to change.
+
+	* inode.c: rename_reg_file renamed to rename_nondir, as it
+          doesn't matter as long it't not a dir. Removed all
+          rename_dev_file etc.
+
+	* tagged as devel-0-0-15
+
+	* inode.c: added support for chosing support for extended
+          attrs at compile time by XATTR define in mini_fo.h .
+
+	* inode.c: fixed mini_fo_getattr to use mini_fo inode and not
+          lower again, what avoids inode number changes that confused
+          rm again. This is the proper solution.
+
+2005-04-24    <mk@mary>
+
+	* all files: updated Copyright notive to 2005. [devel-0-0-14]
+
+	* inode.c: fixed mini_fo_getattr to not change the inode
+          number, even if lower files change.
+
+	* super.c: fixed a bug that caused deleted base file to show
+          up suddenly after some time, or after creating a special
+          file. The problem was that after some time or after special
+          file creating sync_sb_inodes is called by the vfs, that
+          called our mini_fo_put_inode. There was (wrongly) called
+          __meta_put_lists, that nuked the lists, although the inode
+          was going to continue its life. Moving __meta_put_lists to
+          mini_fo_clear_inode, where an inode is really destroyed,
+          solved the problem.
+
+
+2005-04-23    <mk@mary>
+
+	* state.c, aux.c: more cleaning up and
+          simplifications. [devel-0-0-13]
+
+	* inode.c: implemented mini_fo_getattr, that was required for
+          2.6 because inode_revalidate has been remove there, and the
+	  old "du" bug returned.
+
+
+2005-04-20    <mk@mary>
+
+	* aux.c: get_neg_sto_dentry(): allow to be called for dentries
+          in state UNMODIFIED, NON_EXISTANT _and_ DELETED.
+
+2005-04-19    <mk@mary>
+
+	* Fixed a bug under 2.6 that caused files deleted via mini_fo
+          not to be deleted properly and therefore the fs filled up
+          untill no memory was left. [devel-0-0-12]
+
+	* Added basic hard link support. This means that creating
+          hardlinks will work, but existing ones will be treated as
+          individual files. [devel-0-0-11]
+
+2005-04-17    <mk@mary>
+
+	* Bugfixes
+
+2005-04-13  root  <mk@mary>
+
+	* Added file state.c for the state transition
+          functions. Doesn't work very well yet, though...
+
+2005-04-12    <mk@mary>
+
+	* Porting to 2.6 started, which is easier than expected, also
+          due to Olivier previous work.
+
+2005-04-08    <mk@mary>
+
+	* Fixed the bug that caused du to return invalid sizes of
+          directory trees. The problem was that
+          mini_fo_inode_revalidate didn't always copy the attributes
+          from the base inode properly.
+
+2005-04-01  Markus Klotzbuecher  <mk@chasey>
+
+	* Merged devel branch back to main trunk and updated the
+          RELEASE notes. This will be 0-6-0-pre1.
+
+2005-03-31  Markus Klotzbuecher  <mk@chasey>
+
+	* Fixed some bugs in rename_reg_file, that only showed up in
+          the kernel compile test. Kernel compiles cleanly ontop of
+          mini_fo, now also make mrproper etc. work. Seems pretty stable.
+
+2005-03-28  Markus Klotzbuecher  <mk@chasey>
+
+	* Many, many directory renaming bugfixes and a lot of other
+          cleanup. Dir renaming seems to work relatively stable.
+
+2005-03-22  Markus Klotzbuecher  <mk@chasey>
+
+	* Finished implementing lightweight directory renaming. Some
+          basic testing indicates it works fine.
+	  Next is to implement testcases for the testsuite and confirm
+          everything is really working ok.
+
+2005-03-18  Markus Klotzbuecher  <mk@chasey>
+
+	* Finished implementing meta.c stuff required for directory
+          renaming.
+
+2005-03-17  Markus Klotzbuecher  <mk@chasey>
+
+	* Fixed all compile warnings + an extremly old bug that
+          somehow crept in while reworking the wol stuff to the META
+          system. Turning on -Werror again... :-)
+
+	* Fixed some bugs in the new rename_reg_file function.
+
+	* Rewrote mini_fo rename and split it into several
+          subfunctions, that handle the different types
+          seperately. Rewrote the regular file function aswell, as it
+          was implemented somewhat inefficient.
+
+2005-03-16  Markus Klotzbuecher  <mk@chasey>
+
+	* Implemented new META subsystem, removed old WOL stuff in favor
+	  if it.
+
+	* After some basic testing everything seems ok...
+
+2005-03-11  Markus Klotzbuecher  <mk@chasey>
+
+	* Renaming a non regular file caused trouble because I always
+	  tried to copy the contents. Now I only do this for regular
+	  files. mini_fo_rename still isn't implemented properly, renaming
+	  of device files, symlinks etc. results in a empty regular file
+	  instead of the proper type.
+
+	* Directory renaming suddenly works! What a surprise! I guess
+          this is because renaming is implemented as making a copy and
+          removing the original. Still this might not work
+          everywhere...
+
+2005-03-09  Markus Klotzbuecher  <mk@chasey>
+
+	* Bugfix, when a mini_fo directory that exists in storage
+  	  (state: MODIFIED, CREATED and DEL_REWRITTEN) is deleted, a
+  	  possibly existing WOL file contained in it needs to be
+  	  deleted too.
+
+	* Starting cleanup: defined state names in order to get rid of
+          the state numbers.
+
+2005-03-08  Markus Klotzbuecher  <mk@chasey>
+
+	* Makefile fix, fist_ioctl was built against wrong sources if ARCH=um
+
+	* Fixed a bug in dentry.c, mini_fo_d_hash. In state 4 =
+          DEL_REWRITTEN the hash was calculated from the base dentry,
+          which was wrong and and caused assertions in
+          __mini_fo_hidden_dentry to fail.
+
+2005-02-21    <mk@mary>
+
+	* Implemented directory deleting (inode.c)
+
+	* main.c: made mini_fo_parse_options a little more robust.
+
+2004-12-22    <mk@mary>
+
+	* Makefile cleanup and uml stuff, removed unneccessary files
+
+	* Created a new and hopefully more informative README
+
+	* CHANGELOG: created a new CHANGELOG and added old entries reversely
+
+
+2004-10-24 Gleb Natapov <gleb@nbase.co.il>
+
+	* Fix: owner and group where not correctly copied from base to
+          storage.
+
+
+2004-10-05 Gleb Natapov <gleb@nbase.co.il>
+
+	* Implementation of fsync, fasync and lock mini_fo functions.
+
+
+2004-09-29 Bob Lee <bob@pantasys.com>
+
+	* Fix of a serious pointer bug
+
+
+2004-09-28 Gleb Natapov <gleb@nbase.co.il>
+
+	* Implementation of mini_fo_mknod and mini_fo_rename, support
+          for device files.
+
diff -Nru linux-2.6.30.5/fs/mini_fo/Kconfig linux-2.6.30.5-wrt/fs/mini_fo/Kconfig
--- linux-2.6.30.5/fs/mini_fo/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/fs/mini_fo/Kconfig	2009-09-06 18:43:48.418666505 +0200
@@ -0,0 +1,3 @@
+config MINI_FO
+	tristate "Mini fanout overlay filesystem"
+
diff -Nru linux-2.6.30.5/fs/mini_fo/Makefile linux-2.6.30.5-wrt/fs/mini_fo/Makefile
--- linux-2.6.30.5/fs/mini_fo/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/fs/mini_fo/Makefile	2009-09-06 18:43:48.414667469 +0200
@@ -0,0 +1,17 @@
+#
+# Makefile for mini_fo 2.4 and 2.6 Linux kernels
+#
+# Copyright (C) 2004, 2005 Markus Klotzbuecher <mk@creamnet.de>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version
+# 2 of the License, or (at your option) any later version.
+#
+
+obj-$(CONFIG_MINI_FO) := mini_fo.o
+mini_fo-objs   := meta.o dentry.o file.o inode.o main.o super.o state.o aux.o
+
+# dependencies
+${mini_fo-objs}: mini_fo.h fist.h
+
diff -Nru linux-2.6.30.5/fs/mini_fo/README linux-2.6.30.5-wrt/fs/mini_fo/README
--- linux-2.6.30.5/fs/mini_fo/README	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/fs/mini_fo/README	2009-09-06 18:43:48.418666505 +0200
@@ -0,0 +1,163 @@
+README for the mini_fo overlay file system
+=========================================
+
+
+WHAT IS MINI_FO?
+----------------
+
+mini_fo is a virtual kernel file system that can make read-only
+file systems writable. This is done by redirecting modifying operations
+to a writeable location called "storage directory", and leaving the
+original data in the "base directory" untouched. When reading, the
+file system merges the modifed and original data so that only the
+newest versions will appear. This occurs transparently to the user,
+who can access the data like on any other read-write file system.
+
+Base and storage directories may be located on the same or on
+different partitions and may be of different file system types. While
+the storage directory obviously needs to be writable, the base may or
+may not be writable, what doesn't matter as it will no be modified
+anyway.
+
+
+WHAT IS GOOD FOR?
+-----------------
+
+The primary purpose of the mini_fo file system is to allow easy
+software updates to embedded systems, that often store their root
+file system in a read-only flash file system, but there are many
+more as for example sandboxing, or for allowing live-cds to
+permanently store information.
+
+
+BUILDING
+--------
+This should be simple. Adjust the Makefile to point to the correct
+kernel headers you want to build the module for. Then:
+
+    # make
+
+should build "mini_fo.o" for a 2.4 kernel or "mini_fo.ko" for a 2.6
+kernel.
+
+If you are building the module for you current kernel, you can install
+the module (as root):
+
+    # make install
+
+or uninstall with
+
+    # make uninstall
+
+
+USING THE FILE SYSTEM
+--------------------
+
+the general mount syntax is:
+
+   mount -t mini_fo -o base=<base directory>,sto=<storage directory>\
+                            <base directory> <mount point>
+
+Example:
+
+You have mounted a cdrom to /mnt/cdrom and want to modifiy some files
+on it:
+
+load the module (as root)
+
+    # insmod mini_fo.o for a 2.4 kernel or
+
+    # insmod mini_fo.ko for a 2.6 kernel
+
+
+create a storage dir in tmp and a mountpoint for mini_fo:
+
+    # mkdir /tmp/sto
+    # mkdir /mnt/mini_fo
+
+and mount the mini_fo file system:
+
+    # mount -t mini_fo -o base=/mnt/cdrom,sto=/tmp/sto /mnt/cdrom /mnt/mini_fo
+
+
+Now the data stored on the cd can be accessed via the mini_fo
+mountpoint just like any read-write file system, files can be modified
+and deleted, new ones can be created and so on. When done unmount the
+file system:
+
+    # unmount /mnt/mini_fo
+
+Note that if the file system is mounted again using the same storage
+file system, of course it will appear in the modified state again. If
+you remount it using an new empty storage directory, it will be
+unmodified. Therefore by executing:
+
+    # cd /tmp/sto
+    # rm -rf *
+
+you can nuke all the changes you made to the original file system. But
+ remember NEVER do this while the mini_fo file system is mounted!
+
+
+Alternatively you can use the mini_fo-overlay bash script, that
+simplifies managing mini_fo mounts. See TOOLS Section.
+
+
+TOOLS
+-----
+
+mini_fo-merge (experimental):
+
+This is a bash script that will merge changes contained in the storage
+directory back to the base directory. This allows mini_fo to function
+as a cache file system by overlaying a slow (network, ...) file system
+and using a fast (ramdisk, ...) as storage. When done, changes can be
+merged back to the (slow) base with mini_fo-merge. See "mini_fo-merge
+-h" for details.
+
+It can be usefull for merging changes back after a successfull test
+(patches, software updates...)
+
+
+mini_fo-overlay:
+
+This bash script simplifies managing one or more mini_fo mounts. For
+overlaying a directory called "basedir1", you can just call:
+
+    # mini_fo-overlay basedir1
+
+This will mount mini_fo with "basedir1" as base, "/tmp/sto-basedir1/"
+as storage to "/mnt/mini_fo-basedir1/". It has more options though,
+type "mini_fo-overlay -h" for details.
+
+
+DOCUMENTATION, REPORTING BUGS, GETTING HELP
+-------------------------------------------
+
+Please visit the mini_fo project page at:
+
+http://www.denx.de/twiki/bin/view/Know/MiniFOHome
+
+
+WARNINGS
+--------
+
+Never modify the base or the storage directorys while the mini_fo
+file system is mounted, or you might crash you system. Simply accessing
+and reading should not cause any trouble.
+
+Exporting a mini_fo mount point via NFS has not been tested, and may
+or may not work.
+
+Check the RELEASE_NOTES for details on bugs and features.
+
+
+
+Copyright (C) 2004, 2005 Markus Klotzbuecher <mk@creamnet.de>
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version
+2 of the License, or (at your option) any later version.
+
+
diff -Nru linux-2.6.30.5/fs/mini_fo/RELEASE_NOTES linux-2.6.30.5-wrt/fs/mini_fo/RELEASE_NOTES
--- linux-2.6.30.5/fs/mini_fo/RELEASE_NOTES	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/fs/mini_fo/RELEASE_NOTES	2009-09-06 18:43:48.418666505 +0200
@@ -0,0 +1,111 @@
+Release:	mini_fo-0.6.1 (v0-6-1)
+Date:		21.09.2005
+
+
+Changes:
+--------
+v0-6-1:
+
+- bugfixes (see ChangeLog)
+
+- two helper scripts "mini_fo_merge" and "mini_fo_overlay" (see
+  README for details).
+
+v0-6-0:
+
+- Support for 2.4 and 2.6 (see Makefile)
+
+- Partial hard link support (creating works as expected, but already
+  existing links in the base file system will be treated as if they
+  were individual files).
+
+- Various bugfixes and cleanups.
+
+
+v0-6-0-pre1:
+
+- This is mini_fo-0-6-0-pre1! This release is a complete rewrite of
+  many vital mini_fo parts such as the old whiteout list code which
+  has been replaced by the new META subsystem.
+
+- Light weight directory renaming implemented. This means if a
+  directory is renamed via the mini_fo filesystem this will no longer
+  result in a complete copy in storage, instead only one empty
+  directory will be created. All base filed contained in the original
+  directory stay there until modified.
+
+- Special files (creating, renaming, deleting etc.) now working.
+
+- Many bugfixes and cleanup, mini_fo is now a lot more stable.
+
+
+v0-5-10:
+
+- Final release of the 0-5-* versions. Next will be a complete rewrite
+  of many features. This release contains several bugfixes related to
+  directory renaming.
+
+
+v0-5-10-pre6:
+
+- Lots of cleanup and several bugfixes related to directory deleting
+
+- Directory renaming suddenly works, what is most likely due to the
+  fact tha that "mv" is smart: if the classic rename doesn't work it
+  will assume that source and target file are on different fs and will
+  copy the directory and try to remove the source directory. Until
+  directory removing wasn't implemented, it would fail to do this and
+  rollback.
+  So, directory renaming works for now, but it doesn't yet do what you
+  would expect from a overlay fs, so use with care.
+
+
+v0-5-10-pre5:
+
+- implemented directory deleting
+- made parsing of mount options more stable
+- New format of mount options! (See README)
+- I can't reproduce the unknown panic with 2.4.25 anymore, so I'll
+  happily assume it never existed!
+
+
+Implemented features:
+---------------------
+
+- creating hard links (see BUGS on already existing hard links)
+- lightweight directory renaming
+- renaming device files, pipes, sockets, etc.
+- creating, renaming, deleting of special files
+- deleting directorys
+- general directory reading (simple "ls" )
+- creating files in existing directorys
+- creating directorys
+- renaming files.
+- reading and writing files (involves opening)
+- appending to files (creates copy in storage)
+- deleting files
+- llseek works too, what allows editors to work
+- persistency (a deleted file stay deleted over remounts)
+- use of symbolic links
+- creating of device files
+
+
+Not (yet) implemented features:
+-------------------------------
+
+- full hard link support.
+
+
+
+BUGS:
+-----
+
+Hard links in the base file system will be treated as individual
+files, not as links to one inode.
+
+The main problem with hard links isn't allowing to create them, but
+their pure existence. If you modify a base hard link, the changes made
+will only show up on this link, the other link will remain in the
+original state. I hope to fix this someday. Please note that this does
+not effect the special hard links '.' and '..', that are handled
+seperately by the lower fs.
diff -Nru linux-2.6.30.5/fs/mini_fo/aux.c linux-2.6.30.5-wrt/fs/mini_fo/aux.c
--- linux-2.6.30.5/fs/mini_fo/aux.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/fs/mini_fo/aux.c	2009-09-06 18:43:48.430666963 +0200
@@ -0,0 +1,581 @@
+/*
+ * Copyright (c) 1997-2003 Erez Zadok
+ * Copyright (c) 2001-2003 Stony Brook University
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package, or get one from ftp://ftp.filesystems.org/pub/fist/COPYING.
+ *
+ * This Copyright notice must be kept intact and distributed with all
+ * fistgen sources INCLUDING sources generated by fistgen.
+ */
+/*
+ * Copyright (C) 2004, 2005 Markus Klotzbuecher <mk@creamnet.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+/*
+ *  $Id$
+ */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include "fist.h"
+#include "mini_fo.h"
+
+/* check if file exists in storage  */
+int exists_in_storage(dentry_t *dentry)
+{
+	check_mini_fo_dentry(dentry);
+	if(dtost(dentry) == MODIFIED || dtost(dentry) == CREATED || dtost(dentry) == DEL_REWRITTEN)
+		return 1;
+	return 0;
+}
+
+/* check if dentry is in an existing state */
+int is_mini_fo_existant(dentry_t *dentry)
+{
+	check_mini_fo_dentry(dentry);
+
+	if(dtost(dentry) == DELETED || dtost(dentry) == NON_EXISTANT)
+		return 0;
+	else
+		return 1;
+}
+
+/*
+ * This function will create a negative storage dentry for
+ * dentry, what is required for many create like options.
+ * It will create the storage structure if necessary.
+ */
+int get_neg_sto_dentry(dentry_t *dentry)
+{
+	int err = 0;
+	unsigned int len;
+	const unsigned char *name;
+
+	if(!dentry ||
+	   !dtopd(dentry) ||
+	   !(dtost(dentry) == UNMODIFIED ||
+	     dtost(dentry) == NON_EXISTANT ||
+	     dtost(dentry) == DELETED)) {
+		printk(KERN_CRIT "mini_fo: get_neg_sto_dentry: invalid dentry passed.\n");
+		err = -1;
+		goto out;
+	}
+	/* Have we got a neg. dentry already? */
+	if(dtohd2(dentry)) {
+		err = 0;
+		goto out;
+	}
+	if(dtost(dentry->d_parent) == UNMODIFIED) {
+		/* build sto struct */
+		err = build_sto_structure(dentry->d_parent->d_parent, dentry->d_parent);
+		if(err ||
+		   dtost(dentry->d_parent) != MODIFIED) {
+			printk(KERN_CRIT "mini_fo: get_neg_sto_dentry: ERROR building sto structure.\n");
+			err = -1;
+			goto out;
+		}
+	}
+
+	len = dentry->d_name.len;
+	name = dentry->d_name.name;
+
+	mutex_lock(&dtohd2(dentry->d_parent)->d_inode->i_mutex);
+	dtohd2(dentry) =
+		lookup_one_len(name, dtohd2(dentry->d_parent), len);
+	mutex_unlock(&dtohd2(dentry->d_parent)->d_inode->i_mutex);
+
+ out:
+	return err;
+}
+
+int check_mini_fo_dentry(dentry_t *dentry)
+{
+ 	ASSERT(dentry != NULL);
+	ASSERT(dtopd(dentry) != NULL);
+	ASSERT((dtohd(dentry) != NULL) || (dtohd2(dentry) != NULL));
+
+/* 	if(dtost(dentry) == MODIFIED) { */
+/* 		ASSERT(dentry->d_inode != NULL); */
+/* 		ASSERT(dtohd(dentry) != NULL); */
+/* 		ASSERT(dtohd(dentry)->d_inode != NULL); */
+/* 		ASSERT(dtohd2(dentry) != NULL); */
+/* 		ASSERT(dtohd2(dentry)->d_inode != NULL); */
+/* 	} */
+/* 	else if(dtost(dentry) == UNMODIFIED) { */
+/* 		ASSERT(dentry->d_inode != NULL); */
+/* 		ASSERT( */
+/* 	} */
+	return 0;
+}
+
+int check_mini_fo_file(file_t *file)
+{
+	ASSERT(file != NULL);
+	ASSERT(ftopd(file) != NULL);
+	ASSERT(file->f_dentry != NULL);
+
+	/* violent checking, check depending of state and type
+	 *	if(S_ISDIR(file->f_dentry->d_inode->i_mode)) {}
+	 */
+	ASSERT((ftohf(file) != NULL) || (ftohf2(file) != NULL));
+	return 0;
+}
+
+int check_mini_fo_inode(inode_t *inode)
+{
+	ASSERT(inode != NULL);
+	ASSERT(itopd(inode) != NULL);
+	ASSERT((itohi(inode) != NULL) || (itohi2(inode) != NULL));
+	return 0;
+}
+
+/*
+ * will walk a base path as provided by get_mini_fo_bpath and return
+ * the (hopefully ;-) ) positive dentry of the renamed base dir.
+ *
+ * This does some work of path_init.
+ */
+dentry_t *bpath_walk(super_block_t *sb, char *bpath)
+{
+	int err;
+        struct vfsmount *mnt;
+	struct nameidata nd;
+
+	/* be paranoid */
+	if(!bpath || bpath[0] != '/') {
+		printk(KERN_CRIT "mini_fo: bpath_walk: Invalid string.\n");
+		return NULL;
+	}
+	if(!sb || !stopd(sb)) {
+		printk(KERN_CRIT "mini_fo: bpath_walk: Invalid sb.\n");
+		return NULL;
+	}
+
+	/* fix this: how do I reach this lock?
+	 * read_lock(&current->fs->lock); */
+	mnt = mntget(stopd(sb)->hidden_mnt);
+	/* read_unlock(&current->fs->lock); */
+
+	err = vfs_path_lookup(mnt->mnt_root, mnt, bpath+1, 0, &nd);
+
+	/* validate */
+	if (err || !nd_get_dentry(&nd) || !nd_get_dentry(&nd)->d_inode) {
+		printk(KERN_CRIT "mini_fo: bpath_walk: path_walk failed.\n");
+		return NULL;
+	}
+	return nd_get_dentry(&nd);
+}
+
+
+/* returns the full path of the basefile incl. its name */
+int get_mini_fo_bpath(dentry_t *dentry, char **bpath, int *bpath_len)
+{
+	char *buf_walker;
+	int len = 0;
+	dentry_t *sky_walker;
+
+	if(!dentry || !dtohd(dentry)) {
+		printk(KERN_CRIT "mini_fo: get_mini_fo_bpath: invalid dentry passed.\n");
+		return -1;
+	}
+	sky_walker = dtohd(dentry);
+
+	do {
+		len += sky_walker->d_name.len + 1 ; /* 1 for '/' */
+		sky_walker = sky_walker->d_parent;
+	} while(sky_walker != stopd(dentry->d_inode->i_sb)->base_dir_dentry);
+
+	/* 1 to oil the loop */
+	*bpath = (char*)  kmalloc(len + 1, GFP_KERNEL);
+	if(!*bpath) {
+		printk(KERN_CRIT "mini_fo: get_mini_fo_bpath: out of mem.\n");
+		return -1;
+	}
+	buf_walker = *bpath+len; /* put it on last char */
+	*buf_walker = '\n';
+	sky_walker = dtohd(dentry);
+
+	do {
+		buf_walker -= sky_walker->d_name.len;
+		strncpy(buf_walker,
+			sky_walker->d_name.name,
+			sky_walker->d_name.len);
+		*(--buf_walker) = '/';
+		sky_walker = sky_walker->d_parent;
+	} while(sky_walker != stopd(dentry->d_inode->i_sb)->base_dir_dentry);
+
+	/* bpath_len doesn't count newline! */
+	*bpath_len = len;
+ 	return 0;
+}
+
+int mini_fo_cp_cont(dentry_t *tgt_dentry, struct vfsmount *tgt_mnt,
+		    dentry_t *src_dentry, struct vfsmount *src_mnt)
+{
+	void *buf;
+	mm_segment_t old_fs;
+	file_t *tgt_file;
+	file_t *src_file;
+	int bytes, len, tmp, err;
+	err = 0;
+
+	if(!(tgt_dentry->d_inode && src_dentry->d_inode)) {
+		printk(KERN_CRIT "mini_fo_cp_cont: ERROR, neg. dentry passed.\n");
+		err = -EINVAL;
+		goto out;
+	}
+
+	dget(tgt_dentry);
+	dget(src_dentry);
+	mntget(tgt_mnt);
+	mntget(src_mnt);
+
+	/* open file write only */
+	tgt_file = dentry_open(tgt_dentry, tgt_mnt, 0x1, current_cred());
+	if(!tgt_file || IS_ERR(tgt_file)) {
+		printk(KERN_CRIT "mini_fo_cp_cont: ERROR opening target file.\n");
+		err = PTR_ERR(tgt_file);
+		goto out_err;
+	}
+
+	/* open file read only */
+	src_file = dentry_open(src_dentry, src_mnt, 0x0, current_cred());
+	if(!src_file || IS_ERR(src_file)) {
+		printk(KERN_CRIT "mini_fo_cp_cont: ERROR opening source file.\n");
+		err = PTR_ERR(src_file);
+
+		/* close target file */
+		fput(tgt_file);
+		goto out_err;
+	}
+
+	/* check if the filesystem(s) support read respective write */
+	if(!src_file->f_op->read || !tgt_file->f_op->write) {
+		printk(KERN_CRIT "mini_fo_cp_cont: ERROR, no fs read or write support.\n");
+		err = -EPERM;
+		goto out_close;
+	}
+
+	/* allocate a page for transfering the data */
+	buf = (void *) __get_free_page(GFP_KERNEL);
+	if(!buf) {
+		printk(KERN_CRIT "mini_fo_cp_cont: ERROR, out of kernel mem.\n");
+		goto out_err;
+	}
+
+	tgt_file->f_pos = 0;
+	src_file->f_pos = 0;
+
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+
+	/* Doing this I assume that a read operation will return a full
+	 * buffer while there is still data to read, and a less than
+	 * full buffer when all data has been read.
+	 */
+	bytes = len = PAGE_SIZE;
+	while(bytes == len) {
+		bytes = src_file->f_op->read(src_file, buf, len,
+					     &src_file->f_pos);
+		tmp = tgt_file->f_op->write(tgt_file, buf, bytes,
+					    &tgt_file->f_pos);
+		if(tmp != bytes) {
+			printk(KERN_CRIT "mini_fo_cp_cont: ERROR writing.\n");
+			goto out_close_unset;
+		}
+	}
+
+	free_page((unsigned long) buf);
+	set_fs(old_fs);
+	fput(tgt_file);
+	fput(src_file);
+	goto out;
+
+ out_close_unset:
+	free_page((unsigned long) buf);
+	set_fs(old_fs);
+
+ out_close:
+	fput(tgt_file);
+	fput(src_file);
+
+ out_err:
+	dput(tgt_dentry);
+	dput(src_dentry);
+
+	/* mk: not sure if this need to be done */
+	mntput(tgt_mnt);
+	mntput(src_mnt);
+
+ out:
+	return err;
+}
+
+/* mk:
+ * ndl (no-duplicate list) stuff
+ * This is used in mini_fo_readdir, to save the storage directory contents
+ * and later when reading base, match them against the list in order
+ * to avoid duplicates.
+ */
+
+/* add a file specified by name and len to the ndl
+ * Return values: 0 on success, <0 on failure.
+ */
+int ndl_add_entry(struct readdir_data *rd, const char *name, int len)
+{
+	struct ndl_entry *tmp_entry;
+
+	tmp_entry = (struct ndl_entry *)
+		kmalloc(sizeof(struct ndl_entry), GFP_KERNEL);
+	if(!tmp_entry) {
+                printk(KERN_CRIT "mini_fo: ndl_add_entry: out of mem.\n");
+                return -ENOMEM;
+        }
+        tmp_entry->name = (char*) kmalloc(len, GFP_KERNEL);
+        if(!tmp_entry->name) {
+                printk(KERN_CRIT "mini_fo: ndl_add_entry: out of mem.\n");
+                return -ENOMEM;
+        }
+	strncpy(tmp_entry->name, name, len);
+        tmp_entry->len = len;
+
+        list_add(&tmp_entry->list, &rd->ndl_list);
+        rd->ndl_size++;
+        return 0;
+}
+
+/* delete all list entries and free memory */
+void ndl_put_list(struct readdir_data *rd)
+{
+	struct list_head *tmp;
+	struct ndl_entry *tmp_entry;
+
+	if(rd->ndl_size <= 0)
+		return;
+	while(!list_empty(&rd->ndl_list)) {
+		tmp = rd->ndl_list.next;
+                list_del(tmp);
+                tmp_entry = list_entry(tmp, struct ndl_entry, list);
+		kfree(tmp_entry->name);
+                kfree(tmp_entry);
+        }
+	rd->ndl_size = 0;
+}
+
+/* Check if a file specified by name and len is in the ndl
+ * Return value: 0 if not in list, 1 if file is found in ndl.
+ */
+int ndl_check_entry(struct readdir_data *rd, const char *name, int len)
+{
+	struct list_head *tmp;
+	struct ndl_entry *tmp_entry;
+
+	if(rd->ndl_size <= 0)
+		return 0;
+
+	list_for_each(tmp, &rd->ndl_list) {
+                tmp_entry = list_entry(tmp, struct ndl_entry, list);
+                if(tmp_entry->len != len)
+                        continue;
+                if(!strncmp(tmp_entry->name, name, len))
+                        return 1;
+        }
+        return 0;
+}
+
+/* mk:
+ * Recursive function to create corresponding directorys in the storage fs.
+ * The function will build the storage directorys up to dentry.
+ */
+int build_sto_structure(dentry_t *dir, dentry_t *dentry)
+{
+	int err;
+	dentry_t *hidden_sto_dentry;
+	dentry_t *hidden_sto_dir_dentry;
+
+	if(dentry->d_parent != dir) {
+		printk(KERN_CRIT "mini_fo: build_sto_structure: invalid parameter or meta data corruption [1].\n");
+		return 1;
+	}
+
+       	if(dtost(dir) != MODIFIED) {
+		err = build_sto_structure(dir->d_parent, dentry->d_parent);
+		if(err)
+			return err;
+	}
+
+	/* ok, coming back again. */
+	check_mini_fo_dentry(dentry);
+	hidden_sto_dentry = dtohd2(dentry);
+
+	if(!hidden_sto_dentry) {
+		/*
+		 * This is the case after creating the first
+		 * hidden_sto_dentry.
+		 * After one negative storage_dentry, all pointers to
+		 * hidden_storage dentries are set to NULL. We need to
+		 * create the negative dentry before we create the storage
+		 * file.
+		 */
+		unsigned int len;
+		const unsigned char *name;
+		len = dtohd(dentry)->d_name.len;
+		name = dtohd(dentry)->d_name.name;
+		mutex_lock(&dtohd2(dir)->d_inode->i_mutex);
+		hidden_sto_dentry = lookup_one_len(name, dtohd2(dir), len);
+		mutex_unlock(&dtohd2(dir)->d_inode->i_mutex);
+		dtohd2(dentry) = hidden_sto_dentry;
+	}
+
+	/* was:	hidden_sto_dir_dentry = lock_parent(hidden_sto_dentry); */
+	hidden_sto_dir_dentry = dget(hidden_sto_dentry->d_parent);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+	mutex_lock(&hidden_sto_dir_dentry->d_inode->i_mutex);
+#else
+	down(&hidden_sto_dir_dentry->d_inode->i_sem);
+#endif
+	/* lets be safe */
+	if(dtohd2(dir) != hidden_sto_dir_dentry) {
+		printk(KERN_CRIT "mini_fo: build_sto_structure: invalid parameter or meta data corruption [2].\n");
+		return 1;
+	}
+
+	/* check for errors in lock_parent */
+	err = PTR_ERR(hidden_sto_dir_dentry);
+	if(IS_ERR(hidden_sto_dir_dentry)) {
+		printk(KERN_CRIT "mini_fo: build_sto_structure: lock_parent failed.\n");
+		return err;
+	}
+
+	err = vfs_mkdir(hidden_sto_dir_dentry->d_inode,
+			hidden_sto_dentry,
+			dir->d_inode->i_mode);
+
+	if(err) {
+		printk(KERN_CRIT "mini_fo: build_sto_structure: failed to create storage dir [1].\n");
+		/* was: unlock_dir(dir); */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+		mutex_unlock(&dir->d_inode->i_mutex);
+#else
+		up(&dir->d_inode->i_sem);
+#endif
+		dput(dir);
+		return err;
+	}
+
+	/* everything ok! */
+	if(!dtohd2(dentry)->d_inode) {
+		printk(KERN_CRIT "mini_fo: build_sto_structure: failed to create storage dir [2].\n");
+		/* was: unlock_dir(dir); */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+		mutex_unlock(&dir->d_inode->i_mutex);
+#else
+		up(&dir->d_inode->i_sem);
+#endif
+		dput(dir);
+		return 1;
+	}
+
+	/* interpose the new inode and set new state */
+	itohi2(dentry->d_inode) = igrab(dtohd2(dentry)->d_inode);
+	dtopd(dentry)->state = MODIFIED;
+
+	/* initalize the wol list */
+	itopd(dentry->d_inode)->deleted_list_size = -1;
+	itopd(dentry->d_inode)->renamed_list_size = -1;
+	meta_build_lists(dentry);
+
+	fist_copy_attr_all(dentry->d_inode, itohi2(dentry->d_inode));
+	fist_copy_attr_timesizes(dir->d_inode,
+				 hidden_sto_dir_dentry->d_inode);
+	dir->d_inode->i_nlink++;
+	/* was: unlock_dir(hidden_sto_dir_dentry); */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+	mutex_unlock(&hidden_sto_dir_dentry->d_inode->i_mutex);
+#else
+	up(&hidden_sto_dir_dentry->d_inode->i_sem);
+#endif
+	dput(hidden_sto_dir_dentry);
+	return 0;
+}
+
+
+#if 0 /* unused */
+
+/*
+ * Read "len" bytes from "filename" into "buf".
+ * "buf" is in kernel space.
+ */
+int
+mini_fo_read_file(const char *filename, void *buf, int len)
+{
+    file_t *filp;
+    mm_segment_t oldfs;
+    int bytes;
+    /* Chroot? Maybe NULL isn't right here */
+    filp = filp_open(filename, O_RDONLY, 0);
+    if (!filp || IS_ERR(filp)) {
+	printk("mini_fo_read_file err %d\n", (int) PTR_ERR(filp));
+	return -1;  /* or do something else */
+    }
+
+    if (!filp->f_op->read)
+	return -2;  /* file(system) doesn't allow reads */
+
+    /* now read len bytes from offset 0 */
+    filp->f_pos = 0;		/* start offset */
+    oldfs = get_fs();
+    set_fs(KERNEL_DS);
+    bytes = filp->f_op->read(filp, buf, len, &filp->f_pos);
+    set_fs(oldfs);
+
+    /* close the file */
+    fput(filp);
+
+    return bytes;
+}
+
+
+
+/*
+ * Write "len" bytes from "buf" to "filename"
+ * "buf" is in kernel space.
+ */
+int
+mini_fo_write_file(const char *filename, void *buf, int len)
+{
+    file_t *filp;
+    mm_segment_t oldfs;
+    int bytes;
+				/* Chroot? Maybe NULL isn't right here */
+    filp = filp_open(filename, O_RDWR|O_CREAT, 0640);
+    if (!filp || IS_ERR(filp)) {
+	printk("mini_fo_write_file err %d\n", (int) PTR_ERR(filp));
+	return -1;  /* or do something else */
+    }
+
+    if (!filp->f_op->write)
+	return -2;  /* file(system) doesn't allow writes */
+
+    /* now write len bytes from offset 0 */
+    filp->f_pos = 0;		/* start offset */
+    oldfs = get_fs();
+    set_fs(KERNEL_DS);
+    bytes = filp->f_op->write(filp, buf, len, &filp->f_pos);
+    set_fs(oldfs);
+
+    /* close the file */
+    fput(filp);
+
+    return bytes;
+}
+
+#endif /* unused */
+
diff -Nru linux-2.6.30.5/fs/mini_fo/dentry.c linux-2.6.30.5-wrt/fs/mini_fo/dentry.c
--- linux-2.6.30.5/fs/mini_fo/dentry.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/fs/mini_fo/dentry.c	2009-09-06 18:43:48.414667469 +0200
@@ -0,0 +1,244 @@
+/*
+ * Copyright (c) 1997-2003 Erez Zadok
+ * Copyright (c) 2001-2003 Stony Brook University
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package, or get one from ftp://ftp.filesystems.org/pub/fist/COPYING.
+ *
+ * This Copyright notice must be kept intact and distributed with all
+ * fistgen sources INCLUDING sources generated by fistgen.
+ */
+/*
+ * Copyright (C) 2004, 2005 Markus Klotzbuecher <mk@creamnet.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+/*
+ *  $Id$
+ */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include "fist.h"
+#include "mini_fo.h"
+
+/*
+ * THIS IS A BOOLEAN FUNCTION: returns 1 if valid, 0 otherwise.
+ */
+STATIC int
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+mini_fo_d_revalidate(dentry_t *dentry, struct nameidata *nd)
+#else
+mini_fo_d_revalidate(dentry_t *dentry, int flags)
+#endif
+{
+	int err1 = 1; /* valid = 1, invalid = 0 */
+	int err2 = 1;
+	dentry_t *hidden_dentry;
+	dentry_t *hidden_sto_dentry;
+
+
+	check_mini_fo_dentry(dentry);
+
+	hidden_dentry  = dtohd(dentry);
+	hidden_sto_dentry = dtohd2(dentry);
+
+	if(hidden_dentry &&
+	   hidden_dentry->d_op &&
+	   hidden_dentry->d_op->d_revalidate) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+		err1 = hidden_dentry->d_op->d_revalidate(hidden_dentry, nd);
+#else
+		err1 = hidden_dentry->d_op->d_revalidate(hidden_dentry, flags);
+#endif
+	}
+	if(hidden_sto_dentry &&
+	   hidden_sto_dentry->d_op &&
+	   hidden_sto_dentry->d_op->d_revalidate) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+		err2 = hidden_sto_dentry->d_op->d_revalidate(hidden_sto_dentry,
+							     nd);
+#else
+		err2 = hidden_sto_dentry->d_op->d_revalidate(hidden_sto_dentry,
+							     flags);
+#endif
+	}
+
+	/* mk: if one of the lower level dentries are valid,
+	 * the mini_fo dentry is too.
+	 */
+	return (err1 || err2);
+}
+
+
+STATIC int
+mini_fo_d_hash(dentry_t *dentry, qstr_t *name)
+{
+	int err = 0;
+	dentry_t *hidden_dentry;
+	dentry_t *hidden_sto_dentry;
+
+	/* hidden_dentry = mini_fo_hidden_dentry(dentry);
+	 * hidden_sto_dentry = mini_fo_hidden_sto_dentry(dentry); */
+
+	/* state 1, 3, 4, 5: build the hash for the storage dentry */
+	if((dtopd(dentry)->state == MODIFIED) ||
+	   (dtopd(dentry)->state == CREATED) ||
+	   (dtopd(dentry)->state == DEL_REWRITTEN) ||
+	   (dtopd(dentry)->state == DELETED)) {
+		hidden_sto_dentry = dtohd2(dentry);
+		if(hidden_sto_dentry &&
+		   hidden_sto_dentry->d_op &&
+		   hidden_sto_dentry->d_op->d_hash) {
+			err = hidden_sto_dentry->d_op->d_hash(hidden_sto_dentry, name);
+		}
+		goto out;
+	}
+	/* state 2: build the hash for the base dentry */
+	if(dtopd(dentry)->state == UNMODIFIED) {
+		hidden_dentry = dtohd(dentry);
+		if(hidden_dentry &&
+		   hidden_dentry->d_op &&
+		   hidden_dentry->d_op->d_hash) {
+			err = hidden_dentry->d_op->d_hash(hidden_dentry, name);
+		}
+		goto out;
+	}
+	/* state 6: build hash for the dentry that exists */
+	if(dtopd(dentry)->state == NON_EXISTANT) {
+		hidden_sto_dentry = dtohd2(dentry);
+		if(hidden_sto_dentry &&
+		   hidden_sto_dentry->d_op &&
+		   hidden_sto_dentry->d_op->d_hash) {
+			err = hidden_sto_dentry->d_op->d_hash(hidden_sto_dentry, name);
+			goto out;
+		}
+		hidden_dentry = dtohd(dentry);
+		if(hidden_dentry &&
+		   hidden_dentry->d_op &&
+		   hidden_dentry->d_op->d_hash) {
+			err = hidden_dentry->d_op->d_hash(hidden_dentry, name);
+			goto out;
+		}
+	}
+
+	printk(KERN_CRIT "mini_fo: d_hash: invalid state detected.\n");
+
+ out:
+	return err;
+}
+
+
+STATIC int
+mini_fo_d_compare(dentry_t *dentry, qstr_t *a, qstr_t *b)
+{
+	int err;
+	dentry_t *hidden_dentry=NULL;
+
+	/* hidden_dentry = mini_fo_hidden_dentry(dentry); */
+	if(dtohd2(dentry))
+		hidden_dentry = dtohd2(dentry);
+	else if(dtohd(dentry))
+		hidden_dentry = dtohd(dentry);
+
+	if (hidden_dentry && hidden_dentry->d_op && hidden_dentry->d_op->d_compare) {
+		err = hidden_dentry->d_op->d_compare(hidden_dentry, a, b);
+	} else {
+		err = ((a->len != b->len) || memcmp(a->name, b->name, b->len));
+	}
+
+	return err;
+}
+
+
+int
+mini_fo_d_delete(dentry_t *dentry)
+{
+	dentry_t *hidden_dentry;
+	dentry_t *hidden_sto_dentry;
+	int err = 0;
+
+	/* this could be a negative dentry, so check first */
+	if (!dtopd(dentry)) {
+		printk(KERN_CRIT "mini_fo_d_delete: negative dentry passed.\n");
+		goto out;
+	}
+	hidden_dentry = dtohd(dentry);
+	hidden_sto_dentry = dtohd2(dentry);
+
+	if(hidden_dentry) {
+		if(hidden_dentry->d_op &&
+		   hidden_dentry->d_op->d_delete) {
+			err = hidden_dentry->d_op->d_delete(hidden_dentry);
+		}
+	}
+	if(hidden_sto_dentry) {
+		if(hidden_sto_dentry->d_op &&
+		   hidden_sto_dentry->d_op->d_delete) {
+			err = hidden_sto_dentry->d_op->d_delete(hidden_sto_dentry);
+		}
+	}
+
+ out:
+	return err;
+}
+
+
+void
+mini_fo_d_release(dentry_t *dentry)
+{
+	dentry_t *hidden_dentry;
+	dentry_t *hidden_sto_dentry;
+
+
+	/* this could be a negative dentry, so check first */
+	if (!dtopd(dentry)) {
+		printk(KERN_CRIT "mini_fo_d_release: no private data.\n");
+		goto out;
+	}
+	hidden_dentry = dtohd(dentry);
+	hidden_sto_dentry = dtohd2(dentry);
+
+	if(hidden_dentry) {
+		/* decrement hidden dentry's counter and free its inode */
+		dput(hidden_dentry);
+	}
+	if(hidden_sto_dentry) {
+                /* decrement hidden dentry's counter and free its inode */
+		dput(hidden_sto_dentry);
+	}
+
+	/* free private data (mini_fo_dentry_info) here */
+	kfree(dtopd(dentry));
+	__dtopd(dentry) = NULL;	/* just to be safe */
+ out:
+	return;
+}
+
+
+/*
+ * we don't really need mini_fo_d_iput, because dentry_iput will call iput() if
+ * mini_fo_d_iput is not defined. We left this implemented for ease of
+ * tracing/debugging.
+ */
+void
+mini_fo_d_iput(dentry_t *dentry, inode_t *inode)
+{
+	iput(inode);
+}
+
+
+struct dentry_operations mini_fo_dops = {
+	d_revalidate:	mini_fo_d_revalidate,
+	d_hash:		mini_fo_d_hash,
+	d_compare:		mini_fo_d_compare,
+	d_release:		mini_fo_d_release,
+	d_delete:		mini_fo_d_delete,
+	d_iput:		mini_fo_d_iput,
+};
diff -Nru linux-2.6.30.5/fs/mini_fo/file.c linux-2.6.30.5-wrt/fs/mini_fo/file.c
--- linux-2.6.30.5/fs/mini_fo/file.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/fs/mini_fo/file.c	2009-09-06 18:43:48.426667806 +0200
@@ -0,0 +1,713 @@
+/*
+ * Copyright (c) 1997-2003 Erez Zadok
+ * Copyright (c) 2001-2003 Stony Brook University
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package, or get one from ftp://ftp.filesystems.org/pub/fist/COPYING.
+ *
+ * This Copyright notice must be kept intact and distributed with all
+ * fistgen sources INCLUDING sources generated by fistgen.
+ */
+/*
+ * Copyright (C) 2004, 2005 Markus Klotzbuecher <mk@creamnet.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+/*
+ *  $Id$
+ */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include "fist.h"
+#include "mini_fo.h"
+#define ROUND_UP(x) (((x)+sizeof(long)-1) & ~(sizeof(long)-1))
+
+/*******************
+ * File Operations *
+ *******************/
+
+STATIC loff_t
+mini_fo_llseek(file_t *file, loff_t offset, int origin)
+{
+	loff_t err;
+	file_t *hidden_file = NULL;
+
+	if(S_ISDIR(file->f_dentry->d_inode->i_mode)) {
+		/* Check if trying to llseek from a directory */
+		err = -EISDIR;
+		goto out;
+	}
+	if (ftopd(file) != NULL) {
+		if(ftohf2(file)) {
+			hidden_file = ftohf2(file);
+		} else {
+			hidden_file = ftohf(file);
+		}
+	}
+
+	/* always set hidden position to this one */
+	hidden_file->f_pos = file->f_pos;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	memcpy(&(hidden_file->f_ra),
+	       &(file->f_ra),
+	       sizeof(struct file_ra_state));
+#else
+	if (file->f_reada) { /* update readahead information if needed */
+		hidden_file->f_reada = file->f_reada;
+		hidden_file->f_ramax = file->f_ramax;
+		hidden_file->f_raend = file->f_raend;
+		hidden_file->f_ralen = file->f_ralen;
+		hidden_file->f_rawin = file->f_rawin;
+	}
+#endif
+	if (hidden_file->f_op && hidden_file->f_op->llseek)
+		err = hidden_file->f_op->llseek(hidden_file, offset, origin);
+	else
+		err = generic_file_llseek(hidden_file, offset, origin);
+
+	if (err < 0)
+		goto out;
+
+	if (err != file->f_pos) {
+		file->f_pos = err;
+		// ION maybe this?
+		// 	file->f_pos = hidden_file->f_pos;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		file->f_reada = 0;
+#endif
+		file->f_version++;
+	}
+
+ out:
+	return err;
+}
+
+
+/* mk: fanout capable */
+STATIC ssize_t
+mini_fo_read(file_t *file, char *buf, size_t count, loff_t *ppos)
+{
+	int err = -EINVAL;
+	file_t *hidden_file = NULL;
+	loff_t pos = *ppos;
+
+	if(S_ISDIR(file->f_dentry->d_inode->i_mode)) {
+		/* Check if trying to read from a directory */
+		/* printk(KERN_CRIT "mini_fo_read: ERROR: trying to read data from a directory.\n"); */
+		err = -EISDIR;
+		goto out;
+	}
+
+	if (ftopd(file) != NULL) {
+		if(ftohf2(file)) {
+			hidden_file = ftohf2(file);
+		} else {
+			hidden_file = ftohf(file);
+		}
+	}
+
+	if (!hidden_file->f_op || !hidden_file->f_op->read)
+		goto out;
+
+	err = hidden_file->f_op->read(hidden_file, buf, count, &pos);
+	*ppos = pos;
+
+	if (err >= 0) {
+		/* atime should also be updated for reads of size zero or more */
+		fist_copy_attr_atime(file->f_dentry->d_inode,
+				     hidden_file->f_dentry->d_inode);
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	/*
+	 * MAJOR HACK
+	 * because pread() does not have any way to tell us that it is
+	 * our caller, then we don't know for sure if we have to update
+	 * the file positions.  This hack relies on read() having passed us
+	 * the "real" pointer of its struct file's f_pos field.
+	 */
+	if (ppos == &file->f_pos)
+		hidden_file->f_pos = *ppos = pos;
+	if (hidden_file->f_reada) { /* update readahead information if needed */
+		file->f_reada = hidden_file->f_reada;
+		file->f_ramax = hidden_file->f_ramax;
+		file->f_raend = hidden_file->f_raend;
+		file->f_ralen = hidden_file->f_ralen;
+		file->f_rawin = hidden_file->f_rawin;
+	}
+#else
+	memcpy(&(file->f_ra),&(hidden_file->f_ra),sizeof(struct file_ra_state));
+#endif
+
+ out:
+	return err;
+}
+
+
+/* this mini_fo_write() does not modify data pages! */
+STATIC ssize_t
+mini_fo_write(file_t *file, const char *buf, size_t count, loff_t *ppos)
+{
+	int err = -EINVAL;
+	file_t *hidden_file = NULL;
+	inode_t *inode;
+	inode_t *hidden_inode;
+	loff_t pos = *ppos;
+
+	/* mk: fan out: */
+	if (ftopd(file) != NULL) {
+		if(ftohf2(file)) {
+			hidden_file = ftohf2(file);
+		} else {
+			/* This is bad! We have no storage file to write to. This
+			 * should never happen because if a file is opened for
+			 * writing, a copy should have been made earlier.
+			 */
+			printk(KERN_CRIT "mini_fo: write : ERROR, no storage file to write.\n");
+			err = -EINVAL;
+			goto out;
+		}
+	}
+
+	inode = file->f_dentry->d_inode;
+	hidden_inode = itohi2(inode);
+	if(!hidden_inode) {
+		printk(KERN_CRIT "mini_fo: write: no sto inode found, not good.\n");
+		goto out;
+	}
+
+	if (!hidden_file->f_op || !hidden_file->f_op->write)
+		goto out;
+
+	/* adjust for append -- seek to the end of the file */
+	if (file->f_flags & O_APPEND)
+		pos = inode->i_size;
+
+	err = hidden_file->f_op->write(hidden_file, buf, count, &pos);
+
+	/*
+	 * copy ctime and mtime from lower layer attributes
+	 * atime is unchanged for both layers
+	 */
+	if (err >= 0)
+		fist_copy_attr_times(inode, hidden_inode);
+
+	*ppos = pos;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	/*
+	 * XXX: MAJOR HACK
+	 *
+	 * because pwrite() does not have any way to tell us that it is
+	 * our caller, then we don't know for sure if we have to update
+	 * the file positions.  This hack relies on write() having passed us
+	 * the "real" pointer of its struct file's f_pos field.
+	 */
+	if (ppos == &file->f_pos)
+		hidden_file->f_pos = *ppos = pos;
+#endif
+	/* update this inode's size */
+	if (pos > inode->i_size)
+		inode->i_size = pos;
+
+ out:
+	return err;
+}
+
+/* Global variable to hold a file_t pointer.
+ * This serves to allow mini_fo_filldir function to know which file is
+ * beeing read, which is required for two reasons:
+ *
+ *   - be able to call wol functions in order to avoid listing deleted
+ *     base files.
+ *   - if we're reading a directory which is in state 1, we need to
+ *     maintain a list (in mini_fo_filldir) of which files allready
+ *     have been copied to userspace,to detect files existing in base
+ *     and storage and not list them twice.
+ */
+filldir_t mini_fo_filldir_orig;
+file_t *mini_fo_filldir_file;
+
+/* mainly copied from fs/readdir.c */
+STATIC int
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+mini_fo_filldir(void * __buf, const char * name, int namlen, loff_t offset,
+		  u64 ino, unsigned int d_type)
+#else
+mini_fo_filldir(void * __buf, const char * name, int namlen, loff_t offset,
+		  ino_t ino, unsigned int d_type)
+#endif
+{
+	struct getdents_callback * buf = (struct getdents_callback *) __buf;
+	file_t* file = mini_fo_filldir_file;
+
+	/* In theses states we filter meta files in storage (WOL) */
+	if(file && (dtopd(file->f_dentry)->state == MODIFIED ||
+		    dtopd(file->f_dentry)->state == CREATED ||
+		    dtopd(file->f_dentry)->state == DEL_REWRITTEN)) {
+
+		int tmp = strlen(META_FILENAME);
+		if(tmp  == namlen) {
+			if(!strncmp(name, META_FILENAME, namlen))
+				return 0;
+		}
+	}
+
+	/* check if we are merging the contents of storage and base */
+	if(file && dtopd(file->f_dentry)->state == MODIFIED) {
+		/* check if we are still reading storage contents, if
+		 * yes, we just save the name of the file for duplicate
+		 * checking later. */
+
+		if(!ftopd(file)->rd.sto_done) {
+			/* put file into ndl list */
+			if(ndl_add_entry(&ftopd(file)->rd, name, namlen))
+				printk(KERN_CRIT "mini_fo_filldir: Error adding to ndl.\n");
+		} else {
+			/* check if file has been deleted */
+			if(meta_check_d_entry(file->f_dentry, name, namlen))
+				return 0;
+
+			/* do duplicate checking */
+			if(ndl_check_entry(&ftopd(file)->rd, name, namlen))
+				return 0;
+		}
+	}
+
+	return mini_fo_filldir_orig(buf, name, namlen, offset, ino, d_type);
+}
+
+
+STATIC int
+mini_fo_readdir(file_t *file, void *dirent, filldir_t filldir)
+{
+	int err = 0;/* mk: ??? -ENOTDIR; */
+	file_t *hidden_file = NULL;
+	file_t *hidden_sto_file = NULL;
+	inode_t *inode;
+	struct getdents_callback *buf;
+	int oldcount;
+
+#if defined(FIST_FILTER_NAME) || defined(FIST_FILTER_SCA)
+	struct mini_fo_getdents_callback buf;
+#endif /* FIST_FILTER_NAME || FIST_FILTER_SCA */
+
+	buf = (struct getdents_callback *) dirent;
+	oldcount = buf->count;
+	inode = file->f_dentry->d_inode;
+	mini_fo_filldir_file = file;
+	mini_fo_filldir_orig = filldir;
+
+	ftopd(file)->rd.sto_done = 0;
+	do {
+		if (ftopd(file) != NULL) {
+			if(ftohf2(file)) {
+				hidden_sto_file = ftohf2(file);
+				err = vfs_readdir(hidden_sto_file, mini_fo_filldir, dirent);
+				file->f_pos = hidden_sto_file->f_pos;
+				if (err > 0)
+					fist_copy_attr_atime(inode, hidden_sto_file->f_dentry->d_inode);
+				/* not finshed yet, we'll be called again */
+				if (buf->count != oldcount)
+					break;
+			}
+
+			ftopd(file)->rd.sto_done = 1;
+
+			if(ftohf(file)) {
+				hidden_file = ftohf(file);
+				err = vfs_readdir(hidden_file, mini_fo_filldir, dirent);
+				file->f_pos = hidden_file->f_pos;
+				if (err > 0)
+					fist_copy_attr_atime(inode, hidden_file->f_dentry->d_inode);
+			}
+
+		}
+	} while (0);
+
+	/* mk:
+	 * we need to check if all the directory data has been copied to userspace,
+	 * or if we will be called again by userspace to complete the operation.
+	 */
+	if(buf->count == oldcount) {
+		ndl_put_list(&ftopd(file)->rd);
+	}
+
+	/* unset this, safe */
+	mini_fo_filldir_file = NULL;
+	return err;
+}
+
+
+STATIC unsigned int
+mini_fo_poll(file_t *file, poll_table *wait)
+{
+	unsigned int mask = DEFAULT_POLLMASK;
+	file_t *hidden_file = NULL;
+
+	if (ftopd(file) != NULL) {
+		if(ftohf2(file)) {
+			hidden_file = ftohf2(file);
+		} else {
+			hidden_file = ftohf(file);
+		}
+	}
+
+	if (!hidden_file->f_op || !hidden_file->f_op->poll)
+		goto out;
+
+	mask = hidden_file->f_op->poll(hidden_file, wait);
+
+ out:
+	return mask;
+}
+
+/* FIST-LITE special version of mmap */
+STATIC int
+mini_fo_mmap(file_t *file, vm_area_t *vma)
+{
+	int err = 0;
+	file_t *hidden_file = NULL;
+
+	/* fanout capability */
+	if (ftopd(file) != NULL) {
+		if(ftohf2(file)) {
+			hidden_file = ftohf2(file);
+		} else {
+			hidden_file = ftohf(file);
+		}
+	}
+
+	ASSERT(hidden_file != NULL);
+	ASSERT(hidden_file->f_op != NULL);
+	ASSERT(hidden_file->f_op->mmap != NULL);
+
+	vma->vm_file = hidden_file;
+	err = hidden_file->f_op->mmap(hidden_file, vma);
+	get_file(hidden_file); /* make sure it doesn't get freed on us */
+	fput(file);	       /* no need to keep extra ref on ours */
+
+	return err;
+}
+
+
+
+STATIC int
+mini_fo_open(inode_t *inode, file_t *file)
+{
+	int err = 0;
+ 	int hidden_flags;
+	file_t *hidden_file = NULL;
+	dentry_t *hidden_dentry = NULL;
+
+	/* fanout stuff */
+	file_t *hidden_sto_file = NULL;
+	dentry_t *hidden_sto_dentry = NULL;
+
+	__ftopd(file) =
+		kmalloc(sizeof(struct mini_fo_file_info), GFP_KERNEL);
+	if (!ftopd(file)) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	/* init the readdir_helper structure */
+	INIT_LIST_HEAD(&ftopd(file)->rd.ndl_list);
+	ftopd(file)->rd.ndl_size = 0;
+
+	/* In certain paths this could stay uninitalized and cause trouble */
+	ftohf(file) = NULL;
+	ftohf2(file) = NULL;
+	hidden_flags = file->f_flags;
+
+	/* create storage files? */
+	if(dtost(file->f_dentry) == UNMODIFIED) {
+		if(!IS_WRITE_FLAG(file->f_flags)) {
+			hidden_dentry = dtohd(file->f_dentry);
+			dget(hidden_dentry);
+			/* dentry_open will decrement mnt refcnt if err.
+			 * otherwise fput() will do an mntput() for us upon file close. */
+			mntget(stopd(inode->i_sb)->hidden_mnt);
+			hidden_file = dentry_open(hidden_dentry,
+						  stopd(inode->i_sb)->hidden_mnt,
+						  hidden_flags, file->f_cred);
+			if (IS_ERR(hidden_file)) {
+				err = PTR_ERR(hidden_file);
+				dput(hidden_dentry);
+				goto out;
+			}
+			ftohf(file) = hidden_file;	/* link two files */
+			goto out;
+		}
+		else {
+			if(S_ISDIR(file->f_dentry->d_inode->i_mode)) {
+				err = dir_unmod_to_mod(file->f_dentry);
+			} else
+				err = nondir_unmod_to_mod(file->f_dentry, 1);
+
+			if (err) {
+				printk("mini_fo_open: ERROR creating storage file.\n");
+				goto out;
+			}
+		}
+	}
+	hidden_sto_dentry = dtohd2(file->f_dentry);
+	dget(hidden_sto_dentry);
+
+	if(dtopd(file->f_dentry)->state == MODIFIED) {
+		/* Directorys are special, interpose on both lower level files */
+		if(S_ISDIR(itohi(inode)->i_mode)) {
+			/* check for invalid file types of lower level files */
+			if(!(S_ISDIR(itohi(inode)->i_mode) && S_ISDIR(itohi2(inode)->i_mode))) {
+				printk(KERN_CRIT "mini_fo_open: meta data corruption detected.\n");
+				dput(hidden_sto_dentry);
+				err = -EINVAL;
+				goto out;
+			}
+
+			/* lower level directorys are ok, open the base file */
+			hidden_dentry = dtohd(file->f_dentry);
+			dget(hidden_dentry);
+
+			mntget(stopd(inode->i_sb)->hidden_mnt);
+			hidden_file = dentry_open(hidden_dentry,
+						  stopd(inode->i_sb)->hidden_mnt,
+						  hidden_flags, file->f_cred);
+			if (IS_ERR(hidden_file)) {
+				err = PTR_ERR(hidden_file);
+				dput(hidden_dentry);
+				dput(hidden_sto_dentry);
+				goto out;
+			}
+			ftohf(file) = hidden_file; /* link the two files */
+		}
+	}
+
+	if(!exists_in_storage(file->f_dentry)) {
+		printk(KERN_CRIT "mini_fo_open: invalid file state detected.\n");
+		err = -EINVAL;
+		dput(hidden_sto_dentry);
+
+		/* If the base file has been opened, we need to close it here */
+		if(ftohf(file)) {
+			if (hidden_file->f_op && hidden_file->f_op->flush)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+				hidden_file->f_op->flush(hidden_file, NULL);
+#else
+				hidden_file->f_op->flush(hidden_file);
+#endif
+			dput(hidden_dentry);
+		}
+		goto out;
+	}
+
+	/* ok, now we can safely open the storage file */
+	mntget(stopd(inode->i_sb)->hidden_mnt2);
+	hidden_sto_file = dentry_open(hidden_sto_dentry,
+				      stopd(inode->i_sb)->hidden_mnt2,
+				      hidden_flags, file->f_cred);
+
+	/* dentry_open dputs the dentry if it fails */
+	if (IS_ERR(hidden_sto_file)) {
+		err = PTR_ERR(hidden_sto_file);
+		/* close base file if open */
+		if(ftohf(file)) {
+			if (hidden_file->f_op && hidden_file->f_op->flush)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+				hidden_file->f_op->flush(hidden_file, NULL);
+#else
+				hidden_file->f_op->flush(hidden_file);
+#endif
+			dput(hidden_dentry);
+		}
+		goto out;
+	}
+	ftohf2(file) = hidden_sto_file; /* link storage file */
+
+ out:
+	if (err < 0 && ftopd(file)) {
+		kfree(ftopd(file));
+	}
+	return err;
+}
+
+STATIC int
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+mini_fo_flush(file_t *file, fl_owner_t id)
+#else
+mini_fo_flush(file_t *file)
+#endif
+{
+	int err1 = 0;		/* assume ok (see open.c:close_fp) */
+	int err2 = 0;
+	file_t *hidden_file = NULL;
+
+	check_mini_fo_file(file);
+
+	/* mk: we don't do any state checking here, as its not worth the time.
+	 * Just flush the lower level files if they exist.
+	 */
+	if(ftopd(file) != NULL) {
+		if(ftohf(file) != NULL) {
+			hidden_file = ftohf(file);
+			if (hidden_file->f_op && hidden_file->f_op->flush)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+				err1 = hidden_file->f_op->flush(hidden_file, id);
+#else
+				err1 = hidden_file->f_op->flush(hidden_file);
+#endif
+		}
+		if(ftohf2(file) != NULL) {
+			hidden_file = ftohf2(file);
+			if (hidden_file->f_op && hidden_file->f_op->flush)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+				err2 = hidden_file->f_op->flush(hidden_file, id);
+#else
+				err2 = hidden_file->f_op->flush(hidden_file);
+#endif
+		}
+	}
+	return (err1 | err2);
+}
+
+
+STATIC int
+mini_fo_release(inode_t *inode, file_t *file)
+{
+	int err = 0;
+	file_t *hidden_file = NULL;
+
+	if (ftopd(file) != NULL) {
+		if(ftohf(file)) {
+			hidden_file = ftohf(file);
+			fput(hidden_file);
+		}
+		if(ftohf2(file)) {
+			hidden_file = ftohf2(file);
+			fput(hidden_file);
+		}
+		kfree(ftopd(file));
+	}
+	return err;
+}
+
+STATIC int
+mini_fo_fsync(file_t *file, dentry_t *dentry, int datasync)
+{
+	int err1 = 0;
+	int err2 = 0;
+	file_t *hidden_file = NULL;
+	dentry_t *hidden_dentry;
+
+	check_mini_fo_file(file);
+
+	if ((hidden_file = ftohf(file)) != NULL) {
+		hidden_dentry = dtohd(dentry);
+		if (hidden_file->f_op && hidden_file->f_op->fsync) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+			mutex_lock(&hidden_dentry->d_inode->i_mutex);
+#else
+			down(&hidden_dentry->d_inode->i_sem);
+#endif
+			err1 = hidden_file->f_op->fsync(hidden_file, hidden_dentry, datasync);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+			mutex_unlock(&hidden_dentry->d_inode->i_mutex);
+#else
+			up(&hidden_dentry->d_inode->i_sem);
+#endif
+		}
+	}
+
+	if ((hidden_file = ftohf2(file)) != NULL) {
+		hidden_dentry = dtohd2(dentry);
+		if (hidden_file->f_op && hidden_file->f_op->fsync) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+			mutex_lock(&hidden_dentry->d_inode->i_mutex);
+#else
+			down(&hidden_dentry->d_inode->i_sem);
+#endif
+			err2 = hidden_file->f_op->fsync(hidden_file, hidden_dentry, datasync);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+			mutex_unlock(&hidden_dentry->d_inode->i_mutex);
+#else
+			up(&hidden_dentry->d_inode->i_sem);
+#endif
+		}
+	}
+	else
+		goto err;
+
+err:
+	return (err1 || err2);
+}
+
+
+STATIC int
+mini_fo_fasync(int fd, file_t *file, int flag)
+{
+	int err1 = 0;
+	int err2 = 0;
+
+	file_t *hidden_file = NULL;
+
+	check_mini_fo_file(file);
+
+	if((hidden_file = ftohf(file)) != NULL) {
+		err1 = hidden_file->f_op->fasync(fd, hidden_file, flag);
+	}
+	if((hidden_file = ftohf2(file)) != NULL) {
+		err2 = hidden_file->f_op->fasync(fd, hidden_file, flag);
+	}
+
+	return (err1 || err2);
+}
+
+
+
+struct file_operations mini_fo_dir_fops =
+	{
+		read:	generic_read_dir,
+		write:	mini_fo_write,
+		readdir: mini_fo_readdir,
+		poll:	mini_fo_poll,
+		/* ioctl:	mini_fo_ioctl, */
+		mmap:	mini_fo_mmap,
+		open:	mini_fo_open,
+		flush:	mini_fo_flush,
+		release: mini_fo_release,
+		fsync:	mini_fo_fsync,
+		fasync:	mini_fo_fasync,
+		/* not needed lock:	mini_fo_lock, */
+		/* not needed: readv */
+		/* not needed: writev */
+		/* not implemented: sendpage */
+		/* not implemented: get_unmapped_area */
+	};
+
+struct file_operations mini_fo_main_fops =
+	{
+		llseek:	mini_fo_llseek,
+		read:	mini_fo_read,
+		write:	mini_fo_write,
+		readdir: mini_fo_readdir,
+		poll:	mini_fo_poll,
+		/* ioctl:	mini_fo_ioctl, */
+		mmap:	mini_fo_mmap,
+		open:	mini_fo_open,
+		flush:	mini_fo_flush,
+		release: mini_fo_release,
+		fsync:	mini_fo_fsync,
+		fasync:	mini_fo_fasync,
+		/* not needed: lock:	mini_fo_lock, */
+		/* not needed: readv */
+		/* not needed: writev */
+		/* not implemented: sendpage */
+		/* not implemented: get_unmapped_area */
+	};
diff -Nru linux-2.6.30.5/fs/mini_fo/fist.h linux-2.6.30.5-wrt/fs/mini_fo/fist.h
--- linux-2.6.30.5/fs/mini_fo/fist.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/fs/mini_fo/fist.h	2009-09-06 18:43:48.414667469 +0200
@@ -0,0 +1,252 @@
+/*
+ * Copyright (c) 1997-2003 Erez Zadok
+ * Copyright (c) 2001-2003 Stony Brook University
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package, or get one from ftp://ftp.filesystems.org/pub/fist/COPYING.
+ *
+ * This Copyright notice must be kept intact and distributed with all
+ * fistgen sources INCLUDING sources generated by fistgen.
+ */
+/*
+ * Copyright (C) 2004, 2005 Markus Klotzbuecher <mk@creamnet.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+
+/*
+ *  $Id$
+ */
+
+#ifndef __FIST_H_
+#define __FIST_H_
+
+/*
+ * KERNEL ONLY CODE:
+ */
+#ifdef __KERNEL__
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19)
+#include <linux/autoconf.h>
+#else
+#include <linux/config.h>
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#ifdef CONFIG_MODVERSIONS
+# define MODVERSIONS
+# include <linux/modversions.h>
+#endif /* CONFIG_MODVERSIONS */
+#endif /* KERNEL_VERSION < 2.6.0 */
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/stat.h>
+#include <linux/errno.h>
+#include <linux/wait.h>
+#include <linux/limits.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/locks.h>
+#else
+#include <linux/buffer_head.h>
+#include <linux/pagemap.h>
+#include <linux/namei.h>
+#include <linux/module.h>
+#include <linux/mount.h>
+#include <linux/page-flags.h>
+#include <linux/writeback.h>
+#include <linux/statfs.h>
+#endif
+#include <linux/smp.h>
+#include <linux/smp_lock.h>
+#include <linux/file.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/poll.h>
+#include <linux/list.h>
+#include <linux/init.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,20)
+#include <linux/xattr.h>
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#include <linux/security.h>
+#endif
+
+#include <linux/swap.h>
+
+#include <asm/system.h>
+/* #include <asm/segment.h> */
+#include <asm/mman.h>
+#include <linux/seq_file.h>
+
+/*
+ * MACROS:
+ */
+
+/* those mapped to ATTR_* were copied from linux/fs.h */
+#define FA_MODE		ATTR_MODE
+#define FA_UID		ATTR_UID
+#define FA_GID		ATTR_GID
+#define FA_SIZE		ATTR_SIZE
+#define FA_ATIME	ATTR_ATIME
+#define FA_MTIME	ATTR_MTIME
+#define FA_CTIME	ATTR_CTIME
+#define FA_ATIME_SET	ATTR_ATIME_SET
+#define FA_MTIME_SET	ATTR_MTIME_SET
+#define FA_FORCE	ATTR_FORCE
+#define FA_ATTR_FLAGS	ATTR_ATTR_FLAG
+
+/* must be greater than all other ATTR_* flags! */
+#define FA_NLINK	2048
+#define FA_BLKSIZE	4096
+#define FA_BLOCKS	8192
+#define FA_TIMES	(FA_ATIME|FA_MTIME|FA_CTIME)
+#define FA_ALL		0
+
+/* macros to manage changes between kernels */
+#define INODE_DATA(i)	(&(i)->i_data)
+
+#define MIN(x,y) ((x < y) ? (x) : (y))
+#define MAX(x,y) ((x > y) ? (x) : (y))
+#define MAXPATHLEN PATH_MAX
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,5)
+# define lookup_one_len(a,b,c) lookup_one(a,b)
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,4,5) */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,8)
+# define generic_file_llseek default_llseek
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,4,8) */
+
+#ifndef SEEK_SET
+# define SEEK_SET 0
+#endif /* not SEEK_SET */
+
+#ifndef SEEK_CUR
+# define SEEK_CUR 1
+#endif /* not SEEK_CUR */
+
+#ifndef SEEK_END
+# define SEEK_END 2
+#endif /* not SEEK_END */
+
+#ifndef DEFAULT_POLLMASK
+# define DEFAULT_POLLMASK (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM)
+#endif /* not DEFAULT_POLLMASK */
+
+/* XXX: fix this so fistgen generates kfree() code directly */
+#define kfree_s(a,b) kfree(a)
+
+/*
+ * TYPEDEFS:
+ */
+typedef struct dentry dentry_t;
+typedef struct file file_t;
+typedef struct inode inode_t;
+typedef inode_t vnode_t;
+typedef struct page page_t;
+typedef struct qstr qstr_t;
+typedef struct super_block super_block_t;
+typedef super_block_t vfs_t;
+typedef struct vm_area_struct vm_area_t;
+
+
+/*
+ * EXTERNALS:
+ */
+
+#define FPPF(str,page) printk("PPF %s 0x%x/%d: Lck:%d Err:%d Ref:%d Upd:%d Other::%d:%d:%d:%d:\n", \
+		str, \
+		(int) page, \
+		(int) page->index, \
+		(PageLocked(page) ? 1 : 0), \
+		(PageError(page) ? 1 : 0), \
+		(PageReferenced(page) ? 1 : 0), \
+		(Page_Uptodate(page) ? 1 : 0), \
+		(PageDecrAfter(page) ? 1 : 0), \
+		(PageSlab(page) ? 1 : 0), \
+		(PageSwapCache(page) ? 1 : 0), \
+		(PageReserved(page) ? 1 : 0) \
+		)
+#define EZKDBG printk("EZK %s:%d:%s\n",__FILE__,__LINE__,__FUNCTION__)
+#if 0
+# define EZKDBG1 printk("EZK %s:%d\n",__FILE__,__LINE__)
+#else
+# define EZKDBG1
+#endif
+
+extern int fist_get_debug_value(void);
+extern int fist_set_debug_value(int val);
+#if 0 /* mini_fo doesn't need these */
+extern void fist_dprint_internal(int level, char *str,...);
+extern void fist_print_dentry(char *str, const dentry_t *dentry);
+extern void fist_print_inode(char *str, const inode_t *inode);
+extern void fist_print_file(char *str, const file_t *file);
+extern void fist_print_buffer_flags(char *str, struct buffer_head *buffer);
+extern void fist_print_page_flags(char *str, page_t *page);
+extern void fist_print_page_bytes(char *str, page_t *page);
+extern void fist_print_pte_flags(char *str, const page_t *page);
+extern void fist_checkinode(inode_t *inode, char *msg);
+extern void fist_print_sb(char *str, const super_block_t *sb);
+
+/* §$% by mk: special debug functions */
+extern void fist_mk_print_dentry(char *str, const dentry_t *dentry);
+extern void fist_mk_print_inode(char *str, const inode_t *inode);
+
+extern char *add_indent(void);
+extern char *del_indent(void);
+#endif/* mini_fo doesn't need these */
+
+
+#define STATIC
+#define ASSERT(EX)	\
+do {	\
+    if (!(EX)) {	\
+	printk(KERN_CRIT "ASSERTION FAILED: %s at %s:%d (%s)\n", #EX,	\
+	       __FILE__, __LINE__, __FUNCTION__);	\
+	(*((char *)0))=0;	\
+    }	\
+} while (0)
+/* same ASSERT, but tell me who was the caller of the function */
+#define ASSERT2(EX)	\
+do {	\
+    if (!(EX)) {	\
+	printk(KERN_CRIT "ASSERTION FAILED (caller): %s at %s:%d (%s)\n", #EX,	\
+	       file, line, func);	\
+	(*((char *)0))=0;	\
+    }	\
+} while (0)
+
+#if 0 /* mini_fo doesn't need these */
+#define dprintk(format, args...) printk(KERN_DEBUG format, ##args)
+#define fist_dprint(level, str, args...) fist_dprint_internal(level, KERN_DEBUG str, ## args)
+#define print_entry_location() fist_dprint(4, "%sIN:  %s %s:%d\n", add_indent(), __FUNCTION__, __FILE__, __LINE__)
+#define print_exit_location() fist_dprint(4, "%s OUT: %s %s:%d\n", del_indent(), __FUNCTION__, __FILE__, __LINE__)
+#define print_exit_status(status) fist_dprint(4, "%s OUT: %s %s:%d, STATUS: %d\n", del_indent(), __FUNCTION__, __FILE__, __LINE__, status)
+#define print_exit_pointer(status) \
+do { \
+  if (IS_ERR(status)) \
+    fist_dprint(4, "%s OUT: %s %s:%d, RESULT: %ld\n", del_indent(), __FUNCTION__, __FILE__, __LINE__, PTR_ERR(status)); \
+  else \
+    fist_dprint(4, "%s OUT: %s %s:%d, RESULT: 0x%x\n", del_indent(), __FUNCTION__, __FILE__, __LINE__, PTR_ERR(status)); \
+} while (0)
+#endif/* mini_fo doesn't need these */
+
+#endif /* __KERNEL__ */
+
+
+/*
+ * DEFINITIONS FOR USER AND KERNEL CODE:
+ * (Note: ioctl numbers 1--9 are reserved for fistgen, the rest
+ *  are auto-generated automatically based on the user's .fist file.)
+ */
+# define FIST_IOCTL_GET_DEBUG_VALUE	_IOR(0x15, 1, int)
+# define FIST_IOCTL_SET_DEBUG_VALUE	_IOW(0x15, 2, int)
+
+#endif /* not __FIST_H_ */
diff -Nru linux-2.6.30.5/fs/mini_fo/inode.c linux-2.6.30.5-wrt/fs/mini_fo/inode.c
--- linux-2.6.30.5/fs/mini_fo/inode.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/fs/mini_fo/inode.c	2009-09-06 18:43:48.430666963 +0200
@@ -0,0 +1,1577 @@
+/*
+ * Copyright (c) 1997-2003 Erez Zadok
+ * Copyright (c) 2001-2003 Stony Brook University
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package, or get one from ftp://ftp.filesystems.org/pub/fist/COPYING.
+ *
+ * This Copyright notice must be kept intact and distributed with all
+ * fistgen sources INCLUDING sources generated by fistgen.
+ */
+/*
+ * Copyright (C) 2004, 2005 Markus Klotzbuecher <mk@creamnet.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+/*
+ *  $Id$
+ */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include "fist.h"
+#include "mini_fo.h"
+
+STATIC int
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+mini_fo_create(inode_t *dir, dentry_t *dentry, int mode, struct nameidata *nd)
+#else
+mini_fo_create(inode_t *dir, dentry_t *dentry, int mode)
+#endif
+{
+	int err = 0;
+
+	check_mini_fo_dentry(dentry);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	err = create_sto_reg_file(dentry, mode, nd);
+#else
+	err = create_sto_reg_file(dentry, mode);
+#endif
+	check_mini_fo_dentry(dentry);
+	return err;
+}
+
+
+STATIC dentry_t *
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+mini_fo_lookup(inode_t *dir, dentry_t *dentry, struct nameidata* nd)
+#else
+mini_fo_lookup(inode_t *dir, dentry_t *dentry)
+#endif
+{
+	int err = 0;
+	dentry_t *hidden_dir_dentry;
+	dentry_t *hidden_dentry = NULL;
+
+	dentry_t *hidden_sto_dir_dentry;
+	dentry_t *hidden_sto_dentry = NULL;
+
+	/* whiteout flag */
+	int del_flag = 0;
+	char *bpath = NULL;
+
+	const char *name;
+	unsigned int namelen;
+
+	/* Don't allow lookups of META-files */
+	namelen = strlen(META_FILENAME);
+	if(namelen == dentry->d_name.len) {
+		if(!strncmp(dentry->d_name.name, META_FILENAME, namelen)) {
+			err = -ENOENT;
+			goto out;
+		}
+	}
+
+	hidden_dir_dentry = dtohd(dentry->d_parent);
+	hidden_sto_dir_dentry = dtohd2(dentry->d_parent);
+
+	name = dentry->d_name.name;
+	namelen = dentry->d_name.len;
+
+	/* must initialize dentry operations */
+	dentry->d_op = &mini_fo_dops;
+
+	/* setup the del_flag */
+	del_flag = __meta_check_d_entry(dir, name, namelen);
+	bpath = __meta_check_r_entry(dir, name, namelen);
+
+	/* perform the lookups of base and storage files:
+	 *
+	 * This caused some serious trouble, as a lookup_one_len passing
+	 * a negative dentry oopses. Solution is to only do the lookup
+	 * if the dentry is positive, else we set it to NULL
+	 * More trouble, who said a *_dir_dentry can't be NULL?
+	 */
+	if(bpath) {
+		/* Cross-Interposing (C), yeah! */
+		hidden_dentry = bpath_walk(dir->i_sb, bpath);
+		if(!hidden_dentry || !hidden_dentry->d_inode) {
+			printk(KERN_CRIT "mini_fo_lookup: bpath_walk failed.\n");
+			err= -EINVAL;
+			goto out;
+		}
+
+		/* this can be set up safely without fear of spaghetti
+		 * interposing as it is only used for copying times */
+		hidden_dir_dentry = hidden_dentry->d_parent;
+		kfree(bpath);
+	}
+	else if(hidden_dir_dentry && hidden_dir_dentry->d_inode) {
+		mutex_lock(&hidden_dir_dentry->d_inode->i_mutex);
+		hidden_dentry =
+			lookup_one_len(name, hidden_dir_dentry, namelen);
+		mutex_unlock(&hidden_dir_dentry->d_inode->i_mutex);
+	} else {
+		hidden_dentry = NULL;
+	}
+
+	if(hidden_sto_dir_dentry && hidden_sto_dir_dentry->d_inode) {
+		mutex_lock(&hidden_sto_dir_dentry->d_inode->i_mutex);
+		hidden_sto_dentry =
+			lookup_one_len(name, hidden_sto_dir_dentry, namelen);
+		mutex_unlock(&hidden_sto_dir_dentry->d_inode->i_mutex);
+	} else {
+		hidden_sto_dentry =  NULL;
+	}
+
+	/* catch error in lookup */
+	if (IS_ERR(hidden_dentry) || IS_ERR(hidden_sto_dentry)) {
+		/* mk: we need to call dput on the dentry, whose
+		 * lookup_one_len operation failed, in order to avoid
+		 * unmount trouble.
+		 */
+		if(IS_ERR(hidden_dentry)) {
+			printk(KERN_CRIT "mini_fo_lookup: ERR from base dentry, lookup failed.\n");
+			err = PTR_ERR(hidden_dentry);
+		} else {
+			dput(hidden_dentry);
+		}
+		if(IS_ERR(hidden_sto_dentry)) {
+			printk(KERN_CRIT "mini_fo_lookup: ERR from storage dentry, lookup failed.\n");
+			err = PTR_ERR(hidden_sto_dentry);
+		} else {
+			dput(hidden_sto_dentry);
+		}
+		goto out;
+	}
+
+	/* allocate dentry private data */
+	__dtopd(dentry) = (struct mini_fo_dentry_info *)
+		kmalloc(sizeof(struct mini_fo_dentry_info), GFP_KERNEL);
+
+	if (!dtopd(dentry)) {
+		err = -ENOMEM;
+		goto out_dput;
+	}
+
+	/* check for different states of the mini_fo file to be looked up. */
+
+	/* state 1, file has been modified */
+	if(hidden_dentry && hidden_sto_dentry &&
+	   hidden_dentry->d_inode && hidden_sto_dentry->d_inode && !del_flag) {
+
+		/* update parent directory's atime */
+		fist_copy_attr_atime(dir, hidden_sto_dir_dentry->d_inode);
+
+		dtopd(dentry)->state = MODIFIED;
+		dtohd(dentry) = hidden_dentry;
+		dtohd2(dentry) = hidden_sto_dentry;
+
+		err = mini_fo_tri_interpose(hidden_dentry,
+					    hidden_sto_dentry,
+					    dentry, dir->i_sb, 1);
+		if (err) {
+			printk(KERN_CRIT "mini_fo_lookup: error interposing (state1).\n");
+			goto out_free;
+		}
+		goto out;
+	}
+	/* state 2, file is unmodified */
+	if(hidden_dentry && hidden_dentry->d_inode && !del_flag) {
+
+		fist_copy_attr_atime(dir, hidden_dir_dentry->d_inode);
+
+		dtopd(dentry)->state = UNMODIFIED;
+		dtohd(dentry) = hidden_dentry;
+		dtohd2(dentry) = hidden_sto_dentry; /* could be negative */
+
+		err = mini_fo_tri_interpose(hidden_dentry,
+					    hidden_sto_dentry,
+					    dentry, dir->i_sb, 1);
+		if (err) {
+			printk(KERN_CRIT "mini_fo_lookup: error interposing (state2).\n");
+			goto out_free;
+		}
+		goto out;
+	}
+	/* state 3, file has been newly created */
+	if(hidden_sto_dentry && hidden_sto_dentry->d_inode && !del_flag) {
+
+		fist_copy_attr_atime(dir, hidden_sto_dir_dentry->d_inode);
+		dtopd(dentry)->state = CREATED;
+		dtohd(dentry) = hidden_dentry; /* could be negative */
+		dtohd2(dentry) = hidden_sto_dentry;
+
+		err = mini_fo_tri_interpose(hidden_dentry,
+					    hidden_sto_dentry,
+					    dentry, dir->i_sb, 1);
+		if (err) {
+			printk(KERN_CRIT "mini_fo_lookup: error interposing (state3).\n");
+			goto out_free;
+		}
+		goto out;
+	}
+
+	/* state 4, file has deleted and created again. */
+	if(hidden_dentry && hidden_sto_dentry &&
+	   hidden_dentry->d_inode &&
+	   hidden_sto_dentry->d_inode && del_flag) {
+
+		fist_copy_attr_atime(dir, hidden_sto_dir_dentry->d_inode);
+		dtopd(dentry)->state = DEL_REWRITTEN;
+		dtohd(dentry) = NULL;
+		dtohd2(dentry) = hidden_sto_dentry;
+
+		err = mini_fo_tri_interpose(NULL,
+					    hidden_sto_dentry,
+					    dentry, dir->i_sb, 1);
+		if (err) {
+			printk(KERN_CRIT "mini_fo_lookup: error interposing (state4).\n");
+			goto out_free;
+		}
+		/* We will never need this dentry again, as the file has been
+		 * deleted from base */
+		dput(hidden_dentry);
+		goto out;
+	}
+	/* state 5, file has been deleted in base */
+	if(hidden_dentry && hidden_sto_dentry &&
+	   hidden_dentry->d_inode &&
+	   !hidden_sto_dentry->d_inode && del_flag) {
+
+		/* check which parents atime we need for updating */
+		if(hidden_sto_dir_dentry->d_inode)
+			fist_copy_attr_atime(dir,
+					     hidden_sto_dir_dentry->d_inode);
+		else
+			fist_copy_attr_atime(dir,
+					     hidden_dir_dentry->d_inode);
+
+		dtopd(dentry)->state = DELETED;
+		dtohd(dentry) = NULL;
+		dtohd2(dentry) = hidden_sto_dentry;
+
+		/* add negative dentry to dcache to speed up lookups */
+		d_add(dentry, NULL);
+		dput(hidden_dentry);
+		goto out;
+	}
+	/* state 6, file does not exist */
+	if(((hidden_dentry && !hidden_dentry->d_inode) ||
+	    (hidden_sto_dentry && !hidden_sto_dentry->d_inode)) && !del_flag)
+		{
+			/* check which parents atime we need for updating */
+			if(hidden_sto_dir_dentry && hidden_sto_dir_dentry->d_inode)
+				fist_copy_attr_atime(dir, hidden_sto_dir_dentry->d_inode);
+			else
+				fist_copy_attr_atime(dir, hidden_dir_dentry->d_inode);
+
+			dtopd(dentry)->state = NON_EXISTANT;
+			dtohd(dentry) = hidden_dentry;
+			dtohd2(dentry) = hidden_sto_dentry;
+			d_add(dentry, NULL);
+			goto out;
+		}
+
+	/* if we get to here, were in an invalid state. bad. */
+	printk(KERN_CRIT "mini_fo_lookup: ERROR, meta data corruption detected.\n");
+
+	/* end state checking */
+ out_free:
+	d_drop(dentry);		/* so that our bad dentry will get destroyed */
+	kfree(dtopd(dentry));
+	__dtopd(dentry) = NULL;	/* be safe */
+
+ out_dput:
+	if(hidden_dentry)
+		dput(hidden_dentry);
+	if(hidden_sto_dentry)
+		dput(hidden_sto_dentry); /* drops usage count and marks for release */
+
+ out:
+	/* initalize wol if file exists and is directory */
+	if(dentry->d_inode) {
+		if(S_ISDIR(dentry->d_inode->i_mode)) {
+			itopd(dentry->d_inode)->deleted_list_size = -1;
+			itopd(dentry->d_inode)->renamed_list_size = -1;
+			meta_build_lists(dentry);
+		}
+	}
+	return ERR_PTR(err);
+}
+
+
+STATIC int
+mini_fo_link(dentry_t *old_dentry, inode_t *dir, dentry_t *new_dentry)
+{
+	int err;
+	dentry_t *hidden_old_dentry;
+	dentry_t *hidden_new_dentry;
+	dentry_t *hidden_dir_dentry;
+
+
+	check_mini_fo_dentry(old_dentry);
+	check_mini_fo_dentry(new_dentry);
+	check_mini_fo_inode(dir);
+
+	/* no links to directorys and existing targets target allowed */
+	if(S_ISDIR(old_dentry->d_inode->i_mode) ||
+	   is_mini_fo_existant(new_dentry)) {
+		err = -EPERM;
+		goto out;
+	}
+
+	/* bring it directly from unmod to del_rew */
+	if(dtost(old_dentry) == UNMODIFIED) {
+		err = nondir_unmod_to_mod(old_dentry, 1);
+		if(err) {
+			err = -EINVAL;
+			goto out;
+		}
+		err = meta_add_d_entry(old_dentry->d_parent,
+				       old_dentry->d_name.name,
+				       old_dentry->d_name.len);
+		if(err) {
+			err = -EINVAL;
+			goto out;
+		}
+		dput(dtohd(old_dentry));
+		dtohd(old_dentry) = NULL;
+		dtost(old_dentry) = DEL_REWRITTEN;
+	}
+
+	err = get_neg_sto_dentry(new_dentry);
+	if(err) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	hidden_old_dentry = dtohd2(old_dentry);
+	hidden_new_dentry = dtohd2(new_dentry);
+
+	dget(hidden_old_dentry);
+	dget(hidden_new_dentry);
+
+	/* was: hidden_dir_dentry = lock_parent(hidden_new_dentry); */
+	hidden_dir_dentry = dget(hidden_new_dentry->d_parent);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+	mutex_lock(&hidden_dir_dentry->d_inode->i_mutex);
+#else
+	down(&hidden_dir_dentry->d_inode->i_sem);
+#endif
+
+	err = vfs_link(hidden_old_dentry,
+		       hidden_dir_dentry->d_inode,
+		       hidden_new_dentry);
+	if (err || !hidden_new_dentry->d_inode)
+		goto out_lock;
+
+	dtost(new_dentry) = CREATED;
+ 	err = mini_fo_tri_interpose(NULL, hidden_new_dentry, new_dentry, dir->i_sb, 0);
+	if (err)
+		goto out_lock;
+
+	fist_copy_attr_timesizes(dir, hidden_new_dentry->d_inode);
+	/* propagate number of hard-links */
+	old_dentry->d_inode->i_nlink = itohi2(old_dentry->d_inode)->i_nlink;
+
+ out_lock:
+	/* was: unlock_dir(hidden_dir_dentry); */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+	mutex_unlock(&hidden_dir_dentry->d_inode->i_mutex);
+#else
+	up(&hidden_dir_dentry->d_inode->i_sem);
+#endif
+	dput(hidden_dir_dentry);
+
+	dput(hidden_new_dentry);
+	dput(hidden_old_dentry);
+	if (!new_dentry->d_inode)
+		d_drop(new_dentry);
+
+ out:
+	return err;
+}
+
+
+STATIC int
+mini_fo_unlink(inode_t *dir, dentry_t *dentry)
+{
+	int err = 0;
+
+	dget(dentry);
+	if(dtopd(dentry)->state == MODIFIED) {
+		err = nondir_mod_to_del(dentry);
+		goto out;
+	}
+	else if(dtopd(dentry)->state == UNMODIFIED) {
+		err = nondir_unmod_to_del(dentry);
+		goto out;
+	}
+	else if(dtopd(dentry)->state == CREATED) {
+		err = nondir_creat_to_del(dentry);
+		goto out;
+	}
+	else if(dtopd(dentry)->state == DEL_REWRITTEN) {
+		err = nondir_del_rew_to_del(dentry);
+		goto out;
+	}
+
+	printk(KERN_CRIT "mini_fo_unlink: ERROR, invalid state detected.\n");
+
+ out:
+	fist_copy_attr_times(dir, itohi2(dentry->d_parent->d_inode));
+
+	if(!err) {
+		/* is this causing my pain? d_delete(dentry); */
+		d_drop(dentry);
+	}
+
+	dput(dentry);
+	return err;
+}
+
+
+STATIC int
+mini_fo_symlink(inode_t *dir, dentry_t *dentry, const char *symname)
+{
+	int err=0;
+	dentry_t *hidden_sto_dentry;
+	dentry_t *hidden_sto_dir_dentry;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27))
+        umode_t mode;
+#endif
+
+	/* Fail if the symlink file exists */
+	if(!(dtost(dentry) == DELETED ||
+	     dtost(dentry) == NON_EXISTANT)) {
+		err = -EEXIST;
+		goto out;
+	}
+
+	err = get_neg_sto_dentry(dentry);
+	if(err) {
+		err = -EINVAL;
+		goto out;
+	}
+	hidden_sto_dentry = dtohd2(dentry);
+
+	dget(hidden_sto_dentry);
+	/* was: hidden_sto_dir_dentry = lock_parent(hidden_sto_dentry); */
+	hidden_sto_dir_dentry = dget(hidden_sto_dentry->d_parent);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+	mutex_lock(&hidden_sto_dir_dentry->d_inode->i_mutex);
+#else
+	down(&hidden_sto_dir_dentry->d_inode->i_sem);
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27))
+	mode = S_IALLUGO;
+	err = vfs_symlink(hidden_sto_dir_dentry->d_inode,
+			  hidden_sto_dentry, symname, mode);
+#else
+	err = vfs_symlink(hidden_sto_dir_dentry->d_inode,
+			  hidden_sto_dentry,
+			  symname);
+#endif
+	if (err || !hidden_sto_dentry->d_inode)
+                goto out_lock;
+
+        if(dtost(dentry) == DELETED) {
+                dtost(dentry) = DEL_REWRITTEN;
+                err = mini_fo_tri_interpose(NULL, hidden_sto_dentry, dentry, dir->i_sb, 0);
+                if(err)
+                        goto out_lock;
+        } else if(dtost(dentry) == NON_EXISTANT) {
+                dtost(dentry) = CREATED;
+                err = mini_fo_tri_interpose(dtohd(dentry), hidden_sto_dentry, dentry, dir->i_sb, 0);
+                if(err)
+                        goto out_lock;
+        }
+	fist_copy_attr_timesizes(dir, hidden_sto_dir_dentry->d_inode);
+
+ out_lock:
+        /* was: unlock_dir(hidden_sto_dir_dentry); */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+	mutex_unlock(&hidden_sto_dir_dentry->d_inode->i_mutex);
+#else
+	up(&hidden_sto_dir_dentry->d_inode->i_sem);
+#endif
+	dput(hidden_sto_dir_dentry);
+
+        dput(hidden_sto_dentry);
+        if (!dentry->d_inode)
+                d_drop(dentry);
+ out:
+        return err;
+}
+
+STATIC int
+mini_fo_mkdir(inode_t *dir, dentry_t *dentry, int mode)
+{
+	int err;
+
+	err = create_sto_dir(dentry, mode);
+
+	check_mini_fo_dentry(dentry);
+
+	return err;
+}
+
+
+STATIC int
+mini_fo_rmdir(inode_t *dir, dentry_t *dentry)
+{
+	int err = 0;
+
+	dentry_t *hidden_sto_dentry;
+	dentry_t *hidden_sto_dir_dentry;
+	dentry_t *meta_dentry;
+	inode_t *hidden_sto_dir = NULL;
+
+	check_mini_fo_dentry(dentry);
+	check_mini_fo_inode(dir);
+
+	dget(dentry);
+	if(dtopd(dentry)->state == MODIFIED) {
+		/* XXX: disabled, because it does not bother to check files on
+		 * the original filesystem - just a hack, but better than simply
+		 * removing it without testing */
+		err = -EINVAL;
+		goto out;
+
+		hidden_sto_dir = itohi2(dir);
+		hidden_sto_dentry = dtohd2(dentry);
+
+		/* was:hidden_sto_dir_dentry = lock_parent(hidden_sto_dentry); */
+		hidden_sto_dir_dentry = dget(hidden_sto_dentry->d_parent);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+		mutex_lock(&hidden_sto_dir_dentry->d_inode->i_mutex);
+#else
+		down(&hidden_sto_dir_dentry->d_inode->i_sem);
+#endif
+
+		/* Delete an old WOL file contained in the storage dir */
+		mutex_lock(&hidden_sto_dentry->d_inode->i_mutex);
+		meta_dentry = lookup_one_len(META_FILENAME,
+					     hidden_sto_dentry,
+					     strlen(META_FILENAME));
+		mutex_unlock(&hidden_sto_dentry->d_inode->i_mutex);
+		if(meta_dentry->d_inode) {
+			err = vfs_unlink(hidden_sto_dentry->d_inode, meta_dentry);
+			dput(meta_dentry);
+			if(!err)
+				d_delete(meta_dentry);
+		}
+
+		err = vfs_rmdir(hidden_sto_dir, hidden_sto_dentry);
+		dput(hidden_sto_dentry);
+		if(!err)
+			d_delete(hidden_sto_dentry);
+
+		/* propagate number of hard-links */
+		dentry->d_inode->i_nlink = itohi2(dentry->d_inode)->i_nlink;
+
+		dput(dtohd(dentry));
+
+		dtohd(dentry) = NULL;
+		dtopd(dentry)->state = DELETED;
+
+		/* carefull with R files */
+		if( __meta_is_r_entry(dir,
+				      dentry->d_name.name,
+				      dentry->d_name.len) == 1) {
+			err = meta_remove_r_entry(dentry->d_parent,
+						  dentry->d_name.name,
+						  dentry->d_name.len);
+			if(err) {
+				printk(KERN_CRIT "mini_fo: rmdir: meta_remove_r_entry failed.\n");
+				goto out;
+			}
+		}
+		else {
+			/* ok, add deleted file to META */
+			meta_add_d_entry(dentry->d_parent,
+					 dentry->d_name.name,
+					 dentry->d_name.len);
+		}
+		/* was: unlock_dir(hidden_sto_dir_dentry); */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+		mutex_unlock(&hidden_sto_dir_dentry->d_inode->i_mutex);
+#else
+		up(&hidden_sto_dir_dentry->d_inode->i_sem);
+#endif
+		dput(hidden_sto_dir_dentry);
+		goto out;
+	}
+	else if(dtopd(dentry)->state == UNMODIFIED) {
+		/* XXX: simply adding it to the delete list here is fscking dangerous!
+		 * as a temporary hack, i will disable rmdir on unmodified directories
+		 * for now.
+		 */
+		err = -EINVAL;
+		goto out;
+
+		err = get_neg_sto_dentry(dentry);
+		if(err) {
+			err = -EINVAL;
+			goto out;
+		}
+
+		/* dput base dentry, this will relase the inode and free the
+		 * dentry, as we will never need it again. */
+		dput(dtohd(dentry));
+		dtohd(dentry) = NULL;
+		dtopd(dentry)->state = DELETED;
+
+		/* add deleted file to META-file */
+		meta_add_d_entry(dentry->d_parent,
+				 dentry->d_name.name,
+				 dentry->d_name.len);
+		goto out;
+	}
+	else if(dtopd(dentry)->state == CREATED) {
+		hidden_sto_dir = itohi2(dir);
+		hidden_sto_dentry = dtohd2(dentry);
+
+		/* was: hidden_sto_dir_dentry = lock_parent(hidden_sto_dentry);*/
+		hidden_sto_dir_dentry = dget(hidden_sto_dentry->d_parent);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+		mutex_lock(&hidden_sto_dir_dentry->d_inode->i_mutex);
+#else
+		down(&hidden_sto_dir_dentry->d_inode->i_sem);
+#endif
+
+		/* Delete an old WOL file contained in the storage dir */
+		mutex_lock(&hidden_sto_dentry->d_inode->i_mutex);
+		meta_dentry = lookup_one_len(META_FILENAME,
+					     hidden_sto_dentry,
+					     strlen(META_FILENAME));
+		mutex_unlock(&hidden_sto_dentry->d_inode->i_mutex);
+		if(meta_dentry->d_inode) {
+			/* is this necessary? dget(meta_dentry); */
+			err = vfs_unlink(hidden_sto_dentry->d_inode,
+					 meta_dentry);
+			dput(meta_dentry);
+			if(!err)
+				d_delete(meta_dentry);
+		}
+
+		err = vfs_rmdir(hidden_sto_dir, hidden_sto_dentry);
+		dput(hidden_sto_dentry);
+		if(!err)
+			d_delete(hidden_sto_dentry);
+
+		/* propagate number of hard-links */
+		dentry->d_inode->i_nlink = itohi2(dentry->d_inode)->i_nlink;
+		dtopd(dentry)->state = NON_EXISTANT;
+
+		/* was: unlock_dir(hidden_sto_dir_dentry); */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+		mutex_unlock(&hidden_sto_dir_dentry->d_inode->i_mutex);
+#else
+		up(&hidden_sto_dir_dentry->d_inode->i_sem);
+#endif
+		dput(hidden_sto_dir_dentry);
+
+		goto out;
+	}
+	else if(dtopd(dentry)->state == DEL_REWRITTEN) {
+		hidden_sto_dir = itohi2(dir);
+		hidden_sto_dentry = dtohd2(dentry);
+
+		/* was: hidden_sto_dir_dentry = lock_parent(hidden_sto_dentry);*/
+		hidden_sto_dir_dentry = dget(hidden_sto_dentry->d_parent);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+		mutex_lock(&hidden_sto_dir_dentry->d_inode->i_mutex);
+#else
+		down(&hidden_sto_dir_dentry->d_inode->i_sem);
+#endif
+
+		/* Delete an old WOL file contained in the storage dir */
+		mutex_lock(&hidden_sto_dentry->d_inode->i_mutex);
+		meta_dentry = lookup_one_len(META_FILENAME,
+					     hidden_sto_dentry,
+					     strlen(META_FILENAME));
+		mutex_unlock(&hidden_sto_dentry->d_inode->i_mutex);
+		if(meta_dentry->d_inode) {
+			/* is this necessary? dget(meta_dentry); */
+			err = vfs_unlink(hidden_sto_dentry->d_inode,
+					 meta_dentry);
+			dput(meta_dentry);
+			if(!err)
+				d_delete(meta_dentry);
+		}
+
+		err = vfs_rmdir(hidden_sto_dir, hidden_sto_dentry);
+		dput(hidden_sto_dentry);
+		if(!err)
+			d_delete(hidden_sto_dentry);
+
+		/* propagate number of hard-links */
+		dentry->d_inode->i_nlink = itohi2(dentry->d_inode)->i_nlink;
+		dtopd(dentry)->state = DELETED;
+		/* was: unlock_dir(hidden_sto_dir_dentry); */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+		mutex_unlock(&hidden_sto_dir_dentry->d_inode->i_mutex);
+#else
+		up(&hidden_sto_dir_dentry->d_inode->i_sem);
+#endif
+		dput(hidden_sto_dir_dentry);
+		goto out;
+	}
+
+	printk(KERN_CRIT "mini_fo_rmdir: ERROR, invalid state detected.\n");
+
+ out:
+	if(!err) {
+		d_drop(dentry);
+	}
+
+	fist_copy_attr_times(dir, itohi2(dentry->d_parent->d_inode));
+	dput(dentry);
+
+	return err;
+}
+
+
+STATIC int
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+mini_fo_mknod(inode_t *dir, dentry_t *dentry, int mode, dev_t dev)
+#else
+mini_fo_mknod(inode_t *dir, dentry_t *dentry, int mode, int dev)
+#endif
+{
+	int err = 0;
+
+	check_mini_fo_dentry(dentry);
+
+	err = create_sto_nod(dentry, mode, dev);
+	if(err) {
+		printk(KERN_CRIT "mini_fo_mknod: creating sto nod failed.\n");
+		err = -EINVAL;
+	}
+
+	check_mini_fo_dentry(dentry);
+	return err;
+}
+
+
+STATIC int
+mini_fo_rename(inode_t *old_dir, dentry_t *old_dentry,
+	       inode_t *new_dir, dentry_t *new_dentry)
+{
+	/* dispatch */
+	if(S_ISDIR(old_dentry->d_inode->i_mode))
+		return rename_directory(old_dir, old_dentry, new_dir, new_dentry);
+	return rename_nondir(old_dir, old_dentry, new_dir, new_dentry);
+
+}
+
+int rename_directory(inode_t *old_dir, dentry_t *old_dentry,
+		     inode_t *new_dir, dentry_t *new_dentry)
+{
+	int err, bpath_len;
+	char *bpath;
+
+	dentry_t *hidden_old_dentry;
+	dentry_t *hidden_new_dentry;
+	dentry_t *hidden_old_dir_dentry;
+	dentry_t *hidden_new_dir_dentry;
+
+	err = 0;
+	bpath = NULL;
+	bpath_len = 0;
+
+	/* this is a test, chuck out if it works */
+	if(!(dtopd(new_dentry)->state == DELETED ||
+	     dtopd(new_dentry)->state == NON_EXISTANT)) {
+		printk(KERN_CRIT "mini_fo: rename_directory: \
+                                  uh, ah, new_dentry not negative.\n");
+		/* return -1; */
+	}
+
+	/* state = UNMODIFIED */
+	if(dtopd(old_dentry)->state == UNMODIFIED) {
+		err = dir_unmod_to_mod(old_dentry);
+		if (err)
+			goto out;
+	}
+
+	/* state = MODIFIED */
+	if(dtopd(old_dentry)->state == MODIFIED) {
+		bpath = meta_check_r_entry(old_dentry->d_parent,
+					   old_dentry->d_name.name,
+					   old_dentry->d_name.len);
+		if(bpath) {
+			err = meta_remove_r_entry(old_dentry->d_parent,
+						  old_dentry->d_name.name,
+						  old_dentry->d_name.len);
+			if(err) {
+				printk(KERN_CRIT "mini_fo: rename_directory:\
+                                                   meta_remove_r_entry \
+                                                  failed.\n");
+				goto out;
+			}
+			err = meta_add_r_entry(new_dentry->d_parent,
+					       bpath,
+					       strlen(bpath),
+					       new_dentry->d_name.name,
+					       new_dentry->d_name.len);
+			kfree(bpath);
+		}
+		else {/* wol it */
+			err = meta_add_d_entry(old_dentry->d_parent,
+					       old_dentry->d_name.name,
+					       old_dentry->d_name.len);
+			if (err)
+				goto out;
+			/* put it on rename list */
+			err = get_mini_fo_bpath(old_dentry,
+						&bpath,
+						&bpath_len);
+			if (err)
+				goto out;
+			err = meta_add_r_entry(new_dentry->d_parent,
+					       bpath, bpath_len,
+					       new_dentry->d_name.name,
+					       new_dentry->d_name.len);
+			if (err)
+				goto out;
+		}
+		/* no state change, MODIFIED stays MODIFIED */
+	}
+	/* state = CREATED */
+	if(dtopd(old_dentry)->state == CREATED ||
+	   dtopd(old_dentry)->state == DEL_REWRITTEN) {
+		if(dtohd(old_dentry))
+			dput(dtohd(old_dentry));
+
+		if(dtopd(new_dentry)->state == DELETED) {
+			dtopd(old_dentry)->state = DEL_REWRITTEN;
+			dtohd(old_dentry) = NULL;
+		}
+		else if(dtopd(new_dentry)->state == NON_EXISTANT) {
+			dtopd(old_dentry)->state = CREATED;
+			/* steal new dentry's neg. base dentry */
+			dtohd(old_dentry) = dtohd(new_dentry);
+			dtohd(new_dentry) = NULL;
+		}
+	}
+	if(dtopd(new_dentry)->state == UNMODIFIED ||
+	   dtopd(new_dentry)->state == NON_EXISTANT) {
+		err = get_neg_sto_dentry(new_dentry);
+		if(err)
+			goto out;
+	}
+
+	/* now move sto file */
+	hidden_old_dentry = dtohd2(old_dentry);
+	hidden_new_dentry = dtohd2(new_dentry);
+
+	dget(hidden_old_dentry);
+	dget(hidden_new_dentry);
+
+	hidden_old_dir_dentry = dget(hidden_old_dentry->d_parent);
+	hidden_new_dir_dentry = dget(hidden_new_dentry->d_parent);
+	double_lock(hidden_old_dir_dentry, hidden_new_dir_dentry);
+
+	err = vfs_rename(hidden_old_dir_dentry->d_inode, hidden_old_dentry,
+			 hidden_new_dir_dentry->d_inode, hidden_new_dentry);
+	if(err)
+		goto out_lock;
+
+	fist_copy_attr_all(new_dir, hidden_new_dir_dentry->d_inode);
+	if (new_dir != old_dir)
+		fist_copy_attr_all(old_dir,
+				   hidden_old_dir_dentry->d_inode);
+
+ out_lock:
+	/* double_unlock will dput the new/old parent dentries
+	 * whose refcnts were incremented via get_parent above. */
+	double_unlock(hidden_old_dir_dentry, hidden_new_dir_dentry);
+	dput(hidden_new_dentry);
+	dput(hidden_old_dentry);
+
+ out:
+	return err;
+}
+
+int rename_nondir(inode_t *old_dir, dentry_t *old_dentry,
+		  inode_t *new_dir, dentry_t *new_dentry)
+{
+	int err=0;
+
+	check_mini_fo_dentry(old_dentry);
+	check_mini_fo_dentry(new_dentry);
+	check_mini_fo_inode(old_dir);
+	check_mini_fo_inode(new_dir);
+
+	/* state: UNMODIFIED */
+	if(dtost(old_dentry) == UNMODIFIED) {
+		err = nondir_unmod_to_mod(old_dentry, 1);
+		if(err) {
+			err = -EINVAL;
+			goto out;
+		}
+	}
+
+	/* the easy states */
+	if(exists_in_storage(old_dentry)) {
+
+		dentry_t *hidden_old_dentry;
+		dentry_t *hidden_new_dentry;
+		dentry_t *hidden_old_dir_dentry;
+		dentry_t *hidden_new_dir_dentry;
+
+		/* if old file is MODIFIED, add it to the deleted_list */
+		if(dtopd(old_dentry)->state == MODIFIED) {
+			meta_add_d_entry(old_dentry->d_parent,
+					 old_dentry->d_name.name,
+					 old_dentry->d_name.len);
+
+			dput(dtohd(old_dentry));
+		}
+		/* if old file is CREATED, we only release the base dentry */
+		if(dtopd(old_dentry)->state == CREATED) {
+			if(dtohd(old_dentry))
+				dput(dtohd(old_dentry));
+		}
+
+		/* now setup the new states (depends on new_dentry state) */
+		/* new dentry state =  MODIFIED */
+		if(dtopd(new_dentry)->state == MODIFIED) {
+			meta_add_d_entry(new_dentry->d_parent,
+					 new_dentry->d_name.name,
+					 new_dentry->d_name.len);
+
+			/* new dentry will be d_put'ed later by the vfs
+			 * so don't do it here
+			 * dput(dtohd(new_dentry));
+			 */
+			dtohd(old_dentry) = NULL;
+			dtopd(old_dentry)->state = DEL_REWRITTEN;
+		}
+		/* new dentry state =  UNMODIFIED */
+		else if(dtopd(new_dentry)->state == UNMODIFIED) {
+			if(get_neg_sto_dentry(new_dentry))
+				return -EINVAL;
+
+			meta_add_d_entry(new_dentry->d_parent,
+					 new_dentry->d_name.name,
+					 new_dentry->d_name.len);
+
+			/* is this right??? */
+			/*dput(dtohd(new_dentry));*/
+			dtohd(old_dentry) = NULL;
+			dtopd(old_dentry)->state = DEL_REWRITTEN;
+		}
+		/* new dentry state =  CREATED */
+		else if(dtopd(new_dentry)->state == CREATED) {
+			/* we keep the neg. base dentry (if exists) */
+			dtohd(old_dentry) = dtohd(new_dentry);
+			/* ...and set it to Null, or we'll get
+			 * dcache.c:345 if it gets dput twice... */
+			dtohd(new_dentry) = NULL;
+			dtopd(old_dentry)->state = CREATED;
+		}
+		/* new dentry state =  NON_EXISTANT */
+		else if(dtopd(new_dentry)->state == NON_EXISTANT) {
+			if(get_neg_sto_dentry(new_dentry))
+				return -EINVAL;
+
+			/* we keep the neg. base dentry (if exists) */
+			dtohd(old_dentry) = dtohd(new_dentry);
+			/* ...and set it to Null, or we'll get
+			 * Dr. dcache.c:345 if it gets dput twice... */
+			dtohd(new_dentry) = NULL;
+			dtopd(old_dentry)->state = CREATED;
+		}
+		/* new dentry state =  DEL_REWRITTEN or DELETED */
+		else if(dtopd(new_dentry)->state == DEL_REWRITTEN ||
+			dtopd(new_dentry)->state == DELETED) {
+			dtohd(old_dentry) = NULL;
+			dtopd(old_dentry)->state = DEL_REWRITTEN;
+		}
+		else { /* not possible, uhh, ahh */
+			printk(KERN_CRIT
+			       "mini_fo: rename_reg_file: invalid state detected [1].\n");
+			return -1;
+		}
+
+		/* now we definitely have a sto file */
+		hidden_old_dentry = dtohd2(old_dentry);
+		hidden_new_dentry = dtohd2(new_dentry);
+
+		dget(hidden_old_dentry);
+		dget(hidden_new_dentry);
+
+		hidden_old_dir_dentry = dget(hidden_old_dentry->d_parent);
+		hidden_new_dir_dentry = dget(hidden_new_dentry->d_parent);
+		double_lock(hidden_old_dir_dentry, hidden_new_dir_dentry);
+
+		err = vfs_rename(hidden_old_dir_dentry->d_inode,
+				 hidden_old_dentry,
+				 hidden_new_dir_dentry->d_inode,
+				 hidden_new_dentry);
+		if(err)
+			goto out_lock;
+
+		fist_copy_attr_all(new_dir, hidden_new_dir_dentry->d_inode);
+		if (new_dir != old_dir)
+			fist_copy_attr_all(old_dir, hidden_old_dir_dentry->d_inode);
+
+	out_lock:
+		/* double_unlock will dput the new/old parent dentries
+		 * whose refcnts were incremented via get_parent above.
+		 */
+		double_unlock(hidden_old_dir_dentry, hidden_new_dir_dentry);
+		dput(hidden_new_dentry);
+		dput(hidden_old_dentry);
+	out:
+		return err;
+	}
+	else { /* invalid state */
+		printk(KERN_CRIT "mini_fo: rename_reg_file: ERROR: invalid state detected [2].\n");
+		return -1;
+	}
+}
+
+
+STATIC int
+mini_fo_readlink(dentry_t *dentry, char *buf, int bufsiz)
+{
+	int err=0;
+	dentry_t *hidden_dentry = NULL;
+
+	if(dtohd2(dentry) && dtohd2(dentry)->d_inode) {
+		hidden_dentry = dtohd2(dentry);
+	} else if(dtohd(dentry) && dtohd(dentry)->d_inode) {
+		hidden_dentry = dtohd(dentry);
+	} else {
+		goto out;
+	}
+
+	if (!hidden_dentry->d_inode->i_op ||
+	    !hidden_dentry->d_inode->i_op->readlink) {
+		err = -EINVAL;		goto out;
+	}
+
+	err = hidden_dentry->d_inode->i_op->readlink(hidden_dentry,
+						     buf,
+						     bufsiz);
+	if (err > 0)
+		fist_copy_attr_atime(dentry->d_inode, hidden_dentry->d_inode);
+
+ out:
+	return err;
+}
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
+static int mini_fo_follow_link(dentry_t *dentry, struct nameidata *nd)
+#else
+static void* mini_fo_follow_link(dentry_t *dentry, struct nameidata *nd)
+#endif
+{
+	char *buf;
+	int len = PAGE_SIZE, err;
+	mm_segment_t old_fs;
+
+	/* in 2.6 this is freed by mini_fo_put_link called by __do_follow_link */
+	buf = kmalloc(len, GFP_KERNEL);
+	if (!buf) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	/* read the symlink, and then we will follow it */
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	err = dentry->d_inode->i_op->readlink(dentry, buf, len);
+	set_fs(old_fs);
+	if (err < 0) {
+		kfree(buf);
+		buf = NULL;
+		goto out;
+	}
+	buf[err] = 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+        nd_set_link(nd, buf);
+        err = 0;
+#else
+	err = vfs_follow_link(nd, buf);
+#endif
+
+ out:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	kfree(buf);
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
+        return err;
+#else
+        return ERR_PTR(err);
+#endif
+}
+
+STATIC
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
+void mini_fo_put_link(struct dentry *dentry, struct nameidata *nd)
+#else
+void mini_fo_put_link(struct dentry *dentry, struct nameidata *nd, void *cookie)
+#endif
+{
+        char *link;
+        link = nd_get_link(nd);
+        kfree(link);
+}
+#endif
+
+STATIC int
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27))
+mini_fo_permission(inode_t *inode, int mask, struct nameidata *nd)
+#else
+mini_fo_permission(inode_t *inode, int mask)
+#endif
+{
+	inode_t *hidden_inode;
+	int mode;
+	int err;
+
+	if(itohi2(inode)) {
+		hidden_inode = itohi2(inode);
+	} else {
+		hidden_inode = itohi(inode);
+	}
+	mode = inode->i_mode;
+
+	/* not really needed, as permission handles everything:
+	 *	err = vfs_permission(inode, mask);
+	 *	if (err)
+	 *		goto out;
+	 */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+	err = inode_permission(hidden_inode, mask);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	err = permission(hidden_inode, mask, nd);
+#else
+	err = permission(hidden_inode, mask);
+#endif
+
+	/*  out: */
+	return err;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+STATIC int
+mini_fo_inode_revalidate(dentry_t *dentry)
+{
+	int err = 0;
+	dentry_t *hidden_dentry;
+	inode_t *hidden_inode;
+
+	ASSERT(dentry->d_inode);
+	ASSERT(itopd(dentry->d_inode));
+
+	if(itohi2(dentry->d_inode)) {
+                hidden_dentry = dtohd2(dentry);
+		hidden_inode = hidden_dentry->d_inode;
+	} else if(itohi(dentry->d_inode)) {
+                hidden_dentry = dtohd(dentry);
+		hidden_inode = hidden_dentry->d_inode;
+	} else {
+                printk(KERN_CRIT "mini_fo_inode_revalidate: ERROR, invalid state detected.\n");
+                err = -ENOENT;
+                goto out;
+        }
+	if (hidden_inode && hidden_inode->i_op && hidden_inode->i_op->revalidate){
+		err = hidden_inode->i_op->revalidate(hidden_dentry);
+		if (err)
+			goto out;
+	}
+	fist_copy_attr_all(dentry->d_inode, hidden_inode);
+ out:
+	return err;
+}
+#endif
+
+STATIC int
+mini_fo_setattr(dentry_t *dentry, struct iattr *ia)
+{
+	int err = 0;
+
+	check_mini_fo_dentry(dentry);
+
+	if(!is_mini_fo_existant(dentry)) {
+		printk(KERN_CRIT "mini_fo_setattr: ERROR, invalid state detected [1].\n");
+		goto out;
+	}
+
+	if(dtost(dentry) == UNMODIFIED) {
+		if(!IS_COPY_FLAG(ia->ia_valid))
+			goto out; /* we ignore these changes to base */
+
+		if(S_ISDIR(dentry->d_inode->i_mode)) {
+			err = dir_unmod_to_mod(dentry);
+		} else {
+			/* we copy contents if file is not beeing truncated */
+			if(S_ISREG(dentry->d_inode->i_mode) &&
+			   !(ia->ia_size == 0 && (ia->ia_valid & ATTR_SIZE))) {
+				err = nondir_unmod_to_mod(dentry, 1);
+			} else
+				err = nondir_unmod_to_mod(dentry, 0);
+		}
+		if(err) {
+			err = -EINVAL;
+			printk(KERN_CRIT "mini_fo_setattr: ERROR changing states.\n");
+			goto out;
+		}
+	}
+	if(!exists_in_storage(dentry)) {
+		printk(KERN_CRIT "mini_fo_setattr: ERROR, invalid state detected [2].\n");
+		err = -EINVAL;
+		goto out;
+	}
+	ASSERT(dentry->d_inode);
+	ASSERT(dtohd2(dentry));
+	ASSERT(itopd(dentry->d_inode));
+	ASSERT(itohi2(dentry->d_inode));
+
+	err = notify_change(dtohd2(dentry), ia);
+	fist_copy_attr_all(dentry->d_inode, itohi2(dentry->d_inode));
+ out:
+	return err;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+STATIC int
+mini_fo_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
+{
+	int err = 0;
+        dentry_t *hidden_dentry;
+
+	ASSERT(dentry->d_inode);
+	ASSERT(itopd(dentry->d_inode));
+
+	if(itohi2(dentry->d_inode)) {
+                hidden_dentry = dtohd2(dentry);
+	} else if(itohi(dentry->d_inode)) {
+                hidden_dentry = dtohd(dentry);
+	} else {
+                printk(KERN_CRIT "mini_fo_getattr: ERROR, invalid state detected.\n");
+                err = -ENOENT;
+                goto out;
+        }
+	fist_copy_attr_all(dentry->d_inode, hidden_dentry->d_inode);
+
+	ASSERT(hidden_dentry);
+	ASSERT(hidden_dentry->d_inode);
+	ASSERT(hidden_dentry->d_inode->i_op);
+
+	generic_fillattr(dentry->d_inode, stat);
+	if (!stat->blksize) {
+		struct super_block *s = hidden_dentry->d_inode->i_sb;
+		unsigned blocks;
+		blocks = (stat->size+s->s_blocksize-1) >> s->s_blocksize_bits;
+		stat->blocks = (s->s_blocksize / 512) * blocks;
+		stat->blksize = s->s_blocksize;
+	}
+ out:
+        return err;
+}
+#endif
+
+#if defined(XATTR) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,20))
+#if 0 /* no xattr_alloc() and xattr_free() */
+/* This is lifted from fs/xattr.c */
+static void *
+xattr_alloc(size_t size, size_t limit)
+{
+	void *ptr;
+
+	if (size > limit)
+		return ERR_PTR(-E2BIG);
+
+	if (!size)	/* size request, no buffer is needed */
+		return NULL;
+	else if (size <= PAGE_SIZE)
+		ptr = kmalloc((unsigned long) size, GFP_KERNEL);
+	else
+		ptr = vmalloc((unsigned long) size);
+	if (!ptr)
+		return ERR_PTR(-ENOMEM);
+	return ptr;
+}
+
+static void
+xattr_free(void *ptr, size_t size)
+{
+	if (!size)	/* size request, no buffer was needed */
+		return;
+	else if (size <= PAGE_SIZE)
+		kfree(ptr);
+	else
+		vfree(ptr);
+}
+#endif /* no xattr_alloc() and xattr_free() */
+
+/* BKL held by caller.
+ * dentry->d_inode->i_sem down
+ */
+STATIC int
+mini_fo_getxattr(struct dentry *dentry, const char *name, void *value, size_t size) {
+	struct dentry *hidden_dentry = NULL;
+	int err = -EOPNOTSUPP;
+	/* Define these anyway so we don't need as much ifdef'ed code. */
+	char *encoded_name = NULL;
+	char *encoded_value = NULL;
+
+	check_mini_fo_dentry(dentry);
+
+	if(exists_in_storage(dentry))
+		hidden_dentry = dtohd2(dentry);
+	else
+		hidden_dentry = dtohd(dentry);
+
+	ASSERT(hidden_dentry);
+	ASSERT(hidden_dentry->d_inode);
+	ASSERT(hidden_dentry->d_inode->i_op);
+
+	if (hidden_dentry->d_inode->i_op->getxattr) {
+		encoded_name = (char *)name;
+		encoded_value = (char *)value;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+		mutex_lock(&hidden_dentry->d_inode->i_mutex);
+#else
+		down(&hidden_dentry->d_inode->i_sem);
+#endif
+		/* lock_kernel() already done by caller. */
+		err = hidden_dentry->d_inode->i_op->getxattr(hidden_dentry, encoded_name, encoded_value, size);
+		/* unlock_kernel() will be done by caller. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+		mutex_lock(&hidden_dentry->d_inode->i_mutex);
+#else
+		up(&hidden_dentry->d_inode->i_sem);
+#endif
+	}
+	return err;
+}
+
+/* BKL held by caller.
+ * dentry->d_inode->i_sem down
+ */
+STATIC int
+#if ((LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,21) \
+     && LINUX_VERSION_CODE <= KERNEL_VERSION(2,4,23)) \
+     || LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0))
+mini_fo_setxattr(struct dentry *dentry, const char *name,
+		 const void *value, size_t size, int flags)
+#else
+mini_fo_setxattr(struct dentry *dentry, const char *name,
+		 void *value, size_t size, int flags)
+#endif
+
+{
+	struct dentry *hidden_dentry = NULL;
+	int err = -EOPNOTSUPP;
+
+	/* Define these anyway, so we don't have as much ifdef'ed code. */
+	char *encoded_value = NULL;
+	char *encoded_name = NULL;
+
+	check_mini_fo_dentry(dentry);
+
+	if(exists_in_storage(dentry))
+		hidden_dentry = dtohd2(dentry);
+	else
+		hidden_dentry = dtohd(dentry);
+
+	ASSERT(hidden_dentry);
+	ASSERT(hidden_dentry->d_inode);
+	ASSERT(hidden_dentry->d_inode->i_op);
+
+	if (hidden_dentry->d_inode->i_op->setxattr) {
+		encoded_name = (char *)name;
+		encoded_value = (char *)value;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+		mutex_lock(&hidden_dentry->d_inode->i_mutex);
+#else
+		down(&hidden_dentry->d_inode->i_sem);
+#endif
+		/* lock_kernel() already done by caller. */
+		err = hidden_dentry->d_inode->i_op->setxattr(hidden_dentry, encoded_name, encoded_value, size, flags);
+		/* unlock_kernel() will be done by caller. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+		mutex_unlock(&hidden_dentry->d_inode->i_mutex);
+#else
+		up(&hidden_dentry->d_inode->i_sem);
+#endif
+	}
+	return err;
+}
+
+/* BKL held by caller.
+ * dentry->d_inode->i_sem down
+ */
+STATIC int
+mini_fo_removexattr(struct dentry *dentry, const char *name) {
+	struct dentry *hidden_dentry = NULL;
+	int err = -EOPNOTSUPP;
+	char *encoded_name;
+
+	check_mini_fo_dentry(dentry);
+
+	if(exists_in_storage(dentry))
+		hidden_dentry = dtohd2(dentry);
+	else
+		hidden_dentry = dtohd(dentry);
+
+	ASSERT(hidden_dentry);
+	ASSERT(hidden_dentry->d_inode);
+	ASSERT(hidden_dentry->d_inode->i_op);
+
+	if (hidden_dentry->d_inode->i_op->removexattr) {
+		encoded_name = (char *)name;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+		mutex_lock(&hidden_dentry->d_inode->i_mutex);
+#else
+		down(&hidden_dentry->d_inode->i_sem);
+#endif
+		/* lock_kernel() already done by caller. */
+		err = hidden_dentry->d_inode->i_op->removexattr(hidden_dentry, encoded_name);
+		/* unlock_kernel() will be done by caller. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+		mutex_unlock(&hidden_dentry->d_inode->i_mutex);
+#else
+		up(&hidden_dentry->d_inode->i_sem);
+#endif
+	}
+	return err;
+}
+
+/* BKL held by caller.
+ * dentry->d_inode->i_sem down
+ */
+STATIC int
+mini_fo_listxattr(struct dentry *dentry, char *list, size_t size) {
+	struct dentry *hidden_dentry = NULL;
+	int err = -EOPNOTSUPP;
+	char *encoded_list = NULL;
+
+	check_mini_fo_dentry(dentry);
+
+	if(exists_in_storage(dentry))
+		hidden_dentry = dtohd2(dentry);
+	else
+		hidden_dentry = dtohd(dentry);
+
+	ASSERT(hidden_dentry);
+	ASSERT(hidden_dentry->d_inode);
+	ASSERT(hidden_dentry->d_inode->i_op);
+
+	if (hidden_dentry->d_inode->i_op->listxattr) {
+		encoded_list = list;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+		mutex_lock(&hidden_dentry->d_inode->i_mutex);
+#else
+		down(&hidden_dentry->d_inode->i_sem);
+#endif
+		/* lock_kernel() already done by caller. */
+		err = hidden_dentry->d_inode->i_op->listxattr(hidden_dentry, encoded_list, size);
+		/* unlock_kernel() will be done by caller. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+		mutex_unlock(&hidden_dentry->d_inode->i_mutex);
+#else
+		up(&hidden_dentry->d_inode->i_sem);
+#endif
+	}
+	return err;
+}
+# endif /* defined(XATTR) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,20)) */
+
+struct inode_operations mini_fo_symlink_iops =
+	{
+		readlink:	mini_fo_readlink,
+		follow_link: mini_fo_follow_link,
+		/* mk: permission:	mini_fo_permission, */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		revalidate:	mini_fo_inode_revalidate,
+#endif
+		setattr:	mini_fo_setattr,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+		getattr:	mini_fo_getattr,
+		put_link:       mini_fo_put_link,
+#endif
+
+#if defined(XATTR) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,20))
+		setxattr:	mini_fo_setxattr,
+		getxattr:	mini_fo_getxattr,
+		listxattr:	mini_fo_listxattr,
+		removexattr: mini_fo_removexattr
+# endif /* defined(XATTR) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,20)) */
+	};
+
+struct inode_operations mini_fo_dir_iops =
+	{
+		create:	mini_fo_create,
+		lookup:	mini_fo_lookup,
+		link:	mini_fo_link,
+		unlink:	mini_fo_unlink,
+		symlink:	mini_fo_symlink,
+		mkdir:	mini_fo_mkdir,
+		rmdir:	mini_fo_rmdir,
+		mknod:	mini_fo_mknod,
+		rename:	mini_fo_rename,
+		/* no readlink/follow_link for non-symlinks */
+		// off because we have setattr
+		//    truncate:	mini_fo_truncate,
+		/* mk:permission:	mini_fo_permission, */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		revalidate:	mini_fo_inode_revalidate,
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+		getattr:	mini_fo_getattr,
+#endif
+		setattr:	mini_fo_setattr,
+#if defined(XATTR) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,20))
+		setxattr:	mini_fo_setxattr,
+		getxattr:	mini_fo_getxattr,
+		listxattr:	mini_fo_listxattr,
+		removexattr: mini_fo_removexattr
+# endif /* XATTR && LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,20) */
+	};
+
+struct inode_operations mini_fo_main_iops =
+	{
+		/* permission:	mini_fo_permission, */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		revalidate:	mini_fo_inode_revalidate,
+#endif
+		setattr:	mini_fo_setattr,
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+		getattr:	mini_fo_getattr,
+#endif
+#if defined(XATTR) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,20))
+		setxattr:	mini_fo_setxattr,
+		getxattr:	mini_fo_getxattr,
+		listxattr:	mini_fo_listxattr,
+		removexattr:    mini_fo_removexattr
+# endif /* XATTR && LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,20) */
+	};
diff -Nru linux-2.6.30.5/fs/mini_fo/main.c linux-2.6.30.5-wrt/fs/mini_fo/main.c
--- linux-2.6.30.5/fs/mini_fo/main.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/fs/mini_fo/main.c	2009-09-06 18:43:48.418666505 +0200
@@ -0,0 +1,431 @@
+/*
+ * Copyright (c) 1997-2003 Erez Zadok
+ * Copyright (c) 2001-2003 Stony Brook University
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package, or get one from ftp://ftp.filesystems.org/pub/fist/COPYING.
+ *
+ * This Copyright notice must be kept intact and distributed with all
+ * fistgen sources INCLUDING sources generated by fistgen.
+ */
+/*
+ * Copyright (C) 2004, 2005 Markus Klotzbuecher <mk@creamnet.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+/*
+ *  $Id$
+ */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include "fist.h"
+#include "mini_fo.h"
+#include <linux/module.h>
+
+/* This definition must only appear after we include <linux/module.h> */
+#ifndef MODULE_LICENSE
+# define MODULE_LICENSE(bison)
+#endif /* not MODULE_LICENSE */
+
+/*
+ * This is the mini_fo tri interpose function, which extends the
+ * functionality of the regular interpose by interposing a higher
+ * level inode on top of two lower level ones: the base filesystem
+ * inode and the storage filesystem inode.
+ *
+ *  sb we pass is mini_fo's super_block
+ */
+int
+mini_fo_tri_interpose(dentry_t *hidden_dentry,
+		      dentry_t *hidden_sto_dentry,
+		      dentry_t *dentry, super_block_t *sb, int flag)
+{
+	inode_t *hidden_inode = NULL;
+	inode_t *hidden_sto_inode = NULL; /* store corresponding storage inode */
+	int err = 0;
+	inode_t *inode;
+
+	/* Pointer to hidden_sto_inode if exists, else to hidden_inode.
+	 * This is used to copy the attributes of the correct inode. */
+	inode_t *master_inode;
+
+	if(hidden_dentry)
+		hidden_inode = hidden_dentry->d_inode;
+	if(hidden_sto_dentry)
+		hidden_sto_inode = hidden_sto_dentry->d_inode;
+
+	ASSERT(dentry->d_inode == NULL);
+
+	/* mk: One of the inodes associated with the dentrys is likely to
+	 * be NULL, so carefull:
+	 */
+	ASSERT((hidden_inode != NULL) || (hidden_sto_inode != NULL));
+
+	if(hidden_sto_inode)
+		master_inode = hidden_sto_inode;
+	else
+		master_inode = hidden_inode;
+
+	/*
+	 * We allocate our new inode below, by calling iget.
+	 * iget will call our read_inode which will initialize some
+	 * of the new inode's fields
+	 */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25)
+	/*
+	 * original: inode = iget(sb, hidden_inode->i_ino);
+	 */
+	inode = iget(sb, iunique(sb, 25));
+	if (!inode) {
+		err = -EACCES;		/* should be impossible??? */
+		goto out;
+	}
+#else
+	inode = mini_fo_iget(sb, iunique(sb, 25));
+	if (IS_ERR(inode)) {
+		err = PTR_ERR(inode);
+		goto out;
+	}
+#endif
+
+	/*
+	 * interpose the inode if not already interposed
+	 *   this is possible if the inode is being reused
+	 * XXX: what happens if we get_empty_inode() but there's another already?
+	 * for now, ASSERT() that this can't happen; fix later.
+	 */
+	if (itohi(inode) != NULL) {
+		printk(KERN_CRIT "mini_fo_tri_interpose: itohi(inode) != NULL.\n");
+	}
+	if (itohi2(inode) != NULL) {
+		printk(KERN_CRIT "mini_fo_tri_interpose: itohi2(inode) != NULL.\n");
+	}
+
+	/* mk: Carefull, igrab can't handle NULL inodes (ok, why should it?), so
+	 * we need to check here:
+	 */
+	if(hidden_inode)
+		itohi(inode) = igrab(hidden_inode);
+	else
+		itohi(inode) = NULL;
+
+	if(hidden_sto_inode)
+		itohi2(inode) = igrab(hidden_sto_inode);
+	else
+		itohi2(inode) = NULL;
+
+
+	/* Use different set of inode ops for symlinks & directories*/
+	if (S_ISLNK(master_inode->i_mode))
+		inode->i_op = &mini_fo_symlink_iops;
+	else if (S_ISDIR(master_inode->i_mode))
+		inode->i_op = &mini_fo_dir_iops;
+
+	/* Use different set of file ops for directories */
+	if (S_ISDIR(master_inode->i_mode))
+		inode->i_fop = &mini_fo_dir_fops;
+
+	/* properly initialize special inodes */
+	if (S_ISBLK(master_inode->i_mode) || S_ISCHR(master_inode->i_mode) ||
+	    S_ISFIFO(master_inode->i_mode) || S_ISSOCK(master_inode->i_mode)) {
+		init_special_inode(inode, master_inode->i_mode, master_inode->i_rdev);
+	}
+
+	/* Fix our inode's address operations to that of the lower inode */
+	if (inode->i_mapping->a_ops != master_inode->i_mapping->a_ops) {
+		inode->i_mapping->a_ops = master_inode->i_mapping->a_ops;
+	}
+
+	/* only (our) lookup wants to do a d_add */
+	if (flag)
+		d_add(dentry, inode);
+	else
+		d_instantiate(dentry, inode);
+
+	ASSERT(dtopd(dentry) != NULL);
+
+	/* all well, copy inode attributes */
+	fist_copy_attr_all(inode, master_inode);
+
+ out:
+	return err;
+}
+
+/* parse mount options "base=" and "sto=" */
+dentry_t *
+mini_fo_parse_options(super_block_t *sb, char *options)
+{
+	dentry_t *hidden_root = ERR_PTR(-EINVAL);
+	dentry_t *hidden_root2 = ERR_PTR(-EINVAL);
+	struct nameidata nd, nd2;
+	char *name, *tmp, *end;
+	int err = 0;
+
+	/* We don't want to go off the end of our arguments later on. */
+	for (end = options; *end; end++);
+
+	while (options < end) {
+		tmp = options;
+		while (*tmp && *tmp != ',')
+			tmp++;
+		*tmp = '\0';
+		if (!strncmp("base=", options, 5)) {
+			name = options + 5;
+			printk(KERN_INFO "mini_fo: using base directory: %s\n", name);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+			if (path_init(name, LOOKUP_FOLLOW, &nd))
+				err = path_walk(name, &nd);
+#else
+			err = path_lookup(name, LOOKUP_FOLLOW, &nd);
+#endif
+			if (err) {
+				printk(KERN_CRIT "mini_fo: error accessing hidden directory '%s'\n", name);
+				hidden_root = ERR_PTR(err);
+				goto out;
+			}
+			hidden_root = nd_get_dentry(&nd);
+			stopd(sb)->base_dir_dentry = nd_get_dentry(&nd);
+			stopd(sb)->hidden_mnt = nd_get_mnt(&nd);
+
+		} else if(!strncmp("sto=", options, 4)) {
+			/* parse the storage dir */
+			name = options + 4;
+			printk(KERN_INFO "mini_fo: using storage directory: %s\n", name);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+			if(path_init(name, LOOKUP_FOLLOW, &nd2))
+				err = path_walk(name, &nd2);
+#else
+                        err = path_lookup(name, LOOKUP_FOLLOW, &nd2);
+#endif
+			if(err) {
+				printk(KERN_CRIT "mini_fo: error accessing hidden storage directory '%s'\n", name);
+
+				hidden_root2 = ERR_PTR(err);
+				goto out;
+			}
+			hidden_root2 = nd_get_dentry(&nd2);
+			stopd(sb)->storage_dir_dentry = nd_get_dentry(&nd2);
+			stopd(sb)->hidden_mnt2 = nd_get_mnt(&nd2);
+			stohs2(sb) = hidden_root2->d_sb;
+
+			/* validate storage dir, this is done in
+			 * mini_fo_read_super for the base directory.
+			 */
+			if (IS_ERR(hidden_root2)) {
+				printk(KERN_WARNING "mini_fo_parse_options: storage dentry lookup failed (err = %ld)\n", PTR_ERR(hidden_root2));
+				goto out;
+			}
+			if (!hidden_root2->d_inode) {
+				printk(KERN_WARNING "mini_fo_parse_options: no storage dir to interpose on.\n");
+				goto out;
+			}
+			stohs2(sb) = hidden_root2->d_sb;
+		} else {
+			printk(KERN_WARNING "mini_fo: unrecognized option '%s'\n", options);
+			hidden_root = ERR_PTR(-EINVAL);
+			goto out;
+		}
+		options = tmp + 1;
+	}
+
+ out:
+	if(IS_ERR(hidden_root2))
+		return hidden_root2;
+	return hidden_root;
+}
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+static int
+#else
+super_block_t *
+#endif
+mini_fo_read_super(super_block_t *sb, void *raw_data, int silent)
+{
+	dentry_t *hidden_root;
+	int err = 0;
+
+	if (!raw_data) {
+		printk(KERN_WARNING "mini_fo_read_super: missing argument\n");
+		err = -EINVAL;
+		goto out;
+	}
+	/*
+	 * Allocate superblock private data
+	 */
+	__stopd(sb) = kmalloc(sizeof(struct mini_fo_sb_info), GFP_KERNEL);
+	if (!stopd(sb)) {
+		printk(KERN_WARNING "%s: out of memory\n", __FUNCTION__);
+		err = -ENOMEM;
+		goto out;
+	}
+	stohs(sb) = NULL;
+
+	hidden_root = mini_fo_parse_options(sb, raw_data);
+	if (IS_ERR(hidden_root)) {
+		printk(KERN_WARNING "mini_fo_read_super: lookup_dentry failed (err = %ld)\n", PTR_ERR(hidden_root));
+		err = PTR_ERR(hidden_root);
+		goto out_free;
+	}
+	if (!hidden_root->d_inode) {
+		printk(KERN_WARNING "mini_fo_read_super: no directory to interpose on\n");
+		goto out_free;
+	}
+	stohs(sb) = hidden_root->d_sb;
+
+	/*
+	 * Linux 2.4.2-ac3 and beyond has code in
+	 * mm/filemap.c:generic_file_write() that requires sb->s_maxbytes
+	 * to be populated.  If not set, all write()s under that sb will
+	 * return 0.
+	 *
+	 * Linux 2.4.4+ automatically sets s_maxbytes to MAX_NON_LFS;
+	 * the filesystem should override it only if it supports LFS.
+	 */
+	/* non-SCA code is good to go with LFS */
+	sb->s_maxbytes = hidden_root->d_sb->s_maxbytes;
+
+	sb->s_op = &mini_fo_sops;
+	/*
+	 * we can't use d_alloc_root if we want to use
+	 * our own interpose function unchanged,
+	 * so we simply replicate *most* of the code in d_alloc_root here
+	 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	sb->s_root = d_alloc(NULL, &(const struct qstr) { "/", 1, 0 });
+#else
+	sb->s_root = d_alloc(NULL, &(const struct qstr){hash: 0, name: "/", len : 1});
+#endif
+	if (IS_ERR(sb->s_root)) {
+		printk(KERN_WARNING "mini_fo_read_super: d_alloc failed\n");
+		err = -ENOMEM;
+		goto out_dput;
+	}
+
+	sb->s_root->d_op = &mini_fo_dops;
+	sb->s_root->d_sb = sb;
+	sb->s_root->d_parent = sb->s_root;
+
+	/* link the upper and lower dentries */
+	__dtopd(sb->s_root) = (struct mini_fo_dentry_info *)
+		kmalloc(sizeof(struct mini_fo_dentry_info), GFP_KERNEL);
+	if (!dtopd(sb->s_root)) {
+		err = -ENOMEM;
+		goto out_dput2;
+	}
+	dtopd(sb->s_root)->state = MODIFIED;
+	dtohd(sb->s_root) = hidden_root;
+
+	/* fanout relevant, interpose on storage root dentry too */
+	dtohd2(sb->s_root) = stopd(sb)->storage_dir_dentry;
+
+	/* ...and call tri-interpose to interpose root dir inodes
+	 * if (mini_fo_interpose(hidden_root, sb->s_root, sb, 0))
+	 */
+	if(mini_fo_tri_interpose(hidden_root, dtohd2(sb->s_root), sb->s_root, sb, 0))
+		goto out_dput2;
+
+	/* initalize the wol list */
+	itopd(sb->s_root->d_inode)->deleted_list_size = -1;
+	itopd(sb->s_root->d_inode)->renamed_list_size = -1;
+	meta_build_lists(sb->s_root);
+
+	goto out;
+
+ out_dput2:
+	dput(sb->s_root);
+ out_dput:
+	dput(hidden_root);
+	dput(dtohd2(sb->s_root)); /* release the hidden_sto_dentry too */
+ out_free:
+	kfree(stopd(sb));
+	__stopd(sb) = NULL;
+ out:
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+        return err;
+#else
+        if (err) {
+		return ERR_PTR(err);
+        } else {
+		return sb;
+        }
+#endif
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+static int mini_fo_get_sb(struct file_system_type *fs_type,
+					  int flags, const char *dev_name,
+					  void *raw_data, struct vfsmount *mnt)
+{
+	return get_sb_nodev(fs_type, flags, raw_data, mini_fo_read_super, mnt);
+}
+#else
+static struct super_block *mini_fo_get_sb(struct file_system_type *fs_type,
+					  int flags, const char *dev_name,
+					  void *raw_data)
+{
+	return get_sb_nodev(fs_type, flags, raw_data, mini_fo_read_super);
+}
+#endif
+
+void mini_fo_kill_block_super(struct super_block *sb)
+{
+	generic_shutdown_super(sb);
+	/*
+	 *      XXX: BUG: Halcrow: Things get unstable sometime after this point:
+	 *      lib/rwsem-spinlock.c:127: spin_is_locked on uninitialized
+	 *      fs/fs-writeback.c:402: spin_lock(fs/super.c:a0381828) already
+	 *      locked by fs/fs-writeback.c/402
+	 *
+	 *      Apparently, someone's not releasing a lock on sb_lock...
+	 */
+}
+
+static struct file_system_type mini_fo_fs_type = {
+	.owner          = THIS_MODULE,
+	.name           = "mini_fo",
+	.get_sb         = mini_fo_get_sb,
+	.kill_sb        = mini_fo_kill_block_super,
+	.fs_flags       = 0,
+};
+
+
+#else
+static DECLARE_FSTYPE(mini_fo_fs_type, "mini_fo", mini_fo_read_super, 0);
+#endif
+
+static int __init init_mini_fo_fs(void)
+{
+	printk("Registering mini_fo version $Id$\n");
+	return register_filesystem(&mini_fo_fs_type);
+}
+static void __exit exit_mini_fo_fs(void)
+{
+	printk("Unregistering mini_fo version $Id$\n");
+	unregister_filesystem(&mini_fo_fs_type);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+EXPORT_NO_SYMBOLS;
+#endif
+
+MODULE_AUTHOR("Erez Zadok <ezk@cs.sunysb.edu>");
+MODULE_DESCRIPTION("FiST-generated mini_fo filesystem");
+MODULE_LICENSE("GPL");
+
+/* MODULE_PARM(fist_debug_var, "i"); */
+/* MODULE_PARM_DESC(fist_debug_var, "Debug level"); */
+
+module_init(init_mini_fo_fs)
+module_exit(exit_mini_fo_fs)
diff -Nru linux-2.6.30.5/fs/mini_fo/meta.c linux-2.6.30.5-wrt/fs/mini_fo/meta.c
--- linux-2.6.30.5/fs/mini_fo/meta.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/fs/mini_fo/meta.c	2009-09-06 18:43:48.430666963 +0200
@@ -0,0 +1,1031 @@
+/*
+ * Copyright (C) 2004, 2005 Markus Klotzbuecher <mk@creamnet.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif /* HAVE_CONFIG_H */
+#include "fist.h"
+#include "mini_fo.h"
+
+int meta_build_lists(dentry_t *dentry)
+{
+	struct mini_fo_inode_info *inode_info;
+
+	dentry_t *meta_dentry = 0;
+	file_t *meta_file = 0;
+	mm_segment_t old_fs;
+	void *buf;
+
+	int bytes, len;
+	struct vfsmount *meta_mnt;
+	char *entry;
+
+	inode_info = itopd(dentry->d_inode);
+	if(!(inode_info->deleted_list_size == -1 &&
+	     inode_info->renamed_list_size == -1)) {
+		printk(KERN_CRIT "mini_fo: meta_build_lists: \
+                                  Error, list(s) not virgin.\n");
+		return -1;
+	}
+
+	/* init our meta lists */
+	INIT_LIST_HEAD(&inode_info->deleted_list);
+	inode_info->deleted_list_size = 0;
+
+	INIT_LIST_HEAD(&inode_info->renamed_list);
+	inode_info->renamed_list_size = 0;
+
+  	/* might there be a META-file? */
+	if(dtohd2(dentry) && dtohd2(dentry)->d_inode) {
+		mutex_lock(&dtohd2(dentry)->d_inode->i_mutex);
+		meta_dentry = lookup_one_len(META_FILENAME,
+					     dtohd2(dentry),
+					     strlen(META_FILENAME));
+		mutex_unlock(&dtohd2(dentry)->d_inode->i_mutex);
+		if(!meta_dentry->d_inode) {
+			dput(meta_dentry);
+			goto out_ok;
+		}
+		/* $%& err, is this correct? */
+		meta_mnt = stopd(dentry->d_inode->i_sb)->hidden_mnt2;
+		mntget(meta_mnt);
+
+
+		/* open META-file for reading */
+		meta_file = dentry_open(meta_dentry, meta_mnt, 0x0, current_cred());
+		if(!meta_file || IS_ERR(meta_file)) {
+			printk(KERN_CRIT "mini_fo: meta_build_lists: \
+                                          ERROR opening META file.\n");
+			goto out_err;
+		}
+
+		/* check if fs supports reading */
+		if(!meta_file->f_op->read) {
+			printk(KERN_CRIT "mini_fo: meta_build_lists: \
+                                          ERROR, fs does not support reading.\n");
+			goto out_err_close;
+		}
+
+		/* allocate a page for transfering the data */
+		buf = (void *) __get_free_page(GFP_KERNEL);
+		if(!buf) {
+			printk(KERN_CRIT "mini_fo: meta_build_lists: \
+                                          ERROR, out of mem.\n");
+			goto out_err_close;
+		}
+		meta_file->f_pos = 0;
+		old_fs = get_fs();
+		set_fs(KERNEL_DS);
+		do {
+			char *c;
+			bytes = meta_file->f_op->read(meta_file, buf, PAGE_SIZE, &meta_file->f_pos);
+			if(bytes == PAGE_SIZE) {
+				/* trim a cut off filename and adjust f_pos to get it next time */
+				for(c = (char*) buf+PAGE_SIZE;
+				    *c != '\n';
+				    c--, bytes--, meta_file->f_pos--);
+			}
+			entry = (char *) buf;
+			while(entry < (char *) buf+bytes) {
+
+				char *old_path;
+				char *dir_name;
+				int old_len, new_len;
+
+				/* len without '\n'*/
+				len = (int) (strchr(entry, '\n') - entry);
+				switch (*entry) {
+				case 'D':
+					/* format: "D filename" */
+					meta_list_add_d_entry(dentry,
+							      entry+2,
+							      len-2);
+					break;
+				case 'R':
+					/* format: "R path/xy/dir newDir" */
+					old_path = entry+2;
+					dir_name = strchr(old_path, ' ') + 1;
+					old_len =  dir_name - old_path - 1;
+					new_len = ((int) entry) + len - ((int ) dir_name);
+					meta_list_add_r_entry(dentry,
+							      old_path,
+							      old_len,
+							      dir_name,
+							      new_len);
+					break;
+				default:
+					/* unknown entry type detected */
+					break;
+				}
+				entry += len+1;
+			}
+
+		} while(meta_file->f_pos < meta_dentry->d_inode->i_size);
+
+		free_page((unsigned long) buf);
+		set_fs(old_fs);
+		fput(meta_file);
+	}
+	goto out_ok;
+
+ out_err_close:
+	fput(meta_file);
+ out_err:
+	mntput(meta_mnt);
+	dput(meta_dentry);
+	return -1;
+ out_ok:
+	return 1; /* check this!!! inode_info->wol_size; */
+}
+
+/* cleanups up all lists and free's the mem by dentry */
+int meta_put_lists(dentry_t *dentry)
+{
+	if(!dentry || !dentry->d_inode) {
+		printk("mini_fo: meta_put_lists: invalid dentry passed.\n");
+		return -1;
+	}
+	return __meta_put_lists(dentry->d_inode);
+}
+
+/* cleanups up all lists and free's the mem by inode */
+int __meta_put_lists(inode_t *inode)
+{
+	int err = 0;
+	if(!inode || !itopd(inode)) {
+		printk("mini_fo: __meta_put_lists: invalid inode passed.\n");
+		return -1;
+	}
+	err = __meta_put_d_list(inode);
+	err |= __meta_put_r_list(inode);
+	return err;
+}
+
+int meta_sync_lists(dentry_t *dentry)
+{
+	int err = 0;
+	if(!dentry || !dentry->d_inode) {
+		printk("mini_fo: meta_sync_lists: \
+                        invalid dentry passed.\n");
+		return -1;
+	}
+	err = meta_sync_d_list(dentry, 0);
+	err |= meta_sync_r_list(dentry, 1);
+	return err;
+}
+
+
+/* remove all D entries from the renamed list and free the mem */
+int __meta_put_d_list(inode_t *inode)
+{
+	struct list_head *tmp;
+        struct deleted_entry *del_entry;
+        struct mini_fo_inode_info *inode_info;
+
+	if(!inode || !itopd(inode)) {
+		printk(KERN_CRIT "mini_fo: __meta_put_d_list: \
+                                  invalid inode passed.\n");
+		return -1;
+	}
+	inode_info = itopd(inode);
+
+        /* nuke the DELETED-list */
+        if(inode_info->deleted_list_size <= 0)
+		return 0;
+
+	while(!list_empty(&inode_info->deleted_list)) {
+		tmp = inode_info->deleted_list.next;
+		list_del(tmp);
+		del_entry = list_entry(tmp, struct deleted_entry, list);
+		kfree(del_entry->name);
+		kfree(del_entry);
+	}
+	inode_info->deleted_list_size = 0;
+
+	return 0;
+}
+
+/* remove all R entries from the renamed list and free the mem */
+int __meta_put_r_list(inode_t *inode)
+{
+	struct list_head *tmp;
+	struct renamed_entry *ren_entry;
+        struct mini_fo_inode_info *inode_info;
+
+	if(!inode || !itopd(inode)) {
+		printk(KERN_CRIT "mini_fo: meta_put_r_list: invalid inode.\n");
+		return -1;
+	}
+	inode_info = itopd(inode);
+
+        /* nuke the RENAMED-list */
+        if(inode_info->renamed_list_size <= 0)
+		return 0;
+
+	while(!list_empty(&inode_info->renamed_list)) {
+		tmp = inode_info->renamed_list.next;
+		list_del(tmp);
+		ren_entry = list_entry(tmp, struct renamed_entry, list);
+		kfree(ren_entry->new_name);
+		kfree(ren_entry->old_name);
+		kfree(ren_entry);
+	}
+	inode_info->renamed_list_size = 0;
+
+	return 0;
+}
+
+int meta_add_d_entry(dentry_t *dentry, const char *name, int len)
+{
+	int err = 0;
+	err = meta_list_add_d_entry(dentry, name, len);
+	err |= meta_write_d_entry(dentry,name,len);
+	return err;
+}
+
+/* add a D entry to the deleted list */
+int meta_list_add_d_entry(dentry_t *dentry, const char *name, int len)
+{
+        struct deleted_entry *del_entry;
+        struct mini_fo_inode_info *inode_info;
+
+	if(!dentry || !dentry->d_inode) {
+		printk(KERN_CRIT "mini_fo: meta_list_add_d_entry: \
+                                  invalid dentry passed.\n");
+		return -1;
+	}
+	inode_info = itopd(dentry->d_inode);
+
+        if(inode_info->deleted_list_size < 0)
+                return -1;
+
+        del_entry = (struct deleted_entry *)
+		kmalloc(sizeof(struct deleted_entry), GFP_KERNEL);
+        del_entry->name = (char*) kmalloc(len, GFP_KERNEL);
+        if(!del_entry || !del_entry->name) {
+                printk(KERN_CRIT "mini_fo: meta_list_add_d_entry: \
+                                  out of mem.\n");
+		kfree(del_entry->name);
+		kfree(del_entry);
+                return -ENOMEM;
+        }
+
+        strncpy(del_entry->name, name, len);
+        del_entry->len = len;
+
+        list_add(&del_entry->list, &inode_info->deleted_list);
+        inode_info->deleted_list_size++;
+        return 0;
+}
+
+int meta_add_r_entry(dentry_t *dentry,
+			  const char *old_name, int old_len,
+			  const char *new_name, int new_len)
+{
+	int err = 0;
+	err = meta_list_add_r_entry(dentry,
+				    old_name, old_len,
+				    new_name, new_len);
+	err |= meta_write_r_entry(dentry,
+				  old_name, old_len,
+				  new_name, new_len);
+	return err;
+}
+
+/* add a R entry to the renamed list */
+int meta_list_add_r_entry(dentry_t *dentry,
+			  const char *old_name, int old_len,
+			  const char *new_name, int new_len)
+{
+        struct renamed_entry *ren_entry;
+        struct mini_fo_inode_info *inode_info;
+
+	if(!dentry || !dentry->d_inode) {
+		printk(KERN_CRIT "mini_fo: meta_list_add_r_entry: \
+                                  invalid dentry passed.\n");
+		return -1;
+	}
+	inode_info = itopd(dentry->d_inode);
+
+        if(inode_info->renamed_list_size < 0)
+                return -1;
+
+        ren_entry = (struct renamed_entry *)
+		kmalloc(sizeof(struct renamed_entry), GFP_KERNEL);
+        ren_entry->old_name = (char*) kmalloc(old_len, GFP_KERNEL);
+        ren_entry->new_name = (char*) kmalloc(new_len, GFP_KERNEL);
+
+        if(!ren_entry || !ren_entry->old_name || !ren_entry->new_name) {
+                printk(KERN_CRIT "mini_fo: meta_list_add_r_entry: \
+                                  out of mem.\n");
+		kfree(ren_entry->new_name);
+		kfree(ren_entry->old_name);
+		kfree(ren_entry);
+                return -ENOMEM;
+        }
+
+        strncpy(ren_entry->old_name, old_name, old_len);
+        ren_entry->old_len = old_len;
+        strncpy(ren_entry->new_name, new_name, new_len);
+        ren_entry->new_len = new_len;
+
+        list_add(&ren_entry->list, &inode_info->renamed_list);
+        inode_info->renamed_list_size++;
+        return 0;
+}
+
+
+int meta_remove_r_entry(dentry_t *dentry, const char *name, int len)
+{
+	int err = 0;
+	if(!dentry || !dentry->d_inode) {
+		printk(KERN_CRIT
+		       "mini_fo: meta_remove_r_entry: \
+                        invalid dentry passed.\n");
+		return -1;
+	}
+
+	err = meta_list_remove_r_entry(dentry, name, len);
+	err |= meta_sync_lists(dentry);
+	return err;
+}
+
+int meta_list_remove_r_entry(dentry_t *dentry, const char *name, int len)
+{
+	if(!dentry || !dentry->d_inode) {
+		printk(KERN_CRIT
+		       "mini_fo: meta_list_remove_r_entry: \
+                        invalid dentry passed.\n");
+		return -1;
+	}
+	return __meta_list_remove_r_entry(dentry->d_inode, name, len);
+}
+
+int __meta_list_remove_r_entry(inode_t *inode, const char *name, int len)
+{
+	struct list_head *tmp;
+        struct renamed_entry *ren_entry;
+        struct mini_fo_inode_info *inode_info;
+
+	if(!inode || !itopd(inode))
+		printk(KERN_CRIT
+		       "mini_fo: __meta_list_remove_r_entry: \
+                        invalid inode passed.\n");
+	inode_info = itopd(inode);
+
+        if(inode_info->renamed_list_size < 0)
+                return -1;
+        if(inode_info->renamed_list_size == 0)
+                return 1;
+
+	list_for_each(tmp, &inode_info->renamed_list) {
+		ren_entry = list_entry(tmp, struct renamed_entry, list);
+		if(ren_entry->new_len != len)
+			continue;
+
+		if(!strncmp(ren_entry->new_name, name, len)) {
+			list_del(tmp);
+			kfree(ren_entry->new_name);
+			kfree(ren_entry->old_name);
+			kfree(ren_entry);
+			inode_info->renamed_list_size--;
+			return 0;
+		}
+	}
+	return 1;
+}
+
+
+/* append a single D entry to the meta file */
+int meta_write_d_entry(dentry_t *dentry, const char *name, int len)
+{
+	dentry_t *meta_dentry = 0;
+        file_t *meta_file = 0;
+        mm_segment_t old_fs;
+
+        int bytes, err;
+        struct vfsmount *meta_mnt = 0;
+        char *buf;
+
+	err = 0;
+
+	if(itopd(dentry->d_inode)->deleted_list_size < 0) {
+		err = -1;
+		goto out;
+	}
+
+	if(dtopd(dentry)->state == UNMODIFIED) {
+                err = build_sto_structure(dentry->d_parent, dentry);
+                if(err) {
+                        printk(KERN_CRIT "mini_fo: meta_write_d_entry: \
+                                          build_sto_structure failed.\n");
+			goto out;
+                }
+        }
+
+	mutex_lock(&dtohd2(dentry)->d_inode->i_mutex);
+	meta_dentry = lookup_one_len(META_FILENAME,
+				     dtohd2(dentry), strlen (META_FILENAME));
+	mutex_unlock(&dtohd2(dentry)->d_inode->i_mutex);
+
+	/* We need to create a META-file */
+        if(!meta_dentry->d_inode) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+		vfs_create(dtohd2(dentry)->d_inode,
+			   meta_dentry,
+			   S_IRUSR | S_IWUSR,
+			   NULL);
+#else
+                vfs_create(dtohd2(dentry)->d_inode,
+			   meta_dentry,
+			   S_IRUSR | S_IWUSR);
+#endif
+	}
+
+	/* $%& err, is this correct? */
+	meta_mnt = stopd(dentry->d_inode->i_sb)->hidden_mnt2;
+	mntget(meta_mnt);
+
+        /* open META-file for writing */
+        meta_file = dentry_open(meta_dentry, meta_mnt, 0x1, current_cred());
+        if(!meta_file || IS_ERR(meta_file)) {
+                printk(KERN_CRIT "mini_fo: meta_write_d_entry: \
+                                  ERROR opening meta file.\n");
+                mntput(meta_mnt); /* $%& is this necessary? */
+                dput(meta_dentry);
+		err = -1;
+                goto out;
+        }
+
+        /* check if fs supports writing */
+        if(!meta_file->f_op->write) {
+                printk(KERN_CRIT "mini_fo: meta_write_d_entry: \
+                                  ERROR, fs does not support writing.\n");
+                goto out_err_close;
+        }
+
+	meta_file->f_pos = meta_dentry->d_inode->i_size; /* append */
+        old_fs = get_fs();
+        set_fs(KERNEL_DS);
+
+	/* size: len for name, 1 for \n and 2 for "D " */
+	buf = (char *) kmalloc(len+3, GFP_KERNEL);
+	if (!buf) {
+		printk(KERN_CRIT "mini_fo: meta_write_d_entry: \
+                                  out of mem.\n");
+		return -ENOMEM;
+	}
+
+	buf[0] = 'D';
+	buf[1] = ' ';
+	strncpy(buf+2, name, len);
+	buf[len+2] = '\n';
+	bytes = meta_file->f_op->write(meta_file, buf, len+3,
+				       &meta_file->f_pos);
+	if(bytes != len+3) {
+		printk(KERN_CRIT "mini_fo: meta_write_d_entry: \
+                                  ERROR writing.\n");
+		err = -1;
+	}
+	kfree(buf);
+	set_fs(old_fs);
+
+ out_err_close:
+	fput(meta_file);
+ out:
+	return err;
+}
+
+/* append a single R entry to the meta file */
+int meta_write_r_entry(dentry_t *dentry,
+		       const char *old_name, int old_len,
+		       const char *new_name, int new_len)
+{
+	dentry_t *meta_dentry = 0;
+        file_t *meta_file = 0;
+        mm_segment_t old_fs;
+
+        int bytes, err, buf_len;
+	struct vfsmount *meta_mnt = 0;
+        char *buf;
+
+
+	err = 0;
+
+	if(itopd(dentry->d_inode)->renamed_list_size < 0) {
+		err = -1;
+		goto out;
+	}
+
+	/* build the storage structure? */
+	if(dtopd(dentry)->state == UNMODIFIED) {
+                err = build_sto_structure(dentry->d_parent, dentry);
+                if(err) {
+                        printk(KERN_CRIT "mini_fo: meta_write_r_entry: \
+                                          build_sto_structure failed.\n");
+			goto out;
+                }
+        }
+
+	mutex_lock(&dtohd2(dentry)->d_inode->i_mutex);
+	meta_dentry = lookup_one_len(META_FILENAME,
+				     dtohd2(dentry),
+				     strlen (META_FILENAME));
+	mutex_unlock(&dtohd2(dentry)->d_inode->i_mutex);
+
+        if(!meta_dentry->d_inode) {
+                /* We need to create a META-file */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+                vfs_create(dtohd2(dentry)->d_inode,
+			   meta_dentry, S_IRUSR | S_IWUSR, NULL);
+#else
+                vfs_create(dtohd2(dentry)->d_inode,
+			   meta_dentry, S_IRUSR | S_IWUSR);
+#endif
+	}
+
+	/* $%& err, is this correct? */
+	meta_mnt = stopd(dentry->d_inode->i_sb)->hidden_mnt2;
+	mntget(meta_mnt);
+
+        /* open META-file for writing */
+        meta_file = dentry_open(meta_dentry, meta_mnt, 0x1, current_cred());
+        if(!meta_file || IS_ERR(meta_file)) {
+                printk(KERN_CRIT "mini_fo: meta_write_r_entry: \
+                                  ERROR opening meta file.\n");
+                mntput(meta_mnt);
+                dput(meta_dentry);
+		err = -1;
+                goto out;
+        }
+
+        /* check if fs supports writing */
+        if(!meta_file->f_op->write) {
+                printk(KERN_CRIT "mini_fo: meta_write_r_entry: \
+                                  ERROR, fs does not support writing.\n");
+                goto out_err_close;
+        }
+
+	meta_file->f_pos = meta_dentry->d_inode->i_size; /* append */
+        old_fs = get_fs();
+        set_fs(KERNEL_DS);
+
+	/* size: 2 for "R ", old_len+new_len for names, 1 blank+1 \n */
+	buf_len = old_len + new_len + 4;
+	buf = (char *) kmalloc(buf_len, GFP_KERNEL);
+	if (!buf) {
+		printk(KERN_CRIT "mini_fo: meta_write_r_entry: out of mem.\n");
+		return -ENOMEM;
+	}
+
+	buf[0] = 'R';
+	buf[1] = ' ';
+	strncpy(buf + 2, old_name, old_len);
+	buf[old_len + 2] = ' ';
+	strncpy(buf + old_len + 3, new_name, new_len);
+	buf[buf_len -1] = '\n';
+	bytes = meta_file->f_op->write(meta_file, buf, buf_len, &meta_file->f_pos);
+	if(bytes != buf_len) {
+		printk(KERN_CRIT "mini_fo: meta_write_r_entry: ERROR writing.\n");
+		err = -1;
+	}
+
+	kfree(buf);
+	set_fs(old_fs);
+
+ out_err_close:
+	fput(meta_file);
+ out:
+	return err;
+}
+
+/* sync D list to disk, append data if app_flag is 1 */
+/* check the meta_mnt, which seems not to be used (properly)  */
+
+int meta_sync_d_list(dentry_t *dentry, int app_flag)
+{
+	dentry_t *meta_dentry;
+        file_t *meta_file;
+        mm_segment_t old_fs;
+
+        int bytes, err;
+        struct vfsmount *meta_mnt;
+        char *buf;
+
+	struct list_head *tmp;
+        struct deleted_entry *del_entry;
+        struct mini_fo_inode_info *inode_info;
+
+	err = 0;
+	meta_file=0;
+	meta_mnt=0;
+
+	if(!dentry || !dentry->d_inode) {
+		printk(KERN_CRIT "mini_fo: meta_sync_d_list: \
+                                  invalid inode passed.\n");
+		err = -1;
+		goto out;
+	}
+	inode_info = itopd(dentry->d_inode);
+
+        if(inode_info->deleted_list_size < 0) {
+		err = -1;
+		goto out;
+	}
+
+	/* ok, there is something to sync */
+
+	/* build the storage structure? */
+        if(!dtohd2(dentry) && !itohi2(dentry->d_inode)) {
+                err = build_sto_structure(dentry->d_parent, dentry);
+                if(err) {
+                        printk(KERN_CRIT "mini_fo: meta_sync_d_list: \
+                                          build_sto_structure failed.\n");
+			goto out;
+                }
+        }
+
+	mutex_lock(&dtohd2(dentry)->d_inode->i_mutex);
+	meta_dentry = lookup_one_len(META_FILENAME,
+				     dtohd2(dentry),
+				     strlen(META_FILENAME));
+	mutex_unlock(&dtohd2(dentry)->d_inode->i_mutex);
+
+        if(!meta_dentry->d_inode) {
+                /* We need to create a META-file */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+                vfs_create(dtohd2(dentry)->d_inode,
+			   meta_dentry, S_IRUSR | S_IWUSR, NULL);
+#else
+                vfs_create(dtohd2(dentry)->d_inode,
+			   meta_dentry, S_IRUSR | S_IWUSR);
+#endif
+		app_flag = 0;
+	}
+	/* need we truncate the meta file? */
+	if(!app_flag) {
+		struct iattr newattrs;
+                newattrs.ia_size = 0;
+                newattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+		mutex_lock(&meta_dentry->d_inode->i_mutex);
+#else
+                down(&meta_dentry->d_inode->i_sem);
+#endif
+                err = notify_change(meta_dentry, &newattrs);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+		mutex_unlock(&meta_dentry->d_inode->i_mutex);
+#else
+                up(&meta_dentry->d_inode->i_sem);
+#endif
+
+                if(err || meta_dentry->d_inode->i_size != 0) {
+                        printk(KERN_CRIT "mini_fo: meta_sync_d_list: \
+                                          ERROR truncating meta file.\n");
+                        goto out_err_close;
+		}
+	}
+
+	/* $%& err, is this correct? */
+	meta_mnt = stopd(dentry->d_inode->i_sb)->hidden_mnt2;
+	mntget(meta_mnt);
+
+        /* open META-file for writing */
+        meta_file = dentry_open(meta_dentry, meta_mnt, 0x1, current_cred());
+        if(!meta_file || IS_ERR(meta_file)) {
+                printk(KERN_CRIT "mini_fo: meta_sync_d_list: \
+                                  ERROR opening meta file.\n");
+		mntput(meta_mnt);
+		dput(meta_dentry);
+		err = -1;
+                goto out;
+        }
+
+        /* check if fs supports writing */
+        if(!meta_file->f_op->write) {
+                printk(KERN_CRIT "mini_fo: meta_sync_d_list: \
+                                  ERROR, fs does not support writing.\n");
+                goto out_err_close;
+        }
+
+	meta_file->f_pos = meta_dentry->d_inode->i_size; /* append */
+        old_fs = get_fs();
+        set_fs(KERNEL_DS);
+
+	/* here we go... */
+        list_for_each(tmp, &inode_info->deleted_list) {
+		del_entry = list_entry(tmp, struct deleted_entry, list);
+
+		/* size: len for name, 1 for \n and 2 for "D " */
+		buf = (char *) kmalloc(del_entry->len+3, GFP_KERNEL);
+		if (!buf) {
+			printk(KERN_CRIT "mini_fo: meta_sync_d_list: \
+                                          out of mem.\n");
+			return -ENOMEM;
+		}
+
+		buf[0] = 'D';
+		buf[1] = ' ';
+		strncpy(buf+2, del_entry->name, del_entry->len);
+		buf[del_entry->len+2] = '\n';
+		bytes = meta_file->f_op->write(meta_file, buf,
+					       del_entry->len+3,
+					       &meta_file->f_pos);
+		if(bytes != del_entry->len+3) {
+			printk(KERN_CRIT "mini_fo: meta_sync_d_list: \
+                                          ERROR writing.\n");
+			err |= -1;
+		}
+		kfree(buf);
+	}
+	set_fs(old_fs);
+
+ out_err_close:
+	fput(meta_file);
+ out:
+	return err;
+
+}
+
+int meta_sync_r_list(dentry_t *dentry, int app_flag)
+{
+	dentry_t *meta_dentry;
+        file_t *meta_file;
+        mm_segment_t old_fs;
+
+        int bytes, err, buf_len;
+        struct vfsmount *meta_mnt;
+        char *buf;
+
+	struct list_head *tmp;
+        struct renamed_entry *ren_entry;
+        struct mini_fo_inode_info *inode_info;
+
+	err = 0;
+	meta_file=0;
+	meta_mnt=0;
+
+	if(!dentry || !dentry->d_inode) {
+		printk(KERN_CRIT "mini_fo: meta_sync_r_list: \
+                                  invalid dentry passed.\n");
+		err = -1;
+		goto out;
+	}
+	inode_info = itopd(dentry->d_inode);
+
+        if(inode_info->deleted_list_size < 0) {
+		err = -1;
+		goto out;
+	}
+
+	/* ok, there is something to sync */
+
+	/* build the storage structure? */
+        if(!dtohd2(dentry) && !itohi2(dentry->d_inode)) {
+                err = build_sto_structure(dentry->d_parent, dentry);
+                if(err) {
+                        printk(KERN_CRIT "mini_fo: meta_sync_r_list: \
+                                          build_sto_structure failed.\n");
+			goto out;
+                }
+        }
+
+	mutex_lock(&dtohd2(dentry)->d_inode->i_mutex);
+	meta_dentry = lookup_one_len(META_FILENAME,
+				     dtohd2(dentry),
+				     strlen(META_FILENAME));
+	mutex_unlock(&dtohd2(dentry)->d_inode->i_mutex);
+
+        if(!meta_dentry->d_inode) {
+                /* We need to create a META-file */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+                vfs_create(dtohd2(dentry)->d_inode,
+			   meta_dentry, S_IRUSR | S_IWUSR, NULL);
+#else
+                vfs_create(dtohd2(dentry)->d_inode,
+			   meta_dentry, S_IRUSR | S_IWUSR);
+#endif
+		app_flag = 0;
+	}
+	/* need we truncate the meta file? */
+	if(!app_flag) {
+		struct iattr newattrs;
+                newattrs.ia_size = 0;
+                newattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+		mutex_lock(&meta_dentry->d_inode->i_mutex);
+#else
+                down(&meta_dentry->d_inode->i_sem);
+#endif
+                err = notify_change(meta_dentry, &newattrs);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+		mutex_unlock(&meta_dentry->d_inode->i_mutex);
+#else
+                up(&meta_dentry->d_inode->i_sem);
+#endif
+                if(err || meta_dentry->d_inode->i_size != 0) {
+                        printk(KERN_CRIT "mini_fo: meta_sync_r_list: \
+                                          ERROR truncating meta file.\n");
+                        goto out_err_close;
+		}
+	}
+
+	/* $%& err, is this correct? */
+	meta_mnt = stopd(dentry->d_inode->i_sb)->hidden_mnt2;
+	mntget(meta_mnt);
+
+        /* open META-file for writing */
+        meta_file = dentry_open(meta_dentry, meta_mnt, 0x1, current_cred());
+        if(!meta_file || IS_ERR(meta_file)) {
+                printk(KERN_CRIT "mini_fo: meta_sync_r_list: \
+                                  ERROR opening meta file.\n");
+		mntput(meta_mnt);
+		dput(meta_dentry);
+		err = -1;
+                goto out;
+        }
+
+        /* check if fs supports writing */
+        if(!meta_file->f_op->write) {
+                printk(KERN_CRIT "mini_fo: meta_sync_r_list: \
+                                  ERROR, fs does not support writing.\n");
+                goto out_err_close;
+        }
+
+	meta_file->f_pos = meta_dentry->d_inode->i_size; /* append */
+        old_fs = get_fs();
+        set_fs(KERNEL_DS);
+
+	/* here we go... */
+        list_for_each(tmp, &inode_info->renamed_list) {
+		ren_entry = list_entry(tmp, struct renamed_entry, list);
+		/* size:
+		 * 2 for "R ", old_len+new_len for names, 1 blank+1 \n */
+		buf_len = ren_entry->old_len + ren_entry->new_len + 4;
+		buf = (char *) kmalloc(buf_len, GFP_KERNEL);
+		if (!buf) {
+			printk(KERN_CRIT "mini_fo: meta_sync_r_list: \
+                                          out of mem.\n");
+			return -ENOMEM;
+		}
+		buf[0] = 'R';
+		buf[1] = ' ';
+		strncpy(buf + 2, ren_entry->old_name, ren_entry->old_len);
+		buf[ren_entry->old_len + 2] = ' ';
+		strncpy(buf + ren_entry->old_len + 3,
+			ren_entry->new_name, ren_entry->new_len);
+		buf[buf_len - 1] = '\n';
+		bytes = meta_file->f_op->write(meta_file, buf,
+					       buf_len, &meta_file->f_pos);
+		if(bytes != buf_len) {
+			printk(KERN_CRIT "mini_fo: meta_sync_r_list: \
+                                          ERROR writing.\n");
+			err |= -1;
+		}
+		kfree(buf);
+	}
+	set_fs(old_fs);
+
+ out_err_close:
+	fput(meta_file);
+ out:
+	return err;
+}
+
+int meta_check_d_entry(dentry_t *dentry, const char *name, int len)
+{
+	if(!dentry || !dentry->d_inode)
+		printk(KERN_CRIT "mini_fo: meta_check_d_dentry: \
+                                  invalid dentry passed.\n");
+	return __meta_check_d_entry(dentry->d_inode, name, len);
+}
+
+int __meta_check_d_entry(inode_t *inode, const char *name, int len)
+{
+	struct list_head *tmp;
+        struct deleted_entry *del_entry;
+        struct mini_fo_inode_info *inode_info;
+
+	if(!inode || !itopd(inode))
+		printk(KERN_CRIT "mini_fo: __meta_check_d_dentry: \
+                                  invalid inode passed.\n");
+
+        inode_info = itopd(inode);
+
+        if(inode_info->deleted_list_size <= 0)
+                return 0;
+
+        list_for_each(tmp, &inode_info->deleted_list) {
+		del_entry = list_entry(tmp, struct deleted_entry, list);
+		if(del_entry->len != len)
+			continue;
+
+		if(!strncmp(del_entry->name, name, len))
+			return 1;
+	}
+	return 0;
+}
+
+/*
+ * check if file has been renamed and return path to orig. base dir.
+ * Implements no error return values so far, what of course sucks.
+ * String is null terminated.'
+ */
+char* meta_check_r_entry(dentry_t *dentry, const char *name, int len)
+{
+	if(!dentry || !dentry->d_inode) {
+		printk(KERN_CRIT "mini_fo: meta_check_r_dentry: \
+                                  invalid dentry passed.\n");
+		return NULL;
+	}
+	return __meta_check_r_entry(dentry->d_inode, name, len);
+}
+
+char* __meta_check_r_entry(inode_t *inode, const char *name, int len)
+{
+	struct list_head *tmp;
+        struct renamed_entry *ren_entry;
+        struct mini_fo_inode_info *inode_info;
+	char *old_path;
+
+	if(!inode || !itopd(inode)) {
+		printk(KERN_CRIT "mini_fo: meta_check_r_dentry: \
+                                  invalid inode passed.\n");
+		return NULL;
+	}
+	inode_info = itopd(inode);
+
+        if(inode_info->renamed_list_size <= 0)
+                return NULL;
+
+        list_for_each(tmp, &inode_info->renamed_list) {
+		ren_entry = list_entry(tmp, struct renamed_entry, list);
+		if(ren_entry->new_len != len)
+			continue;
+
+		if(!strncmp(ren_entry->new_name, name, len)) {
+			old_path = (char *)
+				kmalloc(ren_entry->old_len+1, GFP_KERNEL);
+			strncpy(old_path,
+				ren_entry->old_name,
+				ren_entry->old_len);
+			old_path[ren_entry->old_len]='\0';
+			return old_path;
+		}
+	}
+	return NULL;
+}
+
+/*
+ * This version only checks if entry exists and return:
+ *     1 if exists,
+ *     0 if not,
+ *    -1 if error.
+ */
+int meta_is_r_entry(dentry_t *dentry, const char *name, int len)
+{
+	if(!dentry || !dentry->d_inode) {
+		printk(KERN_CRIT "mini_fo: meta_check_r_dentry [2]: \
+                                  invalid dentry passed.\n");
+		return -1;
+	}
+	return __meta_is_r_entry(dentry->d_inode, name, len);
+}
+
+int __meta_is_r_entry(inode_t *inode, const char *name, int len)
+{
+	struct list_head *tmp;
+        struct renamed_entry *ren_entry;
+        struct mini_fo_inode_info *inode_info;
+
+	if(!inode || !itopd(inode)) {
+		printk(KERN_CRIT "mini_fo: meta_check_r_dentry [2]: \
+                                  invalid inode passed.\n");
+		return -1;
+	}
+	inode_info = itopd(inode);
+
+        if(inode_info->renamed_list_size <= 0)
+                return -1;
+
+        list_for_each(tmp, &inode_info->renamed_list) {
+		ren_entry = list_entry(tmp, struct renamed_entry, list);
+		if(ren_entry->new_len != len)
+			continue;
+
+		if(!strncmp(ren_entry->new_name, name, len))
+			return 1;
+	}
+	return 0;
+}
+
diff -Nru linux-2.6.30.5/fs/mini_fo/mini_fo-merge linux-2.6.30.5-wrt/fs/mini_fo/mini_fo-merge
--- linux-2.6.30.5/fs/mini_fo/mini_fo-merge	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/fs/mini_fo/mini_fo-merge	2009-09-06 18:43:48.418666505 +0200
@@ -0,0 +1,180 @@
+#!/bin/bash
+#
+# Copyright (C) 2005 Markus Klotzbuecher <mk@creamnet.de>
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version
+# 2 of the License, or (at your option) any later version.
+#
+
+BASE=
+STO=
+HELP=
+DRYRUN=
+VERBOSE=
+TMP="/tmp/"
+META_NAME="META_dAfFgHE39ktF3HD2sr"
+SKIP_DEL_LIST="skip-delete-list.mini_fo-merge"
+
+COMMAND=
+exec_command()
+{
+    if [ x$DRYRUN == "xset" ]; then
+	echo "  would run: $COMMAND"
+    elif ! [ x$DRYRUN == "xset" ]; then
+	if [ x$VERBOSE == "xset" ]; then
+	    echo "  running: $COMMAND"
+	fi
+	eval $COMMAND
+    fi
+}
+
+usage()
+{
+cat <<EOF
+
+USAGE: $0 -b <base dir> -s <storage dir>
+Version 0.1
+
+This script merges the contents of a mini_fo storage file system back
+to the base file system.
+
+!!! Warning: This will modify the base filesystem and can destroy data
+             if used wrongly.
+
+Options:
+     -b <base dir>
+          the directory of the base file system.
+
+     -s <storage dir>
+          the directory of the storage file system.
+
+     -d   dry run, will not change anything and print the commands that
+          would be executed.
+
+     -t   tmp dir for storing temporary file. default: $TMP
+
+     -v   show what operations are performed.
+
+     -h   displays this message.
+
+EOF
+}
+
+# parse parameters
+while getopts hdvt:b:s: OPTS
+  do
+  case $OPTS in
+      h)  HELP="set";;
+      d)  DRYRUN="set";;
+      v)  VERBOSE="set";;
+      b)  BASE="$OPTARG";;
+      s)  STO="$OPTARG";;
+      t)  TMP="$OPTARG";;
+      ?)  usage
+	  exit 1;;
+  esac
+done
+
+if [ "x$HELP" == "xset" ]; then
+    usage
+    exit -1
+fi
+
+if ! [ -d "$BASE" ] || ! [ -d "$STO" ]; then
+    echo -e "$0:\n Error, -s and/or -b argument missing. type $0 -h for help."
+    exit -1;
+fi
+
+# get full paths
+pushd $STO; STO=`pwd`; popd
+pushd $BASE; BASE=`pwd`; popd
+TMP=${TMP%/}
+
+
+cat<<EOF
+###############################################################################
+# mini_fo-merge
+#
+# base dir:       $BASE
+# storage dir:    $STO
+# meta filename:  $META_NAME
+# dry run:        $DRYRUN
+# verbose:        $VERBOSE
+# tmp files:      $TMP
+###############################################################################
+
+EOF
+
+rm $TMP/$SKIP_DEL_LIST
+
+# first process all renamed dirs
+echo "Merging renamed directories..."
+pushd $STO &> /dev/null
+find . -name $META_NAME -type f -print0  | xargs -0 -e grep  -e '^R ' | tr -s ':R' ' ' | while read ENTRY; do
+    echo "entry: $ENTRY"
+    META_FILE=`echo $ENTRY | cut -d ' ' -f 1`
+    OLD_B_DIR=`echo $ENTRY | cut -d ' ' -f 2 | sed -e 's/\///'`
+    NEW_NAME=`echo $ENTRY | cut -d ' ' -f 3`
+    NEW_B_DIR=`echo $META_FILE | sed -e "s/$META_NAME/$NEW_NAME/" | sed -e 's/^\.\///'`
+    echo "META_FILE: $META_FILE"
+    echo "OLD_B_DIR: $OLD_B_DIR"
+    echo "NEW_NAME: $NEW_NAME"
+    echo  "NEW_B_DIR: $NEW_B_DIR"
+
+    pushd $BASE &> /dev/null
+    # remove an existing dir in storage
+    COMMAND="rm -rf $NEW_B_DIR"; exec_command
+    COMMAND="cp -R $OLD_B_DIR $NEW_B_DIR"; exec_command
+    echo ""
+    popd &> /dev/null
+
+    # remember this dir to exclude it from deleting later
+    echo $NEW_B_DIR >> $TMP/$SKIP_DEL_LIST
+done
+
+# delete all whiteouted files from base
+echo -e "\nDeleting whiteout'ed files from base file system..."
+find . -name $META_NAME -type f -print0  | xargs -0 -e grep  -e '^D ' | sed -e 's/:D//' | while read ENTRY; do
+    META_FILE=`echo $ENTRY | cut -d ' ' -f 1`
+    DEL_NAME=`echo $ENTRY | cut -d ' ' -f 2`
+    DEL_FILE=`echo $META_FILE | sed -e "s/$META_NAME/$DEL_NAME/" | sed -e 's/^\.\///'`
+    grep -x $DEL_FILE $TMP/$SKIP_DEL_LIST &> /dev/null
+    if [ $? -ne 0 ]; then
+	pushd $BASE &> /dev/null
+	COMMAND="rm -rf $DEL_FILE"; exec_command
+	popd &> /dev/null
+    else
+	echo "  excluding: $DEL_FILE as in skip-del-list."
+    fi
+done
+
+# create all dirs and update permissions
+echo -e "\nSetting up directory structures in base file system..."
+find . -type d | sed -e 's/^\.\///' | while read DIR; do
+    PERMS=`stat -c %a $DIR`
+    DIR_UID=`stat -c %u $DIR`
+    DIR_GID=`stat -c %g $DIR`
+    pushd $BASE &> /dev/null
+    if ! [ -d $DIR ]; then
+	COMMAND="mkdir -p $DIR"; exec_command
+    fi
+    COMMAND="chmod $PERMS $DIR"; exec_command
+    COMMAND="chown $DIR_UID:$DIR_GID $DIR"; exec_command
+    popd &> /dev/null
+done
+
+# merge all non-directory files
+echo -e "\nMerging all non-directory files...."
+for i in b c p f l s; do
+    find . -type $i | sed -e 's/^\.\///' | grep -v "$META_NAME" | while read FILE; do
+	pushd $BASE #&> /dev/null
+	COMMAND="cp -df $STO/$FILE $BASE/$FILE"; exec_command
+	popd &> /dev/null
+    done
+done
+popd &> /dev/null
+
+#rm $TMP/$SKIP_DEL_LIST
+
+echo "Done!"
diff -Nru linux-2.6.30.5/fs/mini_fo/mini_fo-overlay linux-2.6.30.5-wrt/fs/mini_fo/mini_fo-overlay
--- linux-2.6.30.5/fs/mini_fo/mini_fo-overlay	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/fs/mini_fo/mini_fo-overlay	2009-09-06 18:43:48.418666505 +0200
@@ -0,0 +1,130 @@
+#!/bin/bash
+#
+# Copyright (C) 2005 Markus Klotzbuecher <mk@creamnet.de>
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version
+# 2 of the License, or (at your option) any later version.
+#
+
+HELP=
+SUFF=
+MNTP=
+MNT_DIR="/mnt"
+STO=
+STO_DIR="/tmp"
+BASE=
+
+usage()
+{
+cat <<EOF
+
+Usage: $0 [-s suffix] [-d sto_dir_dir] [-m mount point] base_dir
+Version 0.1
+
+This script overlays the given base directory using the mini_fo file
+system. If only the base directory base_dir is given, $0
+will use a storage directory called "sto-<base_dir_name>" in $STO_DIR,
+and mount point "mini_fo-<base_dir_dir>" in $MNT_DIR.
+
+Options:
+     -s <suffix>
+          add given suffix to storage directory and the mount
+          point. This is usefull for overlaying one base directory
+          several times and avoiding conflicts with storage directory
+          names and mount points.
+
+     -d <sto_dir_dir>
+          change the directory in which the storage directory will be
+          created (default is currently "$STO_DIR".
+
+     -m <mount point>
+          use an alternative directory to create the mini_fo
+          mountpoint (default is currently "$MNT_DIR".
+
+     -h   displays this message.
+
+EOF
+exit 1;
+}
+
+while getopts hm:s:d: OPTS
+  do
+  case $OPTS in
+      s)  SUFF="$OPTARG";;
+      d)  STO_DIR="$OPTARG";;
+      m)  MNT_DIR="$OPTARG";;
+      h)  HELP="set";;
+      ?)  usage
+	  exit 1;;
+  esac
+done
+shift $(($OPTIND - 1))
+
+BASE="$1"
+
+if [ "x$HELP" == "xset" ]; then
+    usage
+    exit -1
+fi
+
+# fix suffix
+if [ "x$SUFF" != "x" ]; then
+    SUFF="-$SUFF"
+fi
+
+# kill trailing slashes
+MNT_DIR=${MNT_DIR%/}
+STO_DIR=${STO_DIR%/}
+BASE=${BASE%/}
+
+
+if ! [ -d "$BASE" ]; then
+    echo "invalid base dir $BASE, run $0 -h for help."
+    exit -1
+fi
+
+# check opts
+if ! [ -d "$MNT_DIR" ]; then
+    echo "invalid mount dir $MNT_DIR, run $0 -h for help."
+    exit -1
+fi
+
+if ! [ -d "$STO_DIR" ]; then
+    echo "invalid sto_dir_dir $STO_DIR, run $0 -h for help."
+    exit -1
+fi
+
+MNTP="$MNT_DIR/mini_fo-`basename $BASE`$SUFF"
+STO="$STO_DIR/sto-`basename $BASE`$SUFF"
+
+# create the mount point if it doesn't exist
+mkdir -p $MNTP
+if [ $? -ne 0 ]; then
+    echo "Error, failed to create mount point $MNTP"
+fi
+
+mkdir -p $STO
+if [ $? -ne 0 ]; then
+    echo "Error, failed to create storage dir $STO"
+fi
+
+# check if fs is already mounted
+mount | grep mini_fo | grep $MNTP &> /dev/null
+if [ $? -eq 0 ]; then
+    echo "Error, existing mini_fo mount at $MNTP."
+    exit -1
+fi
+
+mount | grep mini_fo | grep $STO &> /dev/null
+if [ $? -eq 0 ]; then
+    echo "Error, $STO seems to be used already."
+    exit -1
+fi
+
+# mount
+mount -t mini_fo -o base=$BASE,sto=$STO $BASE $MNTP
+
+if [ $? -ne 0 ]; then
+    echo "Error, mounting failed, maybe no permisson to mount?"
+fi
diff -Nru linux-2.6.30.5/fs/mini_fo/mini_fo.h linux-2.6.30.5-wrt/fs/mini_fo/mini_fo.h
--- linux-2.6.30.5/fs/mini_fo/mini_fo.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/fs/mini_fo/mini_fo.h	2009-09-06 18:43:48.418666505 +0200
@@ -0,0 +1,537 @@
+/*
+ * Copyright (c) 1997-2003 Erez Zadok
+ * Copyright (c) 2001-2003 Stony Brook University
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package, or get one from ftp://ftp.filesystems.org/pub/fist/COPYING.
+ *
+ * This Copyright notice must be kept intact and distributed with all
+ * fistgen sources INCLUDING sources generated by fistgen.
+ */
+/*
+ * Copyright (C) 2004, 2005 Markus Klotzbuecher <mk@creamnet.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+/*
+ *  $Id$
+ */
+
+#ifndef __MINI_FO_H_
+#define __MINI_FO_H_
+
+#ifdef __KERNEL__
+
+/* META stuff */
+#define META_FILENAME "META_dAfFgHE39ktF3HD2sr"
+
+/* use xattrs? */
+#define XATTR
+
+/* File attributes that when changed, result in a file beeing copied to storage */
+#define COPY_FLAGS ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_SIZE
+
+/*
+ * mini_fo filestates
+ */
+#define MODIFIED       1
+#define UNMODIFIED     2
+#define CREATED        3
+#define DEL_REWRITTEN  4
+#define DELETED        5
+#define NON_EXISTANT   6
+
+/* fist file systems superblock magic */
+# define MINI_FO_SUPER_MAGIC 0xf15f
+
+/*
+ * STRUCTURES:
+ */
+
+/* mini_fo inode data in memory */
+struct mini_fo_inode_info {
+	inode_t *wii_inode;
+	inode_t *wii_inode2; /* pointer to storage inode */
+
+	/* META-data lists */
+	/* deleted list, ex wol */
+	struct list_head deleted_list;
+	int deleted_list_size;
+
+	/* renamed list */
+	struct list_head renamed_list;
+	int renamed_list_size;
+
+	/* add other lists here ... */
+};
+
+/* mini_fo dentry data in memory */
+struct mini_fo_dentry_info {
+	dentry_t *wdi_dentry;
+	dentry_t *wdi_dentry2; /* pointer to  storage dentry */
+	unsigned int state;  /* state of the mini_fo dentry */
+};
+
+
+/* mini_fo super-block data in memory */
+struct mini_fo_sb_info {
+	super_block_t *wsi_sb, *wsi_sb2; /* mk: might point to the same sb */
+	struct vfsmount *hidden_mnt, *hidden_mnt2;
+	dentry_t *base_dir_dentry;
+	dentry_t *storage_dir_dentry;
+	;
+};
+
+/* readdir_data, readdir helper struct */
+struct readdir_data {
+	struct list_head ndl_list; /* linked list head ptr */
+	int ndl_size; /* list size */
+	int sto_done; /* flag to show that the storage dir entries have
+		       * all been read an now follow base entries */
+};
+
+/* file private data. */
+struct mini_fo_file_info {
+	struct file *wfi_file;
+	struct file *wfi_file2; /* pointer to storage file */
+	struct readdir_data rd;
+};
+
+/* struct ndl_entry */
+struct ndl_entry {
+	struct list_head list;
+	char *name;
+	int len;
+};
+
+/********************************
+ *  META-data structures
+ ********************************/
+
+/* deleted entry */
+struct deleted_entry {
+	struct list_head list;
+	char *name;
+	int len;
+};
+
+/* renamed entry */
+struct renamed_entry {
+	struct list_head list;
+	char *old_name;     /* old directory with full path */
+	int old_len;        /* length of above string */
+	char *new_name;     /* new directory name */
+	int new_len;        /* length of above string */
+};
+
+/* attr_change entry */
+struct attr_change_entry {
+	struct list_head list;
+	char *name;
+	int len;
+};
+
+/* link entry */
+struct link_entry {
+	struct list_head list;
+	int links_moved;
+	int inum_base;
+	int inum_sto;
+	char *weird_name;
+	int weird_name_len;
+};
+
+
+/* Some other stuff required for mini_fo_filldir64, copied from
+ * fs/readdir.c
+ */
+
+#define ROUND_UP64(x) (((x)+sizeof(u64)-1) & ~(sizeof(u64)-1))
+#define NAME_OFFSET(de) ((int) ((de)->d_name - (char *) (de)))
+
+
+struct linux_dirent64 {
+        u64             d_ino;
+        s64             d_off;
+        unsigned short  d_reclen;
+        unsigned char   d_type;
+        char            d_name[0];
+};
+
+
+struct getdents_callback64 {
+        struct linux_dirent64 * current_dir;
+        struct linux_dirent64 * previous;
+        int count;
+        int error;
+};
+
+struct linux_dirent {
+	unsigned long   d_ino;
+	unsigned long   d_off;
+	unsigned short  d_reclen;
+	char            d_name[1];
+};
+
+struct getdents_callback {
+	struct linux_dirent * current_dir;
+	struct linux_dirent * previous;
+	int count;
+	int error;
+};
+
+
+/*
+ * MACROS:
+ */
+
+/* file TO private_data */
+# define ftopd(file) ((struct mini_fo_file_info *)((file)->private_data))
+# define __ftopd(file) ((file)->private_data)
+/* file TO hidden_file */
+# define ftohf(file) ((ftopd(file))->wfi_file)
+# define ftohf2(file) ((ftopd(file))->wfi_file2)
+
+/* inode TO private_data */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+# define itopd(ino) ((struct mini_fo_inode_info *)(ino)->i_private)
+# define __itopd(ino) ((ino)->i_private)
+#else
+# define itopd(ino) ((struct mini_fo_inode_info *)(ino)->u.generic_ip)
+# define __itopd(ino) ((ino)->u.generic_ip)
+#endif
+/* inode TO hidden_inode */
+# define itohi(ino) (itopd(ino)->wii_inode)
+# define itohi2(ino) (itopd(ino)->wii_inode2)
+
+/* superblock TO private_data */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+# define stopd(super) ((struct mini_fo_sb_info *)(super)->s_fs_info)
+# define __stopd(super) ((super)->s_fs_info)
+#else
+# define stopd(super) ((struct mini_fo_sb_info *)(super)->u.generic_sbp)
+# define __stopd(super) ((super)->u.generic_sbp)
+#endif
+
+/* unused? # define vfs2priv stopd */
+/* superblock TO hidden_superblock */
+
+# define stohs(super) (stopd(super)->wsi_sb)
+# define stohs2(super) (stopd(super)->wsi_sb2)
+
+/* dentry TO private_data */
+# define dtopd(dentry) ((struct mini_fo_dentry_info *)(dentry)->d_fsdata)
+# define __dtopd(dentry) ((dentry)->d_fsdata)
+/* dentry TO hidden_dentry */
+# define dtohd(dent) (dtopd(dent)->wdi_dentry)
+# define dtohd2(dent) (dtopd(dent)->wdi_dentry2)
+
+/* dentry to state */
+# define dtost(dent) (dtopd(dent)->state)
+# define sbt(sb) ((sb)->s_type->name)
+
+#define IS_WRITE_FLAG(flag) (flag & (O_RDWR | O_WRONLY | O_APPEND))
+#define IS_COPY_FLAG(flag) (flag & (COPY_FLAGS))
+
+/* macros to simplify non-SCA code */
+#  define MALLOC_PAGE_POINTERS(hidden_pages, num_hidden_pages)
+#  define MALLOC_PAGEDATA_POINTERS(hidden_pages_data, num_hidden_pages)
+#  define FREE_PAGE_POINTERS(hidden_pages, num)
+#  define FREE_PAGEDATA_POINTERS(hidden_pages_data, num)
+#  define FOR_EACH_PAGE
+#  define CURRENT_HIDDEN_PAGE hidden_page
+#  define CURRENT_HIDDEN_PAGEDATA hidden_page_data
+#  define CURRENT_HIDDEN_PAGEINDEX page->index
+
+/*
+ * EXTERNALS:
+ */
+extern struct file_operations mini_fo_main_fops;
+extern struct file_operations mini_fo_dir_fops;
+extern struct inode_operations mini_fo_main_iops;
+extern struct inode_operations mini_fo_dir_iops;
+extern struct inode_operations mini_fo_symlink_iops;
+extern struct super_operations mini_fo_sops;
+extern struct dentry_operations mini_fo_dops;
+extern struct vm_operations_struct mini_fo_shared_vmops;
+extern struct vm_operations_struct mini_fo_private_vmops;
+extern struct address_space_operations mini_fo_aops;
+
+#if 0 /* unused by mini_fo */
+extern int mini_fo_interpose(dentry_t *hidden_dentry, dentry_t *this_dentry, super_block_t *sb, int flag);
+#if defined(FIST_FILTER_DATA) || defined(FIST_FILTER_SCA)
+extern page_t *mini_fo_get1page(file_t *file, int index);
+extern int mini_fo_fill_zeros(file_t *file, page_t *page, unsigned from);
+# endif /* FIST_FILTER_DATA || FIST_FILTER_SCA */
+
+
+#  define mini_fo_hidden_dentry(d) __mini_fo_hidden_dentry(__FILE__,__FUNCTION__,__LINE__,(d))
+#  define mini_fo_hidden_sto_dentry(d) __mini_fo_hidden_sto_dentry(__FILE__,__FUNCTION__,__LINE__,(d))
+
+extern dentry_t *__mini_fo_hidden_dentry(char *file, char *func, int line, dentry_t *this_dentry);
+extern dentry_t *__mini_fo_hidden_sto_dentry(char *file, char *func, int line, dentry_t *this_dentry);
+
+extern int mini_fo_read_file(const char *filename, void *buf, int len);
+extern int mini_fo_write_file(const char *filename, void *buf, int len);
+extern dentry_t *fist_lookup(dentry_t *dir, const char *name, vnode_t **out, uid_t uid, gid_t gid);
+#endif /* unused by mini_fo */
+
+/* state transition functions */
+extern int nondir_unmod_to_mod(dentry_t *dentry, int cp_flag);
+extern int nondir_del_rew_to_del(dentry_t *dentry);
+extern int nondir_creat_to_del(dentry_t *dentry);
+extern int nondir_mod_to_del(dentry_t *dentry);
+extern int nondir_unmod_to_del(dentry_t *dentry);
+
+extern int dir_unmod_to_mod(dentry_t *dentry);
+
+/* rename specials */
+extern int rename_directory(inode_t *old_dir, dentry_t *old_dentry, inode_t *new_dir, dentry_t *new_dentry);
+extern int rename_nondir(inode_t *old_dir, dentry_t *old_dentry, inode_t *new_dir, dentry_t *new_dentry);
+
+/* misc stuff */
+extern int mini_fo_tri_interpose(dentry_t *hidden_dentry,
+				 dentry_t *hidden_sto_dentry,
+				 dentry_t *dentry,
+				 super_block_t *sb, int flag);
+
+extern int mini_fo_cp_cont(dentry_t *tgt_dentry, struct vfsmount *tgt_mnt,
+			   dentry_t *src_dentry, struct vfsmount *src_mnt);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
+extern struct inode *mini_fo_iget(struct super_block *sb, unsigned long ino);
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+extern int mini_fo_create(inode_t *dir, dentry_t *dentry, int mode, struct nameidata *nd);
+
+extern int create_sto_nod(dentry_t *dentry, int mode, dev_t dev);
+extern int create_sto_reg_file(dentry_t *dentry, int mode, struct nameidata *nd);
+#else
+extern int mini_fo_create(inode_t *dir, dentry_t *dentry, int mode);
+
+extern int create_sto_nod(dentry_t *dentry, int mode, int dev);
+extern int create_sto_reg_file(dentry_t *dentry, int mode);
+#endif
+
+extern int create_sto_dir(dentry_t *dentry, int mode);
+
+extern int exists_in_storage(dentry_t *dentry);
+extern int is_mini_fo_existant(dentry_t *dentry);
+extern int get_neg_sto_dentry(dentry_t *dentry);
+extern int build_sto_structure(dentry_t *dir, dentry_t *dentry);
+extern int get_mini_fo_bpath(dentry_t *dentry, char **bpath, int *bpath_len);
+extern dentry_t *bpath_walk(super_block_t *sb, char *bpath);
+extern int bpath_put(dentry_t *dentry);
+
+/* check_mini_fo types functions */
+extern int check_mini_fo_dentry(dentry_t *dentry);
+extern int check_mini_fo_file(file_t *file);
+extern int check_mini_fo_inode(inode_t *inode);
+
+/* General meta functions, can be called from outside of meta.c */
+extern int meta_build_lists(dentry_t *dentry);
+extern int meta_put_lists(dentry_t *dentry);
+extern int __meta_put_lists(inode_t *inode);
+
+extern int meta_add_d_entry(dentry_t *dentry, const char *name, int len);
+extern int meta_add_r_entry(dentry_t *dentry,
+			    const char *old_name, int old_len,
+			    const char *new_name, int new_len);
+
+extern int meta_remove_r_entry(dentry_t *dentry, const char *name, int len);
+
+extern int meta_check_d_entry(dentry_t *dentry, const char *name, int len);
+extern int __meta_check_d_entry(inode_t *inode, const char *name, int len);
+
+extern char* meta_check_r_entry(dentry_t *dentry, const char *name, int len);
+extern char* __meta_check_r_entry(inode_t *inode, const char *name, int len);
+extern int meta_is_r_entry(dentry_t *dentry, const char *name, int len);
+extern int __meta_is_r_entry(inode_t *inode, const char *name, int len);
+
+/* Specific meta functions, should be called only inside meta.c */
+extern int __meta_put_d_list(inode_t *inode);
+extern int __meta_put_r_list(inode_t *inode);
+
+extern int meta_list_add_d_entry(dentry_t *dentry,
+				 const char *name, int len);
+extern int meta_list_add_r_entry(dentry_t *dentry,
+				 const char *old_name, int old_len,
+				 const char *new_name, int new_len);
+
+extern int meta_list_remove_r_entry(dentry_t *dentry,
+				    const char *name, int len);
+
+extern int __meta_list_remove_r_entry(inode_t *inode,
+				      const char *name, int len);
+
+extern int meta_write_d_entry(dentry_t *dentry, const char *name, int len);
+extern int meta_write_r_entry(dentry_t *dentry,
+			      const char *old_name, int old_len,
+			      const char *new_name, int new_len);
+
+extern int meta_sync_lists(dentry_t *dentry);
+extern int meta_sync_d_list(dentry_t *dentry, int app_flag);
+extern int meta_sync_r_list(dentry_t *dentry, int app_flag);
+
+/* ndl stuff */
+extern int ndl_add_entry(struct readdir_data *rd, const char *name, int len);
+extern void ndl_put_list(struct readdir_data *rd);
+extern int ndl_check_entry(struct readdir_data *rd,
+			   const char *name, int len);
+
+
+# define copy_inode_size(dst, src) \
+    dst->i_size = src->i_size; \
+    dst->i_blocks = src->i_blocks;
+
+static inline void
+fist_copy_attr_atime(inode_t *dest, const inode_t *src)
+{
+	ASSERT(dest != NULL);
+	ASSERT(src != NULL);
+	dest->i_atime = src->i_atime;
+}
+static inline void
+fist_copy_attr_times(inode_t *dest, const inode_t *src)
+{
+	ASSERT(dest != NULL);
+	ASSERT(src != NULL);
+	dest->i_atime = src->i_atime;
+	dest->i_mtime = src->i_mtime;
+	dest->i_ctime = src->i_ctime;
+}
+static inline void
+fist_copy_attr_timesizes(inode_t *dest, const inode_t *src)
+{
+	ASSERT(dest != NULL);
+	ASSERT(src != NULL);
+	dest->i_atime = src->i_atime;
+	dest->i_mtime = src->i_mtime;
+	dest->i_ctime = src->i_ctime;
+	copy_inode_size(dest, src);
+}
+static inline void
+fist_copy_attr_all(inode_t *dest, const inode_t *src)
+{
+	ASSERT(dest != NULL);
+	ASSERT(src != NULL);
+	dest->i_mode = src->i_mode;
+	dest->i_nlink = src->i_nlink;
+	dest->i_uid = src->i_uid;
+	dest->i_gid = src->i_gid;
+	dest->i_rdev = src->i_rdev;
+	dest->i_atime = src->i_atime;
+	dest->i_mtime = src->i_mtime;
+	dest->i_ctime = src->i_ctime;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+	dest->i_blksize = src->i_blksize;
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,12)
+	dest->i_blkbits = src->i_blkbits;
+# endif /* linux 2.4.12 and newer */
+	copy_inode_size(dest, src);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	dest->i_attr_flags = src->i_attr_flags;
+#else
+	dest->i_flags = src->i_flags;
+#endif
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+/* copied from linux/fs.h */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+static inline void double_lock(struct dentry *d1, struct dentry *d2)
+{
+	struct mutex *m1 = &d1->d_inode->i_mutex;
+	struct mutex *m2 = &d2->d_inode->i_mutex;
+	if (m1 != m2) {
+		if ((unsigned long) m1 < (unsigned long) m2) {
+			struct mutex *tmp = m2;
+			m2 = m1; m1 = tmp;
+		}
+		mutex_lock(m1);
+	}
+	mutex_lock(m2);
+}
+
+static inline void double_unlock(struct dentry *d1, struct dentry *d2)
+{
+	struct mutex *m1 = &d1->d_inode->i_mutex;
+	struct mutex *m2 = &d2->d_inode->i_mutex;
+	mutex_unlock(m1);
+	if (m1 != m2)
+		mutex_unlock(m2);
+	dput(d1);
+	dput(d2);
+}
+
+#else
+static inline void double_down(struct semaphore *s1, struct semaphore *s2)
+{
+        if (s1 != s2) {
+                if ((unsigned long) s1 < (unsigned long) s2) {
+                        struct semaphore *tmp = s2;
+                        s2 = s1; s1 = tmp;
+                }
+                down(s1);
+        }
+        down(s2);
+}
+
+static inline void double_up(struct semaphore *s1, struct semaphore *s2)
+{
+        up(s1);
+        if (s1 != s2)
+                up(s2);
+}
+
+static inline void double_lock(struct dentry *d1, struct dentry *d2)
+{
+        double_down(&d1->d_inode->i_sem, &d2->d_inode->i_sem);
+}
+
+static inline void double_unlock(struct dentry *d1, struct dentry *d2)
+{
+        double_up(&d1->d_inode->i_sem,&d2->d_inode->i_sem);
+        dput(d1);
+        dput(d2);
+}
+#endif   /* if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16) */
+#endif  /* if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0) */
+#endif /* __KERNEL__ */
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
+static inline dentry_t *nd_get_dentry(struct nameidata *nd)
+{
+	return (nd->path.dentry);
+}
+
+static inline struct vfsmount *nd_get_mnt(struct nameidata *nd)
+{
+	return (nd->path.mnt);
+}
+#else
+static inline dentry_t *nd_get_dentry(struct nameidata *nd)
+{
+	return (nd->dentry);
+}
+
+static inline struct vfsmount *nd_get_mnt(struct nameidata *nd)
+{
+	return (nd->mnt);
+}
+#endif
+
+/*
+ * Definitions for user and kernel code
+ */
+
+/* ioctls */
+
+#endif	/* not __MINI_FO_H_ */
diff -Nru linux-2.6.30.5/fs/mini_fo/mmap.c linux-2.6.30.5-wrt/fs/mini_fo/mmap.c
--- linux-2.6.30.5/fs/mini_fo/mmap.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/fs/mini_fo/mmap.c	2009-09-06 18:43:48.418666505 +0200
@@ -0,0 +1,637 @@
+/*
+ * Copyright (c) 1997-2003 Erez Zadok
+ * Copyright (c) 2001-2003 Stony Brook University
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package, or get one from ftp://ftp.filesystems.org/pub/fist/COPYING.
+ *
+ * This Copyright notice must be kept intact and distributed with all
+ * fistgen sources INCLUDING sources generated by fistgen.
+ */
+/*
+ * Copyright (C) 2004, 2005 Markus Klotzbuecher <mk@creamnet.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+/*
+ *  $Id$
+ */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif /* HAVE_CONFIG_H */
+
+#include "fist.h"
+#include "mini_fo.h"
+
+
+#ifdef FIST_COUNT_WRITES
+/* for counting writes in the middle vs. regular writes */
+unsigned long count_writes = 0, count_writes_middle = 0;
+#endif /* FIST_COUNT_WRITES */
+
+/* forward declaration of commit write and prepare write */
+STATIC int mini_fo_commit_write(file_t *file, page_t *page, unsigned from, unsigned to);
+STATIC int mini_fo_prepare_write(file_t *file, page_t *page, unsigned from, unsigned to);
+
+
+/*
+ * Function for handling creation of holes when lseek-ing past the
+ * end of the file and then writing some data.
+ */
+int
+mini_fo_fill_zeros(file_t* file, page_t *page, unsigned from)
+{
+	int err = 0;
+	dentry_t *dentry = file->f_dentry;
+	inode_t *inode = dentry->d_inode;
+	page_t *tmp_page;
+	int index;
+
+	print_entry_location();
+
+	for (index = inode->i_size >> PAGE_CACHE_SHIFT; index < page->index; index++) {
+		tmp_page = mini_fo_get1page(file, index);
+		if (IS_ERR(tmp_page)) {
+			err = PTR_ERR(tmp_page);
+			goto out;
+		}
+
+		/*
+		 * zero out rest of the contents of the page between the appropriate
+		 * offsets.
+		 */
+		memset((char*)page_address(tmp_page) + (inode->i_size & ~PAGE_CACHE_MASK), 0, PAGE_CACHE_SIZE - (inode->i_size & ~PAGE_CACHE_MASK));
+
+		if (! (err = mini_fo_prepare_write(file, tmp_page, 0, PAGE_CACHE_SIZE)))
+			err = mini_fo_commit_write(file, tmp_page, 0, PAGE_CACHE_SIZE);
+
+		page_cache_release(tmp_page);
+		if (err < 0)
+			goto out;
+		if (current->need_resched)
+			schedule();
+	}
+
+	/* zero out appropriate parts of last page */
+
+	/*
+	 * if the encoding type is block, then adjust the 'from' (where the
+	 * zeroing will start) offset appropriately
+	 */
+	from = from & (~(FIST_ENCODING_BLOCKSIZE - 1));
+
+	if ((from - (inode->i_size & ~PAGE_CACHE_MASK)) > 0) {
+
+		memset((char*)page_address(page) + (inode->i_size & ~PAGE_CACHE_MASK), 0, from - (inode->i_size & ~PAGE_CACHE_MASK));
+		if (! (err = mini_fo_prepare_write(file, page, 0, PAGE_CACHE_SIZE)))
+			err = mini_fo_commit_write(file, page, 0, PAGE_CACHE_SIZE);
+
+		if (err < 0)
+			goto out;
+		if (current->need_resched)
+			schedule();
+	}
+
+ out:
+	print_exit_status(err);
+	return err;
+}
+
+
+
+STATIC int
+mini_fo_writepage(page_t *page)
+{
+	int err = -EIO;
+	inode_t *inode;
+	inode_t *hidden_inode;
+	page_t *hidden_page;
+	char *kaddr, *hidden_kaddr;
+
+	print_entry_location();
+
+	inode = page->mapping->host;
+	hidden_inode = itohi(inode);
+
+	/*
+	 * writepage is called when shared mmap'ed files need to write
+	 * their pages, while prepare/commit_write are called from the
+	 * non-paged write() interface.  (However, in 2.3 the two interfaces
+	 * share the same cache, while in 2.2 they didn't.)
+	 *
+	 * So we pretty much have to duplicate much of what commit_write does.
+	 */
+
+	/* find lower page (returns a locked page) */
+	hidden_page = grab_cache_page(hidden_inode->i_mapping, page->index);
+	if (!hidden_page)
+		goto out;
+
+	/* get page address, and encode it */
+	kaddr = (char *) kmap(page);
+	hidden_kaddr = (char*) kmap(hidden_page);
+	mini_fo_encode_block(kaddr, hidden_kaddr, PAGE_CACHE_SIZE, inode, inode->i_sb, page->index);
+	/* if encode_block could fail, then return error */
+	kunmap(page);
+	kunmap(hidden_page);
+
+	/* call lower writepage (expects locked page) */
+	err = hidden_inode->i_mapping->a_ops->writepage(hidden_page);
+
+	/*
+	 * update mtime and ctime of lower level file system
+	 * mini_fo' mtime and ctime are updated by generic_file_write
+	 */
+	hidden_inode->i_mtime = hidden_inode->i_ctime = CURRENT_TIME;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,1)
+	UnlockPage(hidden_page);	/* b/c grab_cache_page locked it */
+# endif /* kernel older than 2.4.1 */
+	page_cache_release(hidden_page); /* b/c grab_cache_page increased refcnt */
+
+	if (err)
+		ClearPageUptodate(page);
+	else
+		SetPageUptodate(page);
+ out:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,1)
+	UnlockPage(page);
+# endif /* kernel 2.4.1 and newer */
+	print_exit_status(err);
+	return err;
+}
+
+
+/*
+ * get one page from cache or lower f/s, return error otherwise.
+ * returns unlocked, up-to-date page (if ok), with increased refcnt.
+ */
+page_t *
+mini_fo_get1page(file_t *file, int index)
+{
+	page_t *page;
+	dentry_t *dentry;
+	inode_t *inode;
+	struct address_space *mapping;
+	int err;
+
+	print_entry_location();
+
+	dentry = file->f_dentry; /* CPW: Moved below print_entry_location */
+	inode = dentry->d_inode;
+	mapping = inode->i_mapping;
+
+	fist_dprint(8, "%s: read page index %d pid %d\n", __FUNCTION__, index, current->pid);
+	if (index < 0) {
+		printk("%s BUG: index=%d\n", __FUNCTION__, index);
+		page = ERR_PTR(-EIO);
+		goto out;
+	}
+	page = read_cache_page(mapping,
+			       index,
+			       (filler_t *) mapping->a_ops->readpage,
+			       (void *) file);
+	if (IS_ERR(page))
+		goto out;
+	wait_on_page(page);
+	if (!Page_Uptodate(page)) {
+		lock_page(page);
+		err = mapping->a_ops->readpage(file, page);
+		if (err) {
+			page = ERR_PTR(err);
+			goto out;
+		}
+		wait_on_page(page);
+		if (!Page_Uptodate(page)) {
+			page = ERR_PTR(-EIO);
+			goto out;
+		}
+	}
+
+ out:
+	print_exit_pointer(page);
+	return page;
+}
+
+
+/*
+ * get one page from cache or lower f/s, return error otherwise.
+ * similar to get1page, but doesn't guarantee that it will return
+ * an unlocked page.
+ */
+page_t *
+mini_fo_get1page_cached(file_t *file, int index)
+{
+	page_t *page;
+	dentry_t *dentry;
+	inode_t *inode;
+	struct address_space *mapping;
+	int err;
+
+	print_entry_location();
+
+	dentry = file->f_dentry; /* CPW: Moved below print_entry_location */
+	inode = dentry->d_inode;
+	mapping = inode->i_mapping;
+
+	fist_dprint(8, "%s: read page index %d pid %d\n", __FUNCTION__, index, current->pid);
+	if (index < 0) {
+		printk("%s BUG: index=%d\n", __FUNCTION__, index);
+		page = ERR_PTR(-EIO);
+		goto out;
+	}
+	page = read_cache_page(mapping,
+			       index,
+			       (filler_t *) mapping->a_ops->readpage,
+			       (void *) file);
+	if (IS_ERR(page))
+		goto out;
+
+ out:
+	print_exit_pointer(page);
+	return page;
+}
+
+
+/*
+ * readpage is called from generic_page_read and the fault handler.
+ * If your file system uses generic_page_read for the read op, it
+ * must implement readpage.
+ *
+ * Readpage expects a locked page, and must unlock it.
+ */
+STATIC int
+mini_fo_do_readpage(file_t *file, page_t *page)
+{
+	int err = -EIO;
+	dentry_t *dentry;
+	file_t *hidden_file = NULL;
+	dentry_t *hidden_dentry;
+	inode_t *inode;
+	inode_t *hidden_inode;
+	char *page_data;
+	page_t *hidden_page;
+	char *hidden_page_data;
+	int real_size;
+
+	print_entry_location();
+
+	dentry = file->f_dentry; /* CPW: Moved below print_entry_location */
+	if (ftopd(file) != NULL)
+		hidden_file = ftohf(file);
+	hidden_dentry = dtohd(dentry);
+	inode = dentry->d_inode;
+	hidden_inode = itohi(inode);
+
+	fist_dprint(7, "%s: requesting page %d from file %s\n", __FUNCTION__, page->index, dentry->d_name.name);
+
+	MALLOC_PAGE_POINTERS(hidden_pages, num_hidden_pages);
+	MALLOC_PAGEDATA_POINTERS(hidden_pages_data, num_hidden_pages);
+	FOR_EACH_PAGE
+		CURRENT_HIDDEN_PAGE = NULL;
+
+	/* find lower page (returns a locked page) */
+	FOR_EACH_PAGE {
+		fist_dprint(8, "%s: Current page index = %d\n", __FUNCTION__, CURRENT_HIDDEN_PAGEINDEX);
+		CURRENT_HIDDEN_PAGE = read_cache_page(hidden_inode->i_mapping,
+						      CURRENT_HIDDEN_PAGEINDEX,
+						      (filler_t *) hidden_inode->i_mapping->a_ops->readpage,
+						      (void *) hidden_file);
+		if (IS_ERR(CURRENT_HIDDEN_PAGE)) {
+			err = PTR_ERR(CURRENT_HIDDEN_PAGE);
+			CURRENT_HIDDEN_PAGE = NULL;
+			goto out_release;
+		}
+	}
+
+	/*
+	 * wait for the page data to show up
+	 * (signaled by readpage as unlocking the page)
+	 */
+	FOR_EACH_PAGE {
+		wait_on_page(CURRENT_HIDDEN_PAGE);
+		if (!Page_Uptodate(CURRENT_HIDDEN_PAGE)) {
+			/*
+			 * call readpage() again if we returned from wait_on_page with a
+			 * page that's not up-to-date; that can happen when a partial
+			 * page has a few buffers which are ok, but not the whole
+			 * page.
+			 */
+			lock_page(CURRENT_HIDDEN_PAGE);
+			err = hidden_inode->i_mapping->a_ops->readpage(hidden_file,
+								       CURRENT_HIDDEN_PAGE);
+			if (err) {
+				CURRENT_HIDDEN_PAGE = NULL;
+				goto out_release;
+			}
+			wait_on_page(CURRENT_HIDDEN_PAGE);
+			if (!Page_Uptodate(CURRENT_HIDDEN_PAGE)) {
+				err = -EIO;
+				goto out_release;
+			}
+		}
+	}
+
+	/* map pages, get their addresses */
+	page_data = (char *) kmap(page);
+	FOR_EACH_PAGE
+		CURRENT_HIDDEN_PAGEDATA = (char *) kmap(CURRENT_HIDDEN_PAGE);
+
+	/* if decode_block could fail, then return error */
+	err = 0;
+	real_size = hidden_inode->i_size - (page->index << PAGE_CACHE_SHIFT);
+	if (real_size <= 0)
+		memset(page_data, 0, PAGE_CACHE_SIZE);
+	else if (real_size < PAGE_CACHE_SIZE) {
+		mini_fo_decode_block(hidden_page_data, page_data, real_size, inode, inode->i_sb, page->index);
+		memset(page_data + real_size, 0, PAGE_CACHE_SIZE - real_size);
+	} else
+		mini_fo_decode_block(hidden_page_data, page_data, PAGE_CACHE_SIZE, inode, inode->i_sb, page->index);
+
+	FOR_EACH_PAGE
+		kunmap(CURRENT_HIDDEN_PAGE);
+	kunmap(page);
+
+ out_release:
+	FOR_EACH_PAGE
+		if (CURRENT_HIDDEN_PAGE)
+			page_cache_release(CURRENT_HIDDEN_PAGE); /* undo read_cache_page */
+
+	FREE_PAGE_POINTERS(hidden_pages, num_hidden_pages);
+	FREE_PAGEDATA_POINTERS(hidden_pages_data, num_hidden_pages);
+
+ out:
+	if (err == 0)
+		SetPageUptodate(page);
+	else
+		ClearPageUptodate(page);
+
+	print_exit_status(err);
+	return err;
+}
+
+
+STATIC int
+mini_fo_readpage(file_t *file, page_t *page)
+{
+	int err;
+	print_entry_location();
+
+	err = mini_fo_do_readpage(file, page);
+
+	/*
+	 * we have to unlock our page, b/c we _might_ have gotten a locked page.
+	 * but we no longer have to wakeup on our page here, b/c UnlockPage does
+	 * it
+	 */
+	UnlockPage(page);
+
+	print_exit_status(err);
+	return err;
+}
+
+
+STATIC int
+mini_fo_prepare_write(file_t *file, page_t *page, unsigned from, unsigned to)
+{
+	int err = 0;
+
+	print_entry_location();
+
+	/*
+	 * we call kmap(page) only here, and do the kunmap
+	 * and the actual downcalls, including unlockpage and uncache
+	 * in commit_write.
+	 */
+	kmap(page);
+
+	/* fast path for whole page writes */
+	if (from == 0 && to == PAGE_CACHE_SIZE)
+		goto out;
+	/* read the page to "revalidate" our data */
+	/* call the helper function which doesn't unlock the page */
+	if (!Page_Uptodate(page))
+		err = mini_fo_do_readpage(file, page);
+
+ out:
+	print_exit_status(err);
+	return err;
+}
+
+
+
+STATIC int
+mini_fo_commit_write(file_t *file, page_t *page, unsigned from, unsigned to)
+{
+	int err = -ENOMEM;
+	inode_t *inode;
+	inode_t *hidden_inode;
+	page_t *hidden_page;
+	file_t *hidden_file = NULL;
+	loff_t pos;
+	unsigned bytes = to - from;
+	unsigned hidden_from, hidden_to, hidden_bytes;
+
+	print_entry_location();
+
+	inode = page->mapping->host; /* CPW: Moved below print_entry_location */
+	hidden_inode = itohi(inode);
+
+	ASSERT(file != NULL);
+	/*
+	 * here we have a kmapped page, with data from the user copied
+	 * into it.  we need to encode_block it, and then call the lower
+	 * commit_write.  We also need to simulate same behavior of
+	 * generic_file_write, and call prepare_write on the lower f/s first.
+	 */
+#ifdef FIST_COUNT_WRITES
+	count_writes++;
+# endif /* FIST_COUNT_WRITES */
+
+	/* this is append and/or extend -- we can't have holes so fill them in */
+	if (page->index > (hidden_inode->i_size >> PAGE_CACHE_SHIFT)) {
+		page_t *tmp_page;
+		int index;
+		for (index = hidden_inode->i_size >> PAGE_CACHE_SHIFT; index < page->index; index++) {
+			tmp_page = mini_fo_get1page(file, index);
+			if (IS_ERR(tmp_page)) {
+				err = PTR_ERR(tmp_page);
+				goto out;
+			}
+			/* zero out the contents of the page at the appropriate offsets */
+			memset((char*)page_address(tmp_page) + (inode->i_size & ~PAGE_CACHE_MASK), 0, PAGE_CACHE_SIZE - (inode->i_size & ~PAGE_CACHE_MASK));
+			if (!(err = mini_fo_prepare_write(file, tmp_page, 0, PAGE_CACHE_SIZE)))
+				err = mini_fo_commit_write(file, tmp_page, 0, PAGE_CACHE_SIZE);
+			page_cache_release(tmp_page);
+			if (err < 0)
+				goto out;
+			if (current->need_resched)
+				schedule();
+		}
+	}
+
+	if (ftopd(file) != NULL)
+		hidden_file = ftohf(file);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+	mutex_lock(&hidden_inode->i_mutex);
+#else
+	down(&hidden_inode->i_sem);
+#endif
+	/* find lower page (returns a locked page) */
+	hidden_page = grab_cache_page(hidden_inode->i_mapping, page->index);
+	if (!hidden_page)
+		goto out;
+
+#if FIST_ENCODING_BLOCKSIZE > 1
+#  error encoding_blocksize greater than 1 is not yet supported
+# endif /* FIST_ENCODING_BLOCKSIZE > 1 */
+
+	hidden_from = from & (~(FIST_ENCODING_BLOCKSIZE - 1));
+	hidden_to = ((to + FIST_ENCODING_BLOCKSIZE - 1) & (~(FIST_ENCODING_BLOCKSIZE - 1)));
+	if ((page->index << PAGE_CACHE_SHIFT) + to > hidden_inode->i_size) {
+
+		/*
+		 * if this call to commit_write had introduced holes and the code
+		 * for handling holes was invoked, then the beginning of this page
+		 * must be zeroed out
+		 * zero out bytes from 'size_of_file%pagesize' to 'from'.
+		 */
+		if ((hidden_from - (inode->i_size & ~PAGE_CACHE_MASK)) > 0)
+			memset((char*)page_address(page) + (inode->i_size & ~PAGE_CACHE_MASK), 0, hidden_from - (inode->i_size & ~PAGE_CACHE_MASK));
+
+	}
+	hidden_bytes = hidden_to - hidden_from;
+
+	/* call lower prepare_write */
+	err = -EINVAL;
+	if (hidden_inode->i_mapping &&
+	    hidden_inode->i_mapping->a_ops &&
+	    hidden_inode->i_mapping->a_ops->prepare_write)
+		err = hidden_inode->i_mapping->a_ops->prepare_write(hidden_file,
+								    hidden_page,
+								    hidden_from,
+								    hidden_to);
+	if (err)
+		/* don't leave locked pages behind, esp. on an ENOSPC */
+		goto out_unlock;
+
+	fist_dprint(8, "%s: encoding %d bytes\n", __FUNCTION__, hidden_bytes);
+	mini_fo_encode_block((char *) page_address(page) + hidden_from, (char*) page_address(hidden_page) + hidden_from, hidden_bytes, inode, inode->i_sb, page->index);
+	/* if encode_block could fail, then goto unlock and return error */
+
+	/* call lower commit_write */
+	err = hidden_inode->i_mapping->a_ops->commit_write(hidden_file,
+							   hidden_page,
+							   hidden_from,
+							   hidden_to);
+
+	if (err < 0)
+		goto out_unlock;
+
+	err = bytes;	/* convert error to no. of bytes */
+
+	inode->i_blocks = hidden_inode->i_blocks;
+	/* we may have to update i_size */
+	pos = (page->index << PAGE_CACHE_SHIFT) + to;
+	if (pos > inode->i_size)
+		inode->i_size = pos;
+
+	/*
+	 * update mtime and ctime of lower level file system
+	 * mini_fo' mtime and ctime are updated by generic_file_write
+	 */
+	hidden_inode->i_mtime = hidden_inode->i_ctime = CURRENT_TIME;
+
+	mark_inode_dirty_sync(inode);
+
+ out_unlock:
+	UnlockPage(hidden_page);
+	page_cache_release(hidden_page);
+	kunmap(page);		/* kmap was done in prepare_write */
+ out:
+	/* we must set our page as up-to-date */
+	if (err < 0)
+		ClearPageUptodate(page);
+	else
+		SetPageUptodate(page);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+	mutex_unlock(&hidden_inode->i_mutex);
+#else
+	up(&hidden_inode->i_sem);
+#endif
+	print_exit_status(err);
+	return err;			/* assume all is ok */
+}
+
+
+STATIC int
+mini_fo_bmap(struct address_space *mapping, long block)
+{
+	int err = 0;
+	inode_t *inode;
+	inode_t *hidden_inode;
+
+	print_entry_location();
+
+	inode = (inode_t *) mapping->host;
+	hidden_inode = itohi(inode);
+
+	if (hidden_inode->i_mapping->a_ops->bmap)
+		err = hidden_inode->i_mapping->a_ops->bmap(hidden_inode->i_mapping, block);
+	print_exit_location();
+	return err;
+}
+
+
+/*
+ * This function is copied verbatim from mm/filemap.c.
+ * XXX: It should be simply moved to some header file instead -- bug Al about it!
+ */
+static inline int sync_page(struct page *page)
+{
+	struct address_space *mapping = page->mapping;
+
+	if (mapping && mapping->a_ops && mapping->a_ops->sync_page)
+		return mapping->a_ops->sync_page(page);
+	return 0;
+}
+
+
+/*
+ * XXX: we may not need this function if not FIST_FILTER_DATA.
+ * FIXME: for FIST_FILTER_SCA, get all lower pages and sync them each.
+ */
+STATIC int
+mini_fo_sync_page(page_t *page)
+{
+	int err = 0;
+	inode_t *inode;
+	inode_t *hidden_inode;
+	page_t *hidden_page;
+
+	print_entry_location();
+
+	inode = page->mapping->host; /* CPW: Moved below print_entry_location */
+	hidden_inode = itohi(inode);
+
+	/* find lower page (returns a locked page) */
+	hidden_page = grab_cache_page(hidden_inode->i_mapping, page->index);
+	if (!hidden_page)
+		goto out;
+
+	err = sync_page(hidden_page);
+
+	UnlockPage(hidden_page);	/* b/c grab_cache_page locked it */
+	page_cache_release(hidden_page); /* b/c grab_cache_page increased refcnt */
+
+ out:
+	print_exit_status(err);
+	return err;
+}
diff -Nru linux-2.6.30.5/fs/mini_fo/state.c linux-2.6.30.5-wrt/fs/mini_fo/state.c
--- linux-2.6.30.5/fs/mini_fo/state.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/fs/mini_fo/state.c	2009-09-06 18:43:48.418666505 +0200
@@ -0,0 +1,620 @@
+/*
+ * Copyright (C) 2005 Markus Klotzbuecher <mk@creamnet.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif /* HAVE_CONFIG_H */
+
+#include "fist.h"
+#include "mini_fo.h"
+
+
+/* create the storage file, setup new states */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+int create_sto_reg_file(dentry_t *dentry, int mode, struct nameidata *nd)
+#else
+int create_sto_reg_file(dentry_t *dentry, int mode)
+#endif
+{
+	int err = 0;
+	inode_t *dir;
+	dentry_t *hidden_sto_dentry;
+	dentry_t *hidden_sto_dir_dentry;
+
+	if(exists_in_storage(dentry)) {
+		printk(KERN_CRIT "mini_fo: create_sto_file: wrong type or state.\n");
+		err = -EINVAL;
+		goto out;
+	}
+	err = get_neg_sto_dentry(dentry);
+
+	if (err) {
+		printk(KERN_CRIT "mini_fo: create_sto_file: ERROR getting neg. sto dentry.\n");
+		goto out;
+	}
+
+	dir = dentry->d_parent->d_inode;
+	hidden_sto_dentry = dtohd2(dentry);
+
+	/* lock parent */
+	hidden_sto_dir_dentry = dget(hidden_sto_dentry->d_parent);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+	mutex_lock(&hidden_sto_dir_dentry->d_inode->i_mutex);
+#else
+        down(&hidden_sto_dir_dentry->d_inode->i_sem);
+#endif
+
+	err = PTR_ERR(hidden_sto_dir_dentry);
+        if (IS_ERR(hidden_sto_dir_dentry))
+                goto out;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	err = vfs_create(hidden_sto_dir_dentry->d_inode,
+			 hidden_sto_dentry,
+			 mode, nd);
+#else
+	err = vfs_create(hidden_sto_dir_dentry->d_inode,
+			 hidden_sto_dentry,
+			 mode);
+#endif
+        if(err) {
+		printk(KERN_CRIT "mini_fo: create_sto_file: ERROR creating sto file.\n");
+                goto out_lock;
+	}
+
+	if(!dtohd2(dentry)->d_inode) {
+		printk(KERN_CRIT "mini_fo: create_sto_file: ERROR creating sto file [2].\n");
+                err = -EINVAL;
+                goto out_lock;
+        }
+
+        /* interpose the new inode */
+        if(dtost(dentry) == DELETED) {
+                dtost(dentry) = DEL_REWRITTEN;
+                err = mini_fo_tri_interpose(NULL, hidden_sto_dentry, dentry, dir->i_sb, 0);
+                if(err)
+                        goto out_lock;
+        }
+        else if(dtost(dentry) == NON_EXISTANT) {
+                dtost(dentry) = CREATED;
+                err = mini_fo_tri_interpose(dtohd(dentry), hidden_sto_dentry, dentry, dir->i_sb, 0);
+                if(err)
+                        goto out_lock;
+        }
+        else if(dtost(dentry) == UNMODIFIED) {
+                dtost(dentry) = MODIFIED;
+                /* interpose on new inode */
+                if(itohi2(dentry->d_inode) != NULL) {
+                        printk(KERN_CRIT "mini_fo: create_sto_file: invalid inode detected.\n");
+                        err = -EINVAL;
+                        goto out_lock;
+                }
+                itohi2(dentry->d_inode) = igrab(dtohd2(dentry)->d_inode);
+	}
+	fist_copy_attr_timesizes(dentry->d_parent->d_inode,
+				 hidden_sto_dir_dentry->d_inode);
+
+ out_lock:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+	mutex_unlock(&hidden_sto_dir_dentry->d_inode->i_mutex);
+#else
+	up(&hidden_sto_dir_dentry->d_inode->i_sem);
+#endif
+        dput(hidden_sto_dir_dentry);
+ out:
+	return err;
+}
+
+/* create the sto dir, setup states */
+int create_sto_dir(dentry_t *dentry, int mode)
+{
+	int err = 0;
+	inode_t *dir;
+	dentry_t *hidden_sto_dentry;
+        dentry_t *hidden_sto_dir_dentry;
+
+	/* had to take the "!S_ISDIR(mode))" check out, because it failed */
+	if(exists_in_storage(dentry)) {
+                printk(KERN_CRIT "mini_fo: create_sto_dir: wrong type or state.\\
+n");
+                err = -EINVAL;
+                goto out;
+        }
+
+	err = get_neg_sto_dentry(dentry);
+	if(err) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	dir = dentry->d_parent->d_inode;
+	hidden_sto_dentry = dtohd2(dentry);
+
+	/* was: hidden_sto_dir_dentry = lock_parent(hidden_sto_dentry); */
+	hidden_sto_dir_dentry = dget(hidden_sto_dentry->d_parent);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+	mutex_lock(&hidden_sto_dir_dentry->d_inode->i_mutex);
+#else
+	down(&hidden_sto_dir_dentry->d_inode->i_sem);
+#endif
+
+	err = PTR_ERR(hidden_sto_dir_dentry);
+	if (IS_ERR(hidden_sto_dir_dentry))
+		goto out;
+
+	err = vfs_mkdir(hidden_sto_dir_dentry->d_inode,
+			hidden_sto_dentry,
+			mode);
+	if(err) {
+		printk(KERN_CRIT "mini_fo: create_sto_dir: ERROR creating sto dir.\n");
+		goto out_lock;
+	}
+
+	if(!dtohd2(dentry)->d_inode) {
+		printk(KERN_CRIT "mini_fo: create_sto_dir: ERROR creating sto dir [2].\n");
+		err = -EINVAL;
+		goto out_lock;
+	}
+
+	/* interpose the new inode */
+	if(dtost(dentry) == DELETED) {
+		dtost(dentry) = DEL_REWRITTEN;
+		err = mini_fo_tri_interpose(NULL, hidden_sto_dentry, dentry, dir->i_sb, 0);
+		if(err)
+			goto out_lock;
+	}
+	else if(dtopd(dentry)->state == NON_EXISTANT) {
+		dtopd(dentry)->state = CREATED;
+		err = mini_fo_tri_interpose(dtohd(dentry), hidden_sto_dentry, dentry, dir->i_sb, 0);
+		if(err)
+			goto out_lock;
+	}
+	else if(dtopd(dentry)->state == UNMODIFIED) {
+		dtopd(dentry)->state = MODIFIED;
+		/* interpose on new inode */
+		if(itohi2(dentry->d_inode) != NULL) {
+			printk(KERN_CRIT "mini_fo:  create_sto_dir: ERROR, invalid inode detected.\n");
+			err = -EINVAL;
+			goto out_lock;
+		}
+		itohi2(dentry->d_inode) = igrab(dtohd2(dentry)->d_inode);
+	}
+
+	fist_copy_attr_timesizes(dir, hidden_sto_dir_dentry->d_inode);
+
+	/* initalize the wol list */
+	itopd(dentry->d_inode)->deleted_list_size = -1;
+	itopd(dentry->d_inode)->renamed_list_size = -1;
+	meta_build_lists(dentry);
+
+
+ out_lock:
+	/* was: unlock_dir(hidden_sto_dir_dentry); */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+	mutex_unlock(&hidden_sto_dir_dentry->d_inode->i_mutex);
+#else
+	up(&hidden_sto_dir_dentry->d_inode->i_sem);
+#endif
+	dput(hidden_sto_dir_dentry);
+ out:
+	return err;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+int create_sto_nod(dentry_t *dentry, int mode, dev_t dev)
+#else
+int create_sto_nod(dentry_t *dentry, int mode, int dev)
+#endif
+{
+	int err = 0;
+	inode_t *dir;
+	dentry_t *hidden_sto_dentry;
+	dentry_t *hidden_sto_dir_dentry;
+
+	if(exists_in_storage(dentry)) {
+		err = -EEXIST;
+		goto out;
+	}
+	err = get_neg_sto_dentry(dentry);
+
+	if (err) {
+                printk(KERN_CRIT "mini_fo: create_sto_nod: ERROR getting neg. sto dentry.\n");
+                goto out;
+        }
+
+	dir = dentry->d_parent->d_inode;
+	hidden_sto_dentry = dtohd2(dentry);
+
+	/* lock parent */
+	hidden_sto_dir_dentry = dget(hidden_sto_dentry->d_parent);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+	mutex_lock(&hidden_sto_dir_dentry->d_inode->i_mutex);
+#else
+	down(&hidden_sto_dir_dentry->d_inode->i_sem);
+#endif
+
+	err = PTR_ERR(hidden_sto_dir_dentry);
+	if (IS_ERR(hidden_sto_dir_dentry))
+		goto out;
+
+	err = vfs_mknod(hidden_sto_dir_dentry->d_inode, hidden_sto_dentry, mode, dev);
+	if(err)
+		goto out_lock;
+
+	if(!dtohd2(dentry)->d_inode) {
+		printk(KERN_CRIT "mini_fo: create_sto_nod: creating storage inode failed [1].\n");
+		err = -EINVAL; /* return something indicating failure */
+		goto out_lock;
+	}
+
+	/* interpose the new inode */
+	if(dtost(dentry) == DELETED) {
+		dtost(dentry) = DEL_REWRITTEN;
+		err = mini_fo_tri_interpose(NULL, hidden_sto_dentry, dentry, dir->i_sb, 0);
+		if(err)
+			goto out_lock;
+	}
+	else if(dtost(dentry) == NON_EXISTANT) {
+		dtost(dentry) = CREATED;
+		err = mini_fo_tri_interpose(dtohd(dentry), hidden_sto_dentry, dentry, dir->i_sb, 0);
+		if(err)
+			goto out_lock;
+	}
+	else if(dtost(dentry) == UNMODIFIED) {
+		dtost(dentry) = MODIFIED;
+		/* interpose on new inode */
+		if(itohi2(dentry->d_inode) != NULL) {
+			printk(KERN_CRIT "mini_fo: create_sto_nod: error, invalid inode detected.\n");
+			err = -EINVAL;
+			goto out_lock;
+		}
+		itohi2(dentry->d_inode) = igrab(dtohd2(dentry)->d_inode);
+	}
+
+	fist_copy_attr_timesizes(dir, hidden_sto_dir_dentry->d_inode);
+
+ out_lock:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+	mutex_unlock(&hidden_sto_dir_dentry->d_inode->i_mutex);
+#else
+	up(&hidden_sto_dir_dentry->d_inode->i_sem);
+#endif
+	dput(hidden_sto_dir_dentry);
+ out:
+	return err;
+}
+
+
+/* unimplemented (and possibly not usefull):
+
+   nondir-del_to_del_rew
+   nondir-non_exist_to_creat
+
+   dir-unmod_to_del
+   dir-mod_to_del
+   dir-creat_to_del
+   dir-del_rew_to_del
+   dir-del_to_del_rew
+   dir-non_exist_to_creat
+*/
+
+
+/* bring a file of any type from state UNMODIFIED to MODIFIED */
+int nondir_unmod_to_mod(dentry_t *dentry, int cp_flag)
+{
+	int err = 0;
+	struct vfsmount *tgt_mnt;
+	struct vfsmount *src_mnt;
+	dentry_t *tgt_dentry;
+	dentry_t *src_dentry;
+	dentry_t *hidden_sto_dentry;
+	dentry_t *hidden_sto_dir_dentry;
+
+	check_mini_fo_dentry(dentry);
+
+	if((dtost(dentry) != UNMODIFIED) ||
+	   S_ISDIR(dentry->d_inode->i_mode)) {
+		printk(KERN_CRIT "mini_fo: nondir_unmod_to_mod: \
+                                  wrong type or state.\n");
+		err = -1;
+		goto out;
+	}
+	err = get_neg_sto_dentry(dentry);
+
+	if (err) {
+		printk(KERN_CRIT "mini_fo: nondir_unmod_to_mod: \
+                                  ERROR getting neg. sto dentry.\n");
+		goto out;
+	}
+
+	/* create sto file */
+	hidden_sto_dentry = dtohd2(dentry);
+
+	/* lock parent */
+	hidden_sto_dir_dentry = dget(hidden_sto_dentry->d_parent);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+	mutex_lock(&hidden_sto_dir_dentry->d_inode->i_mutex);
+#else
+        down(&hidden_sto_dir_dentry->d_inode->i_sem);
+#endif
+
+	err = PTR_ERR(hidden_sto_dir_dentry);
+        if (IS_ERR(hidden_sto_dir_dentry))
+                goto out;
+
+	/* handle different types of nondirs */
+	if(S_ISCHR(dentry->d_inode->i_mode) ||
+	   S_ISBLK(dentry->d_inode->i_mode)) {
+		err = vfs_mknod(hidden_sto_dir_dentry->d_inode,
+				hidden_sto_dentry,
+				dtohd(dentry)->d_inode->i_mode,
+				dtohd(dentry)->d_inode->i_rdev);
+	}
+
+	else if(S_ISREG(dentry->d_inode->i_mode)) {
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+		err = vfs_create(hidden_sto_dir_dentry->d_inode,
+				 hidden_sto_dentry,
+				 dtohd(dentry)->d_inode->i_mode, NULL);
+#else
+		err = vfs_create(hidden_sto_dir_dentry->d_inode,
+				 hidden_sto_dentry,
+				 dtohd(dentry)->d_inode->i_mode);
+#endif
+	}
+        if(err) {
+		printk(KERN_CRIT "mini_fo: nondir_unmod_to_mod: \
+                                  ERROR creating sto file.\n");
+                goto out_lock;
+	}
+
+	/* interpose on new inode */
+	if(itohi2(dentry->d_inode) != NULL) {
+		printk(KERN_CRIT "mini_fo: nondir_unmod_to_mod: \
+                                  ERROR, invalid inode detected.\n");
+		err = -EINVAL;
+		goto out_lock;
+	}
+
+	itohi2(dentry->d_inode) = igrab(dtohd2(dentry)->d_inode);
+
+        fist_copy_attr_timesizes(dentry->d_parent->d_inode,
+				 hidden_sto_dir_dentry->d_inode);
+	dtost(dentry) = MODIFIED;
+
+	/* copy contents if regular file and cp_flag = 1 */
+	if((cp_flag == 1) && S_ISREG(dentry->d_inode->i_mode)) {
+
+		/* unlock first */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+		mutex_unlock(&hidden_sto_dir_dentry->d_inode->i_mutex);
+#else
+		up(&hidden_sto_dir_dentry->d_inode->i_sem);
+#endif
+
+		dput(hidden_sto_dir_dentry);
+
+		tgt_dentry = dtohd2(dentry);
+		tgt_mnt = stopd(dentry->d_inode->i_sb)->hidden_mnt2;
+		src_dentry = dtohd(dentry);
+		src_mnt = stopd(dentry->d_inode->i_sb)->hidden_mnt;
+
+		err = mini_fo_cp_cont(tgt_dentry, tgt_mnt,
+				      src_dentry, src_mnt);
+		if(err) {
+			printk(KERN_CRIT "mini_fo: nondir_unmod_to_mod: \
+                                          ERROR copying contents.\n");
+		}
+		goto out;
+	}
+
+ out_lock:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+	mutex_unlock(&hidden_sto_dir_dentry->d_inode->i_mutex);
+#else
+	up(&hidden_sto_dir_dentry->d_inode->i_sem);
+#endif
+        dput(hidden_sto_dir_dentry);
+ out:
+	return err;
+}
+
+/* this function is currently identical to nondir_creat_to_del */
+int nondir_del_rew_to_del(dentry_t *dentry)
+{
+	return nondir_creat_to_del(dentry);
+}
+
+int nondir_creat_to_del(dentry_t *dentry)
+{
+	int err = 0;
+
+	inode_t *hidden_sto_dir_inode;
+	dentry_t *hidden_sto_dir_dentry;
+	dentry_t *hidden_sto_dentry;
+
+	check_mini_fo_dentry(dentry);
+
+	/* for now this function serves for both state DEL_REWRITTEN and
+	 * CREATED */
+	if(!(dtost(dentry) == CREATED || (dtost(dentry) == DEL_REWRITTEN)) ||
+	   S_ISDIR(dentry->d_inode->i_mode)) {
+		printk(KERN_CRIT "mini_fo: nondir_mod_to_del/del_rew_to_del: \
+                                  wrong type or state.\n");
+		err = -1;
+		goto out;
+	}
+
+	hidden_sto_dir_inode = itohi2(dentry->d_parent->d_inode);
+	hidden_sto_dentry = dtohd2(dentry);
+
+	/* was: hidden_sto_dir_dentry = lock_parent(hidden_sto_dentry);*/
+	hidden_sto_dir_dentry = dget(hidden_sto_dentry->d_parent);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+	mutex_lock(&hidden_sto_dir_dentry->d_inode->i_mutex);
+#else
+	down(&hidden_sto_dir_dentry->d_inode->i_sem);
+#endif
+
+	/* avoid destroying the hidden inode if the file is in use */
+	dget(hidden_sto_dentry);
+	err = vfs_unlink(hidden_sto_dir_inode, hidden_sto_dentry);
+	dput(hidden_sto_dentry);
+	if(!err)
+		d_delete(hidden_sto_dentry);
+
+	/* propagate number of hard-links */
+	dentry->d_inode->i_nlink = itohi2(dentry->d_inode)->i_nlink;
+
+	dtost(dentry) = NON_EXISTANT;
+
+	/* was: unlock_dir(hidden_sto_dir_dentry); */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+	mutex_unlock(&hidden_sto_dir_dentry->d_inode->i_mutex);
+#else
+	up(&hidden_sto_dir_dentry->d_inode->i_sem);
+#endif
+	dput(hidden_sto_dir_dentry);
+
+ out:
+	return err;
+}
+
+int nondir_mod_to_del(dentry_t *dentry)
+{
+	int err;
+	dentry_t *hidden_sto_dentry;
+	inode_t *hidden_sto_dir_inode;
+	dentry_t *hidden_sto_dir_dentry;
+
+	check_mini_fo_dentry(dentry);
+
+	if(dtost(dentry) != MODIFIED ||
+	   S_ISDIR(dentry->d_inode->i_mode)) {
+		printk(KERN_CRIT "mini_fo: nondir_mod_to_del: \
+                                  wrong type or state.\n");
+		err = -1;
+		goto out;
+	}
+
+	hidden_sto_dir_inode = itohi2(dentry->d_parent->d_inode);
+	hidden_sto_dentry = dtohd2(dentry);
+
+	/* was hidden_sto_dir_dentry = lock_parent(hidden_sto_dentry); */
+	hidden_sto_dir_dentry = dget(hidden_sto_dentry->d_parent);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+	mutex_lock(&hidden_sto_dir_dentry->d_inode->i_mutex);
+#else
+	down(&hidden_sto_dir_dentry->d_inode->i_sem);
+#endif
+
+	/* avoid destroying the hidden inode if the file is in use */
+	dget(hidden_sto_dentry);
+	err = vfs_unlink(hidden_sto_dir_inode, hidden_sto_dentry);
+	dput(hidden_sto_dentry);
+	if(!err)
+		d_delete(hidden_sto_dentry);
+
+	/* propagate number of hard-links */
+	dentry->d_inode->i_nlink = itohi2(dentry->d_inode)->i_nlink;
+
+	/* dput base dentry, this will relase the inode and free the
+	 * dentry, as we will never need it again. */
+	dput(dtohd(dentry));
+	dtohd(dentry) = NULL;
+	dtost(dentry) = DELETED;
+
+	/* add deleted file to META-file */
+	meta_add_d_entry(dentry->d_parent,
+			 dentry->d_name.name,
+			 dentry->d_name.len);
+
+	/* was: unlock_dir(hidden_sto_dir_dentry); */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+	mutex_unlock(&hidden_sto_dir_dentry->d_inode->i_mutex);
+#else
+	up(&hidden_sto_dir_dentry->d_inode->i_sem);
+#endif
+	dput(hidden_sto_dir_dentry);
+
+ out:
+	return err;
+}
+
+int nondir_unmod_to_del(dentry_t *dentry)
+{
+	int err = 0;
+
+	check_mini_fo_dentry(dentry);
+
+	if(dtost(dentry) != UNMODIFIED ||
+	   S_ISDIR(dentry->d_inode->i_mode)) {
+		printk(KERN_CRIT "mini_fo: nondir_unmod_to_del: \
+                                  wrong type or state.\n");
+		err = -1;
+		goto out;
+	}
+
+	 /* next we have to get a negative dentry for the storage file */
+	err = get_neg_sto_dentry(dentry);
+
+	if(err)
+		goto out;
+
+	/* add deleted file to META lists */
+	err = meta_add_d_entry(dentry->d_parent,
+			       dentry->d_name.name,
+			       dentry->d_name.len);
+
+	if(err)
+		goto out;
+
+	/* dput base dentry, this will relase the inode and free the
+	 * dentry, as we will never need it again. */
+	dput(dtohd(dentry));
+	dtohd(dentry) = NULL;
+	dtost(dentry) = DELETED;
+
+ out:
+	return err;
+}
+
+/* bring a dir from state UNMODIFIED to MODIFIED */
+int dir_unmod_to_mod(dentry_t *dentry)
+{
+	int err;
+
+	check_mini_fo_dentry(dentry);
+
+	if(dtost(dentry) != UNMODIFIED ||
+	   !S_ISDIR(dentry->d_inode->i_mode)) {
+		printk(KERN_CRIT "mini_fo: dir_unmod_to_mod: \
+                                  wrong type or state.\n");
+		err = -1;
+		goto out;
+	}
+
+	/* this creates our dir incl. sto. structure */
+	err = build_sto_structure(dentry->d_parent, dentry);
+	if(err) {
+		printk(KERN_CRIT "mini_fo: dir_unmod_to_mod: \
+                                  build_sto_structure failed.\n");
+		goto out;
+	}
+ out:
+	return err;
+}
+
diff -Nru linux-2.6.30.5/fs/mini_fo/super.c linux-2.6.30.5-wrt/fs/mini_fo/super.c
--- linux-2.6.30.5/fs/mini_fo/super.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/fs/mini_fo/super.c	2009-09-06 18:43:48.426667806 +0200
@@ -0,0 +1,306 @@
+/*
+ * Copyright (c) 1997-2003 Erez Zadok
+ * Copyright (c) 2001-2003 Stony Brook University
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package, or get one from ftp://ftp.filesystems.org/pub/fist/COPYING.
+ *
+ * This Copyright notice must be kept intact and distributed with all
+ * fistgen sources INCLUDING sources generated by fistgen.
+ */
+/*
+ * Copyright (C) 2004, 2005 Markus Klotzbuecher <mk@creamnet.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+/*
+ *  $Id$
+ */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include "fist.h"
+#include "mini_fo.h"
+
+
+STATIC void
+mini_fo_read_inode(inode_t *inode)
+{
+	static struct address_space_operations mini_fo_empty_aops;
+
+	__itopd(inode) = kmalloc(sizeof(struct mini_fo_inode_info), GFP_KERNEL);
+	if (!itopd(inode)) {
+		printk("<0>%s:%s:%d: No kernel memory!\n", __FILE__, __FUNCTION__, __LINE__);
+		ASSERT(NULL);
+	}
+	itohi(inode) = NULL;
+	itohi2(inode) = NULL;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	inode->i_version++;
+#else
+	inode->i_version = ++event;	/* increment inode version */
+#endif
+	inode->i_op = &mini_fo_main_iops;
+	inode->i_fop = &mini_fo_main_fops;
+#if 0
+	/*
+	 * XXX: To export a file system via NFS, it has to have the
+	 * FS_REQUIRES_DEV flag, so turn it on.  But should we inherit it from
+	 * the lower file system, or can we allow our file system to be exported
+	 * even if the lower one cannot be natively exported.
+	 */
+	inode->i_sb->s_type->fs_flags |= FS_REQUIRES_DEV;
+	/*
+	 * OK, the above was a hack, which is now turned off because it may
+	 * cause a panic/oops on some systems.  The correct way to export a
+	 * "nodev" filesystem is via using nfs-utils > 1.0 and the "fsid=" export
+	 * parameter, which requires 2.4.20 or later.
+	 */
+#endif
+	/* I don't think ->a_ops is ever allowed to be NULL */
+	inode->i_mapping->a_ops = &mini_fo_empty_aops;
+}
+
+
+#if defined(FIST_DEBUG) || defined(FIST_FILTER_SCA)
+/*
+ * No need to call write_inode() on the lower inode, as it
+ * will have been marked 'dirty' anyway. But we might need
+ * to write some of our own stuff to disk.
+ */
+STATIC void
+mini_fo_write_inode(inode_t *inode, int sync)
+{
+	print_entry_location();
+	print_exit_location();
+}
+#endif /* defined(FIST_DEBUG) || defined(FIST_FILTER_SCA) */
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26)
+STATIC void
+mini_fo_put_inode(inode_t *inode)
+{
+	/*
+	 * This is really funky stuff:
+	 * Basically, if i_count == 1, iput will then decrement it and this inode will be destroyed.
+	 * It is currently holding a reference to the hidden inode.
+	 * Therefore, it needs to release that reference by calling iput on the hidden inode.
+	 * iput() _will_ do it for us (by calling our clear_inode), but _only_ if i_nlink == 0.
+	 * The problem is, NFS keeps i_nlink == 1 for silly_rename'd files.
+	 * So we must for our i_nlink to 0 here to trick iput() into calling our clear_inode.
+	 */
+	if (atomic_read(&inode->i_count) == 1)
+		inode->i_nlink = 0;
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26) */
+
+
+#if defined(FIST_DEBUG) || defined(FIST_FILTER_SCA)
+/*
+ * we now define delete_inode, because there are two VFS paths that may
+ * destroy an inode: one of them calls clear inode before doing everything
+ * else that's needed, and the other is fine.  This way we truncate the inode
+ * size (and its pages) and then clear our own inode, which will do an iput
+ * on our and the lower inode.
+ */
+STATIC void
+mini_fo_delete_inode(inode_t *inode)
+{
+	print_entry_location();
+
+	fist_checkinode(inode, "mini_fo_delete_inode IN");
+	inode->i_size = 0;		/* every f/s seems to do that */
+	clear_inode(inode);
+
+	print_exit_location();
+}
+#endif /* defined(FIST_DEBUG) || defined(FIST_FILTER_SCA) */
+
+
+/* final actions when unmounting a file system */
+STATIC void
+mini_fo_put_super(super_block_t *sb)
+{
+	if (stopd(sb)) {
+		mntput(stopd(sb)->hidden_mnt);
+		mntput(stopd(sb)->hidden_mnt2);
+
+		/* mk: no! dput(stopd(sb)->base_dir_dentry);
+		   dput(stopd(sb)->storage_dir_dentry); */
+
+		kfree(stopd(sb));
+		__stopd(sb) = NULL;
+	}
+}
+
+
+#ifdef NOT_NEEDED
+/*
+ * This is called in do_umount before put_super.
+ * The superblock lock is not held yet.
+ * We probably do not need to define this or call write_super
+ * on the hidden_sb, because sync_supers() will get to hidden_sb
+ * sooner or later.  But it is also called from file_fsync()...
+ */
+STATIC void
+mini_fo_write_super(super_block_t *sb)
+{
+	return;
+}
+#endif /* NOT_NEEDED */
+
+
+STATIC int
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+mini_fo_statfs(struct dentry *d, struct kstatfs *buf)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+mini_fo_statfs(super_block_t *sb, struct kstatfs *buf)
+#else
+mini_fo_statfs(super_block_t *sb, struct statfs *buf)
+#endif
+{
+	int err = 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+	struct dentry *hidden_d;
+
+	hidden_d = dtohd(d);
+	err = vfs_statfs(hidden_d, buf);
+#else
+	super_block_t *hidden_sb;
+
+	hidden_sb = stohs(sb);
+	err = vfs_statfs(hidden_sb, buf);
+#endif
+
+	return err;
+}
+
+
+/*
+ * XXX: not implemented.  This is not allowed yet.
+ * Should we call this on the hidden_sb?  Probably not.
+ */
+STATIC int
+mini_fo_remount_fs(super_block_t *sb, int *flags, char *data)
+{
+	//printk(KERN_CRIT "mini_fo_remount_fs: WARNING, this function is umimplemented.\n");
+	return -ENOSYS;
+}
+
+
+/*
+ * Called by iput() when the inode reference count reached zero
+ * and the inode is not hashed anywhere.  Used to clear anything
+ * that needs to be, before the inode is completely destroyed and put
+ * on the inode free list.
+ */
+STATIC void
+mini_fo_clear_inode(inode_t *inode)
+{
+	/*
+	 * Decrement a reference to a hidden_inode, which was incremented
+	 * by our read_inode when it was created initially.
+	 */
+
+	/* release the wol_list */
+	if(S_ISDIR(inode->i_mode)) {
+		__meta_put_lists(inode);
+	}
+
+	/* mk: fan out fun */
+	if(itohi(inode))
+		iput(itohi(inode));
+	if(itohi2(inode))
+		iput(itohi2(inode));
+
+	// XXX: why this assertion fails?
+	// because it doesn't like us
+	// ASSERT((inode->i_state & I_DIRTY) == 0);
+	kfree(itopd(inode));
+	__itopd(inode) = NULL;
+}
+
+
+/*
+ * Called in do_umount() if the MNT_FORCE flag was used and this
+ * function is defined.  See comment in linux/fs/super.c:do_umount().
+ * Used only in nfs, to kill any pending RPC tasks, so that subsequent
+ * code can actually succeed and won't leave tasks that need handling.
+ *
+ * PS. I wonder if this is somehow useful to undo damage that was
+ * left in the kernel after a user level file server (such as amd)
+ * dies.
+ */
+STATIC void
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+mini_fo_umount_begin(struct vfsmount *mnt, int flags)
+{
+	struct vfsmount *hidden_mnt;
+
+	hidden_mnt = stopd(mnt->mnt_sb)->hidden_mnt;
+
+	if (hidden_mnt->mnt_sb->s_op->umount_begin)
+		hidden_mnt->mnt_sb->s_op->umount_begin(hidden_mnt, flags);
+
+}
+#else
+mini_fo_umount_begin(super_block_t *sb)
+{
+	super_block_t *hidden_sb;
+
+	hidden_sb = stohs(sb);
+
+	if (hidden_sb->s_op->umount_begin)
+		hidden_sb->s_op->umount_begin(hidden_sb);
+
+}
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
+struct inode *
+mini_fo_iget(struct super_block *sb, unsigned long ino)
+{
+	struct inode *inode;
+
+	inode = iget_locked(sb, ino);
+	if (!inode)
+		return ERR_PTR(-ENOMEM);
+
+	if (!(inode->i_state & I_NEW))
+		return inode;
+
+	mini_fo_read_inode(inode);
+
+	unlock_new_inode(inode);
+	return inode;
+}
+#endif /* if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25) */
+
+struct super_operations mini_fo_sops =
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25)
+	read_inode:		mini_fo_read_inode,
+#endif
+#if defined(FIST_DEBUG) || defined(FIST_FILTER_SCA)
+	write_inode:	mini_fo_write_inode,
+#endif /* defined(FIST_DEBUG) || defined(FIST_FILTER_SCA) */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26)
+	put_inode:		mini_fo_put_inode,
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26) */
+#if defined(FIST_DEBUG) || defined(FIST_FILTER_SCA)
+	delete_inode:	mini_fo_delete_inode,
+#endif /* defined(FIST_DEBUG) || defined(FIST_FILTER_SCA) */
+	put_super:		mini_fo_put_super,
+	statfs:		mini_fo_statfs,
+	remount_fs:		mini_fo_remount_fs,
+	clear_inode:	mini_fo_clear_inode,
+	umount_begin:	mini_fo_umount_begin,
+};
diff -Nru linux-2.6.30.5/fs/squashfs/Kconfig linux-2.6.30.5-wrt/fs/squashfs/Kconfig
--- linux-2.6.30.5/fs/squashfs/Kconfig	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/fs/squashfs/Kconfig	2009-09-06 18:43:48.342667486 +0200
@@ -1,7 +1,7 @@
 config SQUASHFS
 	tristate "SquashFS 4.0 - Squashed file system support"
 	depends on BLOCK
-	select ZLIB_INFLATE
+	select CRYPTO
 	help
 	  Saying Y here includes support for SquashFS 4.0 (a Compressed
 	  Read-Only File System).  Squashfs is a highly compressed read-only
@@ -36,6 +36,26 @@
 
 	  If unsure, say N.
 
+config SQUASHFS_SUPPORT_ZLIB
+	bool
+	prompt "Support ZLIB compression" if SQUASHFS_SUPPORT_LZMA
+	depends on SQUASHFS
+	select CRYPTO_ZLIB
+	default y
+	help
+	  ZLIB is the default compression used in squashfs. If you are
+	  using LZMA compression instead, you can remove support for ZLIB
+	  entirely.
+
+config SQUASHFS_SUPPORT_LZMA
+	bool "Support LZMA compression"
+	depends on SQUASHFS
+	select CRYPTO_UNLZMA
+	help
+	  By default SquashFS uses ZLIB compression, however (if your tools
+	  support it, you can use LZMA instead, which saves space.
+
+
 config SQUASHFS_FRAGMENT_CACHE_SIZE
 	int "Number of fragments cached" if SQUASHFS_EMBEDDED
 	depends on SQUASHFS
diff -Nru linux-2.6.30.5/fs/squashfs/block.c linux-2.6.30.5-wrt/fs/squashfs/block.c
--- linux-2.6.30.5/fs/squashfs/block.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/fs/squashfs/block.c	2009-09-06 18:43:48.338666730 +0200
@@ -32,7 +32,8 @@
 #include <linux/mutex.h>
 #include <linux/string.h>
 #include <linux/buffer_head.h>
-#include <linux/zlib.h>
+
+#include <crypto/compress.h>
 
 #include "squashfs_fs.h"
 #include "squashfs_fs_sb.h"
@@ -153,7 +154,8 @@
 	}
 
 	if (compressed) {
-		int zlib_err = 0, zlib_init = 0;
+		int res = 0, decomp_init = 0;
+		struct comp_request req;
 
 		/*
 		 * Uncompress block.
@@ -161,12 +163,13 @@
 
 		mutex_lock(&msblk->read_data_mutex);
 
-		msblk->stream.avail_out = 0;
-		msblk->stream.avail_in = 0;
+		req.avail_out = 0;
+		req.avail_in = 0;
 
 		bytes = length;
+		length = 0;
 		do {
-			if (msblk->stream.avail_in == 0 && k < b) {
+			if (req.avail_in == 0 && k < b) {
 				avail = min(bytes, msblk->devblksize - offset);
 				bytes -= avail;
 				wait_on_buffer(bh[k]);
@@ -179,45 +182,47 @@
 					continue;
 				}
 
-				msblk->stream.next_in = bh[k]->b_data + offset;
-				msblk->stream.avail_in = avail;
+				req.next_in = bh[k]->b_data + offset;
+				req.avail_in = avail;
 				offset = 0;
 			}
 
-			if (msblk->stream.avail_out == 0 && page < pages) {
-				msblk->stream.next_out = buffer[page++];
-				msblk->stream.avail_out = PAGE_CACHE_SIZE;
+			if (req.avail_out == 0 && page < pages) {
+				req.next_out = buffer[page++];
+				req.avail_out = PAGE_CACHE_SIZE;
 			}
 
-			if (!zlib_init) {
-				zlib_err = zlib_inflateInit(&msblk->stream);
-				if (zlib_err != Z_OK) {
-					ERROR("zlib_inflateInit returned"
-						" unexpected result 0x%x,"
-						" srclength %d\n", zlib_err,
-						srclength);
+			if (!decomp_init) {
+				res = crypto_decompress_init(msblk->tfm);
+				if (res) {
+					ERROR("crypto_decompress_init "
+						"returned %d, srclength %d\n",
+						res, srclength);
 					goto release_mutex;
 				}
-				zlib_init = 1;
+				decomp_init = 1;
 			}
 
-			zlib_err = zlib_inflate(&msblk->stream, Z_SYNC_FLUSH);
+			res = crypto_decompress_update(msblk->tfm, &req);
+			if (res < 0) {
+				ERROR("crypto_decompress_update returned %d, "
+					"data probably corrupt\n", res);
+				goto release_mutex;
+			}
+			length += res;
 
-			if (msblk->stream.avail_in == 0 && k < b)
+			if (req.avail_in == 0 && k < b)
 				put_bh(bh[k++]);
-		} while (zlib_err == Z_OK);
+		} while (bytes || res);
 
-		if (zlib_err != Z_STREAM_END) {
-			ERROR("zlib_inflate error, data probably corrupt\n");
+		res = crypto_decompress_final(msblk->tfm, &req);
+		if (res < 0) {
+			ERROR("crypto_decompress_final returned %d, data "
+				"probably corrupt\n", res);
 			goto release_mutex;
 		}
+		length += res;
 
-		zlib_err = zlib_inflateEnd(&msblk->stream);
-		if (zlib_err != Z_OK) {
-			ERROR("zlib_inflate error, data probably corrupt\n");
-			goto release_mutex;
-		}
-		length = msblk->stream.total_out;
 		mutex_unlock(&msblk->read_data_mutex);
 	} else {
 		/*
diff -Nru linux-2.6.30.5/fs/squashfs/squashfs_fs.h linux-2.6.30.5-wrt/fs/squashfs/squashfs_fs.h
--- linux-2.6.30.5/fs/squashfs/squashfs_fs.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/fs/squashfs/squashfs_fs.h	2009-09-06 18:43:48.342667486 +0200
@@ -212,6 +212,7 @@
  * definitions for structures on disk
  */
 #define ZLIB_COMPRESSION	 1
+#define LZMA_COMPRESSION	 2
 
 struct squashfs_super_block {
 	__le32			s_magic;
diff -Nru linux-2.6.30.5/fs/squashfs/squashfs_fs_sb.h linux-2.6.30.5-wrt/fs/squashfs/squashfs_fs_sb.h
--- linux-2.6.30.5/fs/squashfs/squashfs_fs_sb.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/fs/squashfs/squashfs_fs_sb.h	2009-09-06 18:43:48.338666730 +0200
@@ -64,7 +64,7 @@
 	struct mutex		read_data_mutex;
 	struct mutex		meta_index_mutex;
 	struct meta_index	*meta_index;
-	z_stream		stream;
+	struct crypto_pcomp	*tfm;
 	__le64			*inode_lookup_table;
 	u64			inode_table;
 	u64			directory_table;
diff -Nru linux-2.6.30.5/fs/squashfs/super.c linux-2.6.30.5-wrt/fs/squashfs/super.c
--- linux-2.6.30.5/fs/squashfs/super.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/fs/squashfs/super.c	2009-09-06 18:43:48.342667486 +0200
@@ -37,15 +37,86 @@
 #include <linux/zlib.h>
 #include <linux/magic.h>
 
+#include <crypto/compress.h>
+
+#include <net/netlink.h>
+
 #include "squashfs_fs.h"
 #include "squashfs_fs_sb.h"
 #include "squashfs_fs_i.h"
 #include "squashfs.h"
 
+
+static int squashfs_setup_zlib(struct squashfs_sb_info *msblk)
+{
+	int err = -EOPNOTSUPP;
+
+#ifdef CONFIG_SQUASHFS_SUPPORT_ZLIB
+	struct {
+		struct nlattr nla;
+		int val;
+	} params = {
+		.nla = {
+			.nla_len	= nla_attr_size(sizeof(int)),
+			.nla_type	= ZLIB_DECOMP_WINDOWBITS,
+		},
+		.val			= DEF_WBITS,
+	};
+
+	msblk->tfm = crypto_alloc_pcomp("zlib", 0,
+					CRYPTO_ALG_ASYNC);
+	if (IS_ERR(msblk->tfm)) {
+		ERROR("Failed to load zlib crypto module\n");
+		return PTR_ERR(msblk->tfm);
+	}
+
+	err = crypto_decompress_setup(msblk->tfm, &params, sizeof(params));
+	if (err) {
+		ERROR("Failed to set up decompression parameters\n");
+		crypto_free_pcomp(msblk->tfm);
+	}
+#endif
+
+	return err;
+}
+
+static int squashfs_setup_lzma(struct squashfs_sb_info *msblk)
+{
+	int err = -EOPNOTSUPP;
+
+#ifdef CONFIG_SQUASHFS_SUPPORT_LZMA
+	struct {
+		struct nlattr nla;
+		int val;
+	} params = {
+		.nla = {
+			.nla_len	= nla_attr_size(sizeof(int)),
+			.nla_type	= UNLZMA_DECOMP_OUT_BUFFERS,
+		},
+		.val = (msblk->block_size / PAGE_CACHE_SIZE) + 1
+	};
+
+	msblk->tfm = crypto_alloc_pcomp("lzma", 0,
+					CRYPTO_ALG_ASYNC);
+	if (IS_ERR(msblk->tfm)) {
+		ERROR("Failed to load lzma crypto module\n");
+		return PTR_ERR(msblk->tfm);
+	}
+
+	err = crypto_decompress_setup(msblk->tfm, &params, sizeof(params));
+	if (err) {
+		ERROR("Failed to set up decompression parameters\n");
+		crypto_free_pcomp(msblk->tfm);
+	}
+#endif
+
+	return err;
+}
+
 static struct file_system_type squashfs_fs_type;
 static struct super_operations squashfs_super_ops;
 
-static int supported_squashfs_filesystem(short major, short minor, short comp)
+static int supported_squashfs_filesystem(short major, short minor)
 {
 	if (major < SQUASHFS_MAJOR) {
 		ERROR("Major/Minor mismatch, older Squashfs %d.%d "
@@ -58,9 +129,6 @@
 		return -EINVAL;
 	}
 
-	if (comp != ZLIB_COMPRESSION)
-		return -EINVAL;
-
 	return 0;
 }
 
@@ -86,16 +154,10 @@
 	}
 	msblk = sb->s_fs_info;
 
-	msblk->stream.workspace = kmalloc(zlib_inflate_workspacesize(),
-		GFP_KERNEL);
-	if (msblk->stream.workspace == NULL) {
-		ERROR("Failed to allocate zlib workspace\n");
-		goto failure;
-	}
-
 	sblk = kzalloc(sizeof(*sblk), GFP_KERNEL);
 	if (sblk == NULL) {
 		ERROR("Failed to allocate squashfs_super_block\n");
+		err = -ENOMEM;
 		goto failure;
 	}
 
@@ -129,10 +191,28 @@
 		goto failed_mount;
 	}
 
+	/* Check block size for sanity */
+	msblk->block_size = le32_to_cpu(sblk->block_size);
+	if (msblk->block_size > SQUASHFS_FILE_MAX_SIZE)
+		goto failed_mount;
+
 	/* Check the MAJOR & MINOR versions and compression type */
 	err = supported_squashfs_filesystem(le16_to_cpu(sblk->s_major),
-			le16_to_cpu(sblk->s_minor),
-			le16_to_cpu(sblk->compression));
+			le16_to_cpu(sblk->s_minor));
+	if (err < 0)
+		goto failed_mount;
+
+	switch(le16_to_cpu(sblk->compression)) {
+	case ZLIB_COMPRESSION:
+		err = squashfs_setup_zlib(msblk);
+		break;
+	case LZMA_COMPRESSION:
+		err = squashfs_setup_lzma(msblk);
+		break;
+	default:
+		err = -EINVAL;
+		break;
+	}
 	if (err < 0)
 		goto failed_mount;
 
@@ -152,11 +232,6 @@
 			i_size_read(sb->s_bdev->bd_inode))
 		goto failed_mount;
 
-	/* Check block size for sanity */
-	msblk->block_size = le32_to_cpu(sblk->block_size);
-	if (msblk->block_size > SQUASHFS_FILE_MAX_SIZE)
-		goto failed_mount;
-
 	/*
 	 * Check the system page size is not larger than the filesystem
 	 * block size (by default 128K).  This is currently not supported.
@@ -288,23 +363,19 @@
 	return 0;
 
 failed_mount:
+	if (msblk->tfm)
+		crypto_free_pcomp(msblk->tfm);
 	squashfs_cache_delete(msblk->block_cache);
 	squashfs_cache_delete(msblk->fragment_cache);
 	squashfs_cache_delete(msblk->read_page);
 	kfree(msblk->inode_lookup_table);
 	kfree(msblk->fragment_index);
 	kfree(msblk->id_table);
-	kfree(msblk->stream.workspace);
-	kfree(sb->s_fs_info);
-	sb->s_fs_info = NULL;
 	kfree(sblk);
-	return err;
-
 failure:
-	kfree(msblk->stream.workspace);
 	kfree(sb->s_fs_info);
 	sb->s_fs_info = NULL;
-	return -ENOMEM;
+	return err;
 }
 
 
@@ -346,7 +417,7 @@
 		kfree(sbi->id_table);
 		kfree(sbi->fragment_index);
 		kfree(sbi->meta_index);
-		kfree(sbi->stream.workspace);
+		crypto_free_pcomp(sbi->tfm);
 		kfree(sb->s_fs_info);
 		sb->s_fs_info = NULL;
 	}
diff -Nru linux-2.6.30.5/include/asm-generic/vmlinux.lds.h linux-2.6.30.5-wrt/include/asm-generic/vmlinux.lds.h
--- linux-2.6.30.5/include/asm-generic/vmlinux.lds.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/include/asm-generic/vmlinux.lds.h	2009-09-06 18:43:48.334667043 +0200
@@ -4,6 +4,27 @@
 #define LOAD_OFFSET 0
 #endif
 
+#ifndef SYMTAB_KEEP_STR
+#define SYMTAB_KEEP_STR *(__ksymtab_strings.*)
+#define SYMTAB_DISCARD_STR
+#else
+#define SYMTAB_DISCARD_STR *(__ksymtab_strings.*)
+#endif
+
+#ifndef SYMTAB_KEEP
+#define SYMTAB_KEEP *(__ksymtab.*)
+#define SYMTAB_DISCARD
+#else
+#define SYMTAB_DISCARD *(__ksymtab.*)
+#endif
+
+#ifndef SYMTAB_KEEP_GPL
+#define SYMTAB_KEEP_GPL *(__ksymtab_gpl.*)
+#define SYMTAB_DISCARD_GPL
+#else
+#define SYMTAB_DISCARD_GPL *(__ksymtab_gpl.*)
+#endif
+
 #ifndef VMLINUX_SYMBOL
 #define VMLINUX_SYMBOL(_sym_) _sym_
 #endif
@@ -176,35 +197,35 @@
 	/* Kernel symbol table: Normal symbols */			\
 	__ksymtab         : AT(ADDR(__ksymtab) - LOAD_OFFSET) {		\
 		VMLINUX_SYMBOL(__start___ksymtab) = .;			\
-		*(__ksymtab)						\
+		SYMTAB_KEEP						\
 		VMLINUX_SYMBOL(__stop___ksymtab) = .;			\
 	}								\
 									\
 	/* Kernel symbol table: GPL-only symbols */			\
 	__ksymtab_gpl     : AT(ADDR(__ksymtab_gpl) - LOAD_OFFSET) {	\
 		VMLINUX_SYMBOL(__start___ksymtab_gpl) = .;		\
-		*(__ksymtab_gpl)					\
+		SYMTAB_KEEP_GPL						\
 		VMLINUX_SYMBOL(__stop___ksymtab_gpl) = .;		\
 	}								\
 									\
 	/* Kernel symbol table: Normal unused symbols */		\
 	__ksymtab_unused  : AT(ADDR(__ksymtab_unused) - LOAD_OFFSET) {	\
 		VMLINUX_SYMBOL(__start___ksymtab_unused) = .;		\
-		*(__ksymtab_unused)					\
+		*(__ksymtab_unused.*)					\
 		VMLINUX_SYMBOL(__stop___ksymtab_unused) = .;		\
 	}								\
 									\
 	/* Kernel symbol table: GPL-only unused symbols */		\
 	__ksymtab_unused_gpl : AT(ADDR(__ksymtab_unused_gpl) - LOAD_OFFSET) { \
 		VMLINUX_SYMBOL(__start___ksymtab_unused_gpl) = .;	\
-		*(__ksymtab_unused_gpl)					\
+		*(__ksymtab_unused_gpl.*)				\
 		VMLINUX_SYMBOL(__stop___ksymtab_unused_gpl) = .;	\
 	}								\
 									\
 	/* Kernel symbol table: GPL-future-only symbols */		\
 	__ksymtab_gpl_future : AT(ADDR(__ksymtab_gpl_future) - LOAD_OFFSET) { \
 		VMLINUX_SYMBOL(__start___ksymtab_gpl_future) = .;	\
-		*(__ksymtab_gpl_future)					\
+		*(__ksymtab_gpl_future.*)				\
 		VMLINUX_SYMBOL(__stop___ksymtab_gpl_future) = .;	\
 	}								\
 									\
@@ -245,7 +266,13 @@
 									\
 	/* Kernel symbol table: strings */				\
         __ksymtab_strings : AT(ADDR(__ksymtab_strings) - LOAD_OFFSET) {	\
-		*(__ksymtab_strings)					\
+		SYMTAB_KEEP_STR						\
+	}								\
+									\
+	/DISCARD/ : {							\
+		SYMTAB_DISCARD						\
+		SYMTAB_DISCARD_GPL					\
+		SYMTAB_DISCARD_STR					\
 	}								\
 									\
 	/* __*init sections */						\
diff -Nru linux-2.6.30.5/include/asm-mips/mips_machine.h linux-2.6.30.5-wrt/include/asm-mips/mips_machine.h
--- linux-2.6.30.5/include/asm-mips/mips_machine.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/include/asm-mips/mips_machine.h	2009-09-06 18:43:48.322739724 +0200
@@ -0,0 +1,46 @@
+/*
+ *  Copyright (C) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ */
+
+#ifndef __ASM_MIPS_MACHINE_H
+#define __ASM_MIPS_MACHINE_H
+
+#include <linux/init.h>
+#include <linux/list.h>
+
+struct mips_machine {
+	unsigned long		mach_type;
+	void			(*mach_setup)(void);
+	char			*mach_name;
+	struct list_head	list;
+};
+
+void mips_machine_register(struct mips_machine *) __init;
+void mips_machine_setup(unsigned long machtype) __init;
+
+extern char *mips_machine_name;
+
+#define MIPS_MACHINE(_type, _name, _setup) 			\
+static char machine_name_##_type[] __initdata = _name;		\
+static struct mips_machine machine_##_type __initdata =		\
+{								\
+	.mach_type	= _type,				\
+	.mach_name	= machine_name_##_type,			\
+	.mach_setup	= _setup,				\
+};								\
+								\
+static int __init register_machine_##_type(void)		\
+{								\
+	mips_machine_register(&machine_##_type);		\
+	return 0;						\
+}								\
+								\
+pure_initcall(register_machine_##_type)
+
+#endif /* __ASM_MIPS_MACHINE_H */
+
diff -Nru linux-2.6.30.5/include/asm-powerpc/segment.h linux-2.6.30.5-wrt/include/asm-powerpc/segment.h
--- linux-2.6.30.5/include/asm-powerpc/segment.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/include/asm-powerpc/segment.h	2009-09-06 18:43:48.410667457 +0200
@@ -0,0 +1,6 @@
+#ifndef _ASM_SEGMENT_H
+#define _ASM_SEGMENT_H
+
+/* Only here because we have some old header files that expect it.. */
+
+#endif /* _ASM_SEGMENT_H */
diff -Nru linux-2.6.30.5/include/crypto/compress.h linux-2.6.30.5-wrt/include/crypto/compress.h
--- linux-2.6.30.5/include/crypto/compress.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/include/crypto/compress.h	2009-09-06 18:43:48.342667486 +0200
@@ -49,6 +49,12 @@
 
 #define ZLIB_DECOMP_MAX	(__ZLIB_DECOMP_MAX - 1)
 
+enum unlzma_decomp_params {
+	UNLZMA_DECOMP_OUT_BUFFERS = 1, /* naximum number of output buffers */
+	__UNLZMA_DECOMP_MAX,
+};
+#define UNLZMA_DECOMP_MAX	(__UNLZMA_DECOMP_MAX - 1)
+
 
 struct crypto_pcomp {
 	struct crypto_tfm base;
diff -Nru linux-2.6.30.5/include/linux/Kbuild linux-2.6.30.5-wrt/include/linux/Kbuild
--- linux-2.6.30.5/include/linux/Kbuild	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/include/linux/Kbuild	2009-09-06 18:44:06.791167574 +0200
@@ -75,6 +75,8 @@
 header-y += gen_stats.h
 header-y += gfs2_ondisk.h
 header-y += gigaset_dev.h
+header-y += glamofb.h
+header-y += glamo-engine.h
 header-y += hysdn_if.h
 header-y += i2o-dev.h
 header-y += i8k.h
diff -Nru linux-2.6.30.5/include/linux/fb.h linux-2.6.30.5-wrt/include/linux/fb.h
--- linux-2.6.30.5/include/linux/fb.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/include/linux/fb.h	2009-09-06 18:44:06.791167574 +0200
@@ -124,6 +124,7 @@
 #define FB_ACCEL_TRIDENT_BLADE3D 52	/* Trident Blade3D		*/
 #define FB_ACCEL_TRIDENT_BLADEXP 53	/* Trident BladeXP		*/
 #define FB_ACCEL_CIRRUS_ALPINE   53	/* Cirrus Logic 543x/544x/5480	*/
+#define FB_ACCEL_GLAMO		50	/* SMedia Glamo                 */
 #define FB_ACCEL_NEOMAGIC_NM2070 90	/* NeoMagic NM2070              */
 #define FB_ACCEL_NEOMAGIC_NM2090 91	/* NeoMagic NM2090              */
 #define FB_ACCEL_NEOMAGIC_NM2093 92	/* NeoMagic NM2093              */
diff -Nru linux-2.6.30.5/include/linux/glamo-engine.h linux-2.6.30.5-wrt/include/linux/glamo-engine.h
--- linux-2.6.30.5/include/linux/glamo-engine.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/include/linux/glamo-engine.h	2009-09-06 18:43:20.906698817 +0200
@@ -0,0 +1,27 @@
+#ifndef __GLAMO_ENGINE_H
+#define __GLAMO_ENGINE_H
+
+enum glamo_engine {
+	GLAMO_ENGINE_CAPTURE = 0,
+	GLAMO_ENGINE_ISP = 1,
+	GLAMO_ENGINE_JPEG = 2,
+	GLAMO_ENGINE_MPEG_ENC = 3,
+	GLAMO_ENGINE_MPEG_DEC = 4,
+	GLAMO_ENGINE_LCD = 5,
+	GLAMO_ENGINE_CMDQ = 6,
+	GLAMO_ENGINE_2D = 7,
+	GLAMO_ENGINE_3D = 8,
+	GLAMO_ENGINE_MMC = 9,
+	GLAMO_ENGINE_MICROP0 = 10,
+	GLAMO_ENGINE_RISC = 11,
+	GLAMO_ENGINE_MICROP1_MPEG_ENC = 12,
+	GLAMO_ENGINE_MICROP1_MPEG_DEC = 13,
+#if 0
+	GLAMO_ENGINE_H264_DEC = 14,
+	GLAMO_ENGINE_RISC1 = 15,
+	GLAMO_ENGINE_SPI = 16,
+#endif
+	__NUM_GLAMO_ENGINES
+};
+
+#endif
diff -Nru linux-2.6.30.5/include/linux/glamofb.h linux-2.6.30.5-wrt/include/linux/glamofb.h
--- linux-2.6.30.5/include/linux/glamofb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/include/linux/glamofb.h	2009-09-06 18:43:20.910688744 +0200
@@ -0,0 +1,35 @@
+#ifndef _LINUX_GLAMOFB_H
+#define _LINUX_GLAMOFB_H
+
+#include <linux/fb.h>
+
+#ifdef __KERNEL__
+
+struct glamo_core;
+struct glamofb_handle;
+
+struct glamo_fb_platform_data {
+    int width, height;
+
+    int num_modes;
+    struct fb_videomode *modes;
+
+    struct glamo_core *core;
+};
+
+int glamofb_cmd_mode(struct glamofb_handle *gfb, int on);
+int glamofb_cmd_write(struct glamofb_handle *gfb, u_int16_t val);
+
+#ifdef CONFIG_MFD_GLAMO
+void glamo_lcm_reset(struct platform_device *pdev, int level);
+#else
+#define glamo_lcm_reset(...) do {} while (0)
+#endif
+
+#endif
+
+#define GLAMOFB_ENGINE_ENABLE _IOW('F', 0x1, __u32)
+#define GLAMOFB_ENGINE_DISABLE _IOW('F', 0x2, __u32)
+#define GLAMOFB_ENGINE_RESET _IOW('F', 0x3, __u32)
+
+#endif
diff -Nru linux-2.6.30.5/include/linux/gpio_buttons.h linux-2.6.30.5-wrt/include/linux/gpio_buttons.h
--- linux-2.6.30.5/include/linux/gpio_buttons.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/include/linux/gpio_buttons.h	2009-09-06 18:43:20.906698817 +0200
@@ -0,0 +1,35 @@
+/*
+ *  Definitions for the GPIO buttons interface driver
+ *
+ *  Copyright (C) 2007,2008 Gabor Juhos <juhosg at openwrt.org>
+ *
+ *  This file was based on: /include/linux/gpio_keys.h
+ *	The original gpio_keys.h seems not to have a license.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ */
+
+#ifndef _GPIO_BUTTONS_H_
+#define _GPIO_BUTTONS_H_
+
+struct gpio_button {
+	int	gpio;		/* GPIO line number */
+	int	active_low;
+	char	*desc;		/* button description */
+	int	type;		/* input event type (EV_KEY, EV_SW) */
+	int	code;		/* input event code (KEY_*, SW_*) */
+	int	count;
+	int	threshold;	/* count threshold */
+};
+
+struct gpio_buttons_platform_data {
+	struct gpio_button *buttons;
+	int	nbuttons;		/* number of buttons */
+	int	poll_interval;		/* polling interval */
+};
+
+#endif /* _GPIO_BUTTONS_H_ */
+
diff -Nru linux-2.6.30.5/include/linux/gpio_dev.h linux-2.6.30.5-wrt/include/linux/gpio_dev.h
--- linux-2.6.30.5/include/linux/gpio_dev.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/include/linux/gpio_dev.h	2009-09-06 18:43:20.906698817 +0200
@@ -0,0 +1,11 @@
+#ifndef _GPIODEV_H__
+#define _GPIODEV_H__
+
+#define IOC_GPIODEV_MAGIC  'B'
+#define GPIO_GET        _IO(IOC_GPIODEV_MAGIC, 10)
+#define GPIO_SET        _IO(IOC_GPIODEV_MAGIC, 11)
+#define GPIO_CLEAR      _IO(IOC_GPIODEV_MAGIC, 12)
+#define GPIO_DIR_IN     _IO(IOC_GPIODEV_MAGIC, 13)
+#define GPIO_DIR_OUT    _IO(IOC_GPIODEV_MAGIC, 14)
+
+#endif
diff -Nru linux-2.6.30.5/include/linux/if_packet.h linux-2.6.30.5-wrt/include/linux/if_packet.h
--- linux-2.6.30.5/include/linux/if_packet.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/include/linux/if_packet.h	2009-09-06 18:43:48.438677047 +0200
@@ -31,6 +31,8 @@
 /* These ones are invisible by user level */
 #define PACKET_LOOPBACK		5		/* MC/BRD frame looped back */
 #define PACKET_FASTROUTE	6		/* Fastrouted frame	*/
+#define PACKET_MASK_ANY		0xffffffff	/* mask for packet type bits */
+
 
 /* Packet socket options */
 
@@ -46,6 +48,7 @@
 #define PACKET_VERSION			10
 #define PACKET_HDRLEN			11
 #define PACKET_RESERVE			12
+#define PACKET_RECV_TYPE		13
 
 struct tpacket_stats
 {
diff -Nru linux-2.6.30.5/include/linux/imq.h linux-2.6.30.5-wrt/include/linux/imq.h
--- linux-2.6.30.5/include/linux/imq.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/include/linux/imq.h	2009-09-06 18:43:48.382672077 +0200
@@ -0,0 +1,13 @@
+#ifndef _IMQ_H
+#define _IMQ_H
+
+/* IFMASK (16 device indexes, 0 to 15) and flag(s) fit in 5 bits */
+#define IMQ_F_BITS	5
+
+#define IMQ_F_IFMASK	0x0f
+#define IMQ_F_ENQUEUE	0x10
+
+#define IMQ_MAX_DEVS	(IMQ_F_IFMASK + 1)
+
+#endif /* _IMQ_H */
+
diff -Nru linux-2.6.30.5/include/linux/jhash.h linux-2.6.30.5-wrt/include/linux/jhash.h
--- linux-2.6.30.5/include/linux/jhash.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/include/linux/jhash.h	2009-09-06 18:43:48.402669044 +0200
@@ -3,80 +3,95 @@
 
 /* jhash.h: Jenkins hash support.
  *
- * Copyright (C) 1996 Bob Jenkins (bob_jenkins@burtleburtle.net)
+ * Copyright (C) 2006. Bob Jenkins (bob_jenkins@burtleburtle.net)
  *
  * http://burtleburtle.net/bob/hash/
  *
  * These are the credits from Bob's sources:
  *
- * lookup2.c, by Bob Jenkins, December 1996, Public Domain.
- * hash(), hash2(), hash3, and mix() are externally useful functions.
- * Routines to test the hash are included if SELF_TEST is defined.
- * You can use this free for any purpose.  It has no warranty.
+ * lookup3.c, by Bob Jenkins, May 2006, Public Domain.
  *
- * Copyright (C) 2003 David S. Miller (davem@redhat.com)
+ * These are functions for producing 32-bit hashes for hash table lookup.
+ * hashword(), hashlittle(), hashlittle2(), hashbig(), mix(), and final() 
+ * are externally useful functions.  Routines to test the hash are included 
+ * if SELF_TEST is defined.  You can use this free for any purpose.  It's in
+ * the public domain.  It has no warranty.
+ *
+ * Copyright (C) 2009 Jozsef Kadlecsik (kadlec@blackhole.kfki.hu)
  *
  * I've modified Bob's hash to be useful in the Linux kernel, and
- * any bugs present are surely my fault.  -DaveM
+ * any bugs present are my fault.  Jozsef
  */
 
-/* NOTE: Arguments are modified. */
-#define __jhash_mix(a, b, c) \
+#define __rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))
+
+/* __jhash_mix - mix 3 32-bit values reversibly. */
+#define __jhash_mix(a,b,c) \
+{ \
+  a -= c;  a ^= __rot(c, 4);  c += b; \
+  b -= a;  b ^= __rot(a, 6);  a += c; \
+  c -= b;  c ^= __rot(b, 8);  b += a; \
+  a -= c;  a ^= __rot(c,16);  c += b; \
+  b -= a;  b ^= __rot(a,19);  a += c; \
+  c -= b;  c ^= __rot(b, 4);  b += a; \
+}
+
+/* __jhash_final - final mixing of 3 32-bit values (a,b,c) into c */
+#define __jhash_final(a,b,c) \
 { \
-  a -= b; a -= c; a ^= (c>>13); \
-  b -= c; b -= a; b ^= (a<<8); \
-  c -= a; c -= b; c ^= (b>>13); \
-  a -= b; a -= c; a ^= (c>>12);  \
-  b -= c; b -= a; b ^= (a<<16); \
-  c -= a; c -= b; c ^= (b>>5); \
-  a -= b; a -= c; a ^= (c>>3);  \
-  b -= c; b -= a; b ^= (a<<10); \
-  c -= a; c -= b; c ^= (b>>15); \
+  c ^= b; c -= __rot(b,14); \
+  a ^= c; a -= __rot(c,11); \
+  b ^= a; b -= __rot(a,25); \
+  c ^= b; c -= __rot(b,16); \
+  a ^= c; a -= __rot(c,4);  \
+  b ^= a; b -= __rot(a,14); \
+  c ^= b; c -= __rot(b,24); \
 }
 
-/* The golden ration: an arbitrary value */
-#define JHASH_GOLDEN_RATIO	0x9e3779b9
+/* An arbitrary initial parameter */
+#define JHASH_GOLDEN_RATIO	0xdeadbeef
 
 /* The most generic version, hashes an arbitrary sequence
  * of bytes.  No alignment or length assumptions are made about
- * the input key.
+ * the input key. The result depends on endianness.
  */
 static inline u32 jhash(const void *key, u32 length, u32 initval)
 {
-	u32 a, b, c, len;
+	u32 a,b,c;
 	const u8 *k = key;
 
-	len = length;
-	a = b = JHASH_GOLDEN_RATIO;
-	c = initval;
-
-	while (len >= 12) {
-		a += (k[0] +((u32)k[1]<<8) +((u32)k[2]<<16) +((u32)k[3]<<24));
-		b += (k[4] +((u32)k[5]<<8) +((u32)k[6]<<16) +((u32)k[7]<<24));
-		c += (k[8] +((u32)k[9]<<8) +((u32)k[10]<<16)+((u32)k[11]<<24));
-
-		__jhash_mix(a,b,c);
+	/* Set up the internal state */
+	a = b = c = JHASH_GOLDEN_RATIO + length + initval;
 
+	/* all but the last block: affect some 32 bits of (a,b,c) */
+	while (length > 12) {
+    		a += (k[0] + ((u32)k[1]<<8) + ((u32)k[2]<<16) + ((u32)k[3]<<24));
+		b += (k[4] + ((u32)k[5]<<8) + ((u32)k[6]<<16) + ((u32)k[7]<<24));
+		c += (k[8] + ((u32)k[9]<<8) + ((u32)k[10]<<16) + ((u32)k[11]<<24));
+		__jhash_mix(a, b, c);
+		length -= 12;
 		k += 12;
-		len -= 12;
 	}
 
-	c += length;
-	switch (len) {
-	case 11: c += ((u32)k[10]<<24);
-	case 10: c += ((u32)k[9]<<16);
-	case 9 : c += ((u32)k[8]<<8);
-	case 8 : b += ((u32)k[7]<<24);
-	case 7 : b += ((u32)k[6]<<16);
-	case 6 : b += ((u32)k[5]<<8);
+	/* last block: affect all 32 bits of (c) */
+	/* all the case statements fall through */
+	switch (length) {
+	case 12: c += (u32)k[11]<<24;
+	case 11: c += (u32)k[10]<<16;
+	case 10: c += (u32)k[9]<<8;
+	case 9 : c += k[8];
+	case 8 : b += (u32)k[7]<<24;
+	case 7 : b += (u32)k[6]<<16;
+	case 6 : b += (u32)k[5]<<8;
 	case 5 : b += k[4];
-	case 4 : a += ((u32)k[3]<<24);
-	case 3 : a += ((u32)k[2]<<16);
-	case 2 : a += ((u32)k[1]<<8);
+	case 4 : a += (u32)k[3]<<24;
+	case 3 : a += (u32)k[2]<<16;
+	case 2 : a += (u32)k[1]<<8;
 	case 1 : a += k[0];
-	};
-
-	__jhash_mix(a,b,c);
+		__jhash_final(a, b, c);
+	case 0 :
+		break;
+	}
 
 	return c;
 }
@@ -86,58 +101,57 @@
  */
 static inline u32 jhash2(const u32 *k, u32 length, u32 initval)
 {
-	u32 a, b, c, len;
+	u32 a, b, c;
 
-	a = b = JHASH_GOLDEN_RATIO;
-	c = initval;
-	len = length;
+	/* Set up the internal state */
+	a = b = c = JHASH_GOLDEN_RATIO + (length<<2) + initval;
 
-	while (len >= 3) {
+	/* handle most of the key */
+	while (length > 3) {
 		a += k[0];
 		b += k[1];
 		c += k[2];
 		__jhash_mix(a, b, c);
-		k += 3; len -= 3;
+		length -= 3;
+		k += 3;
 	}
 
-	c += length * 4;
-
-	switch (len) {
-	case 2 : b += k[1];
-	case 1 : a += k[0];
-	};
-
-	__jhash_mix(a,b,c);
+	/* handle the last 3 u32's */
+	/* all the case statements fall through */ 
+	switch (length) {
+	case 3: c += k[2];
+	case 2: b += k[1];
+	case 1: a += k[0];
+		__jhash_final(a, b, c);
+	case 0:     /* case 0: nothing left to add */
+		break;
+	}
 
 	return c;
 }
 
-
 /* A special ultra-optimized versions that knows they are hashing exactly
  * 3, 2 or 1 word(s).
- *
- * NOTE: In partilar the "c += length; __jhash_mix(a,b,c);" normally
- *       done at the end is not done here.
  */
 static inline u32 jhash_3words(u32 a, u32 b, u32 c, u32 initval)
 {
-	a += JHASH_GOLDEN_RATIO;
-	b += JHASH_GOLDEN_RATIO;
-	c += initval;
+	a += JHASH_GOLDEN_RATIO + initval;
+	b += JHASH_GOLDEN_RATIO + initval;
+	c += JHASH_GOLDEN_RATIO + initval;
 
-	__jhash_mix(a, b, c);
+	__jhash_final(a, b, c);
 
 	return c;
 }
 
 static inline u32 jhash_2words(u32 a, u32 b, u32 initval)
 {
-	return jhash_3words(a, b, 0, initval);
+	return jhash_3words(0, a, b, initval);
 }
 
 static inline u32 jhash_1word(u32 a, u32 initval)
 {
-	return jhash_3words(a, 0, 0, initval);
+	return jhash_3words(0, 0, a, initval);
 }
 
 #endif /* _LINUX_JHASH_H */
diff -Nru linux-2.6.30.5/include/linux/miscdevice.h linux-2.6.30.5-wrt/include/linux/miscdevice.h
--- linux-2.6.30.5/include/linux/miscdevice.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/include/linux/miscdevice.h	2009-09-06 18:44:06.835168037 +0200
@@ -12,6 +12,7 @@
 #define APOLLO_MOUSE_MINOR	7
 #define PC110PAD_MINOR		9
 /*#define ADB_MOUSE_MINOR	10	FIXME OBSOLETE */
+#define CRYPTODEV_MINOR		70	/* /dev/crypto */
 #define WATCHDOG_MINOR		130	/* Watchdog timer     */
 #define TEMP_MINOR		131	/* Temperature Sensor */
 #define RTC_MINOR		135
diff -Nru linux-2.6.30.5/include/linux/mm.h linux-2.6.30.5-wrt/include/linux/mm.h
--- linux-2.6.30.5/include/linux/mm.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/include/linux/mm.h	2009-09-06 18:44:12.067169104 +0200
@@ -726,6 +726,7 @@
 #endif
 struct file *shmem_file_setup(char *name, loff_t size, unsigned long flags);
 
+void shmem_set_file(struct vm_area_struct *vma, struct file *file);
 int shmem_zero_setup(struct vm_area_struct *);
 
 #ifndef CONFIG_MMU
diff -Nru linux-2.6.30.5/include/linux/mmc/gpiommc.h linux-2.6.30.5-wrt/include/linux/mmc/gpiommc.h
--- linux-2.6.30.5/include/linux/mmc/gpiommc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/include/linux/mmc/gpiommc.h	2009-09-06 18:44:06.807166783 +0200
@@ -0,0 +1,71 @@
+/*
+ * Device driver for MMC/SD cards driven over a GPIO bus.
+ *
+ * Copyright (c) 2008 Michael Buesch
+ *
+ * Licensed under the GNU/GPL version 2.
+ */
+#ifndef LINUX_GPIOMMC_H_
+#define LINUX_GPIOMMC_H_
+
+#include <linux/types.h>
+
+
+#define GPIOMMC_MAX_NAMELEN		15
+#define GPIOMMC_MAX_NAMELEN_STR		__stringify(GPIOMMC_MAX_NAMELEN)
+
+/**
+ * struct gpiommc_pins - Hardware pin assignments
+ *
+ * @gpio_di: The GPIO number of the DATA IN pin
+ * @gpio_do: The GPIO number of the DATA OUT pin
+ * @gpio_clk: The GPIO number of the CLOCK pin
+ * @gpio_cs: The GPIO number of the CHIPSELECT pin
+ * @cs_activelow: If true, the chip is considered selected if @gpio_cs is low.
+ */
+struct gpiommc_pins {
+	unsigned int gpio_di;
+	unsigned int gpio_do;
+	unsigned int gpio_clk;
+	unsigned int gpio_cs;
+	bool cs_activelow;
+};
+
+/**
+ * struct gpiommc_platform_data - Platform data for a MMC-over-SPI-GPIO device.
+ *
+ * @name: The unique name string of the device.
+ * @pins: The hardware pin assignments.
+ * @mode: The hardware mode. This is either SPI_MODE_0,
+ *        SPI_MODE_1, SPI_MODE_2 or SPI_MODE_3. See the SPI documentation.
+ * @no_spi_delay: Do not use delays in the lowlevel SPI bitbanging code.
+ *                This is not standards compliant, but may be required for some
+ *                embedded machines to gain reasonable speed.
+ * @max_bus_speed: The maximum speed of the SPI bus, in Hertz.
+ */
+struct gpiommc_platform_data {
+	char name[GPIOMMC_MAX_NAMELEN + 1];
+	struct gpiommc_pins pins;
+	u8 mode;
+	bool no_spi_delay;
+	unsigned int max_bus_speed;
+};
+
+/**
+ * GPIOMMC_PLATDEV_NAME - The platform device name string.
+ *
+ * The name string that has to be used for platform_device_alloc
+ * when allocating a gpiommc device.
+ */
+#define GPIOMMC_PLATDEV_NAME	"gpiommc"
+
+/**
+ * gpiommc_next_id - Get another platform device ID number.
+ *
+ * This returns the next platform device ID number that has to be used
+ * for platform_device_alloc. The ID is opaque and should not be used for
+ * anything else.
+ */
+int gpiommc_next_id(void);
+
+#endif /* LINUX_GPIOMMC_H_ */
diff -Nru linux-2.6.30.5/include/linux/module.h linux-2.6.30.5-wrt/include/linux/module.h
--- linux-2.6.30.5/include/linux/module.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/include/linux/module.h	2009-09-06 18:43:48.334667043 +0200
@@ -187,16 +187,24 @@
 #define __CRC_SYMBOL(sym, sec)
 #endif
 
+#ifdef MODULE
+#define __EXPORT_SUFFIX(sym)
+#else
+#define __EXPORT_SUFFIX(sym) "." #sym
+#endif
+
 /* For every exported symbol, place a struct in the __ksymtab section */
 #define __EXPORT_SYMBOL(sym, sec)				\
 	extern typeof(sym) sym;					\
 	__CRC_SYMBOL(sym, sec)					\
 	static const char __kstrtab_##sym[]			\
-	__attribute__((section("__ksymtab_strings"), aligned(1))) \
+	__attribute__((section("__ksymtab_strings"		\
+	  __EXPORT_SUFFIX(sym)), aligned(1)))			\
 	= MODULE_SYMBOL_PREFIX #sym;                    	\
 	static const struct kernel_symbol __ksymtab_##sym	\
 	__used							\
-	__attribute__((section("__ksymtab" sec), unused))	\
+	__attribute__((section("__ksymtab" sec			\
+	  __EXPORT_SUFFIX(sym)), unused))			\
 	= { (unsigned long)&sym, __kstrtab_##sym }
 
 #define EXPORT_SYMBOL(sym)					\
diff -Nru linux-2.6.30.5/include/linux/mtd/mtd.h linux-2.6.30.5-wrt/include/linux/mtd/mtd.h
--- linux-2.6.30.5/include/linux/mtd/mtd.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/include/linux/mtd/mtd.h	2009-09-06 18:43:48.350677830 +0200
@@ -101,6 +101,7 @@
 	uint8_t		*oobbuf;
 };
 
+struct mtd_info;
 struct mtd_info {
 	u_char type;
 	uint32_t flags;
@@ -241,6 +242,9 @@
 	struct device dev;
 	int usecount;
 
+	int (*refresh_device)(struct mtd_info *mtd);
+	struct mtd_info *split;
+
 	/* If the driver is something smart, like UBI, it may need to maintain
 	 * its own reference counting. The below functions are only for driver.
 	 * The driver may register its callbacks. These callbacks are not
diff -Nru linux-2.6.30.5/include/linux/mtd/nand.h linux-2.6.30.5-wrt/include/linux/mtd/nand.h
--- linux-2.6.30.5/include/linux/mtd/nand.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/include/linux/mtd/nand.h	2009-09-06 18:43:48.354667544 +0200
@@ -574,6 +574,7 @@
 	int			chip_delay;
 	unsigned int		options;
 	const char		**part_probe_types;
+	int			(*chip_fixup)(struct mtd_info *mtd);
 	void			*priv;
 };
 
diff -Nru linux-2.6.30.5/include/linux/mtd/partitions.h linux-2.6.30.5-wrt/include/linux/mtd/partitions.h
--- linux-2.6.30.5/include/linux/mtd/partitions.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/include/linux/mtd/partitions.h	2009-09-06 18:43:48.350677830 +0200
@@ -34,6 +34,7 @@
  * erasesize aligned (e.g. use MTDPART_OFS_NEXTBLK).
  */
 
+struct mtd_partition;
 struct mtd_partition {
 	char *name;			/* identifier string */
 	uint64_t size;			/* partition size */
@@ -41,6 +42,7 @@
 	uint32_t mask_flags;		/* master MTD flags to mask out for this partition */
 	struct nand_ecclayout *ecclayout;	/* out of band layout for this partition (NAND only)*/
 	struct mtd_info **mtdp;		/* pointer to store the MTD object */
+	int (*refresh_partition)(struct mtd_info *);
 };
 
 #define MTDPART_OFS_NXTBLK	(-2)
@@ -50,6 +52,7 @@
 
 int add_mtd_partitions(struct mtd_info *, const struct mtd_partition *, int);
 int del_mtd_partitions(struct mtd_info *);
+int refresh_mtd_partitions(struct mtd_info *);
 
 /*
  * Functions dealing with the various ways of partitioning the space
diff -Nru linux-2.6.30.5/include/linux/netdevice.h linux-2.6.30.5-wrt/include/linux/netdevice.h
--- linux-2.6.30.5/include/linux/netdevice.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/include/linux/netdevice.h	2009-09-06 18:44:06.815168492 +0200
@@ -99,7 +99,7 @@
  */
 
 #if defined(CONFIG_WLAN_80211) || defined(CONFIG_AX25) || defined(CONFIG_AX25_MODULE)
-# if defined(CONFIG_MAC80211_MESH)
+# if 1 || defined(CONFIG_MAC80211_MESH)
 #  define LL_MAX_HEADER 128
 # else
 #  define LL_MAX_HEADER 96
@@ -770,6 +770,7 @@
 	void			*ax25_ptr;	/* AX.25 specific data */
 	struct wireless_dev	*ieee80211_ptr;	/* IEEE 802.11 specific data,
 						   assign before registering */
+	void			*phy_ptr; /* PHY device specific data */
 
 /*
  * Cache line mostly used on receive path (including eth_type_trans())
@@ -1102,6 +1103,7 @@
 extern int		dev_open(struct net_device *dev);
 extern int		dev_close(struct net_device *dev);
 extern void		dev_disable_lro(struct net_device *dev);
+extern struct netdev_queue *dev_pick_tx(struct net_device *dev, struct sk_buff *skb);
 extern int		dev_queue_xmit(struct sk_buff *skb);
 extern int		register_netdevice(struct net_device *dev);
 extern void		unregister_netdevice(struct net_device *dev);
diff -Nru linux-2.6.30.5/include/linux/netfilter/nf_conntrack_rtsp.h linux-2.6.30.5-wrt/include/linux/netfilter/nf_conntrack_rtsp.h
--- linux-2.6.30.5/include/linux/netfilter/nf_conntrack_rtsp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/include/linux/netfilter/nf_conntrack_rtsp.h	2009-09-06 18:43:48.394667414 +0200
@@ -0,0 +1,63 @@
+/*
+ * RTSP extension for IP connection tracking.
+ * (C) 2003 by Tom Marshall <tmarshall at real.com>
+ * based on ip_conntrack_irc.h
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ */
+#ifndef _IP_CONNTRACK_RTSP_H
+#define _IP_CONNTRACK_RTSP_H
+
+//#define IP_NF_RTSP_DEBUG 1
+#define IP_NF_RTSP_VERSION "0.6.21"
+
+#ifdef __KERNEL__
+/* port block types */
+typedef enum {
+    pb_single,  /* client_port=x */
+    pb_range,   /* client_port=x-y */
+    pb_discon   /* client_port=x/y (rtspbis) */
+} portblock_t;
+
+/* We record seq number and length of rtsp headers here, all in host order. */
+
+/*
+ * This structure is per expected connection.  It is a member of struct
+ * ip_conntrack_expect.  The TCP SEQ for the conntrack expect is stored
+ * there and we are expected to only store the length of the data which
+ * needs replaced.  If a packet contains multiple RTSP messages, we create
+ * one expected connection per message.
+ *
+ * We use these variables to mark the entire header block.  This may seem
+ * like overkill, but the nature of RTSP requires it.  A header may appear
+ * multiple times in a message.  We must treat two Transport headers the
+ * same as one Transport header with two entries.
+ */
+struct ip_ct_rtsp_expect
+{
+    u_int32_t   len;        /* length of header block */
+    portblock_t pbtype;     /* Type of port block that was requested */
+    u_int16_t   loport;     /* Port that was requested, low or first */
+    u_int16_t   hiport;     /* Port that was requested, high or second */
+#if 0
+    uint        method;     /* RTSP method */
+    uint        cseq;       /* CSeq from request */
+#endif
+};
+
+extern unsigned int (*nf_nat_rtsp_hook)(struct sk_buff *skb,
+				 enum ip_conntrack_info ctinfo,
+				 unsigned int matchoff, unsigned int matchlen,
+				 struct ip_ct_rtsp_expect *prtspexp,
+				 struct nf_conntrack_expect *exp);
+
+extern void (*nf_nat_rtsp_hook_expectfn)(struct nf_conn *ct, struct nf_conntrack_expect *exp);
+
+#define RTSP_PORT   554
+
+#endif /* __KERNEL__ */
+
+#endif /* _IP_CONNTRACK_RTSP_H */
diff -Nru linux-2.6.30.5/include/linux/netfilter/xt_IMQ.h linux-2.6.30.5-wrt/include/linux/netfilter/xt_IMQ.h
--- linux-2.6.30.5/include/linux/netfilter/xt_IMQ.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/include/linux/netfilter/xt_IMQ.h	2009-09-06 18:43:48.390666560 +0200
@@ -0,0 +1,9 @@
+#ifndef _XT_IMQ_H
+#define _XT_IMQ_H
+
+struct xt_imq_info {
+	unsigned int todev;     /* target imq device */
+};
+
+#endif /* _XT_IMQ_H */
+
diff -Nru linux-2.6.30.5/include/linux/netfilter/xt_layer7.h linux-2.6.30.5-wrt/include/linux/netfilter/xt_layer7.h
--- linux-2.6.30.5/include/linux/netfilter/xt_layer7.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/include/linux/netfilter/xt_layer7.h	2009-09-06 18:43:48.366668750 +0200
@@ -0,0 +1,14 @@
+#ifndef _XT_LAYER7_H
+#define _XT_LAYER7_H
+
+#define MAX_PATTERN_LEN 8192
+#define MAX_PROTOCOL_LEN 256
+
+struct xt_layer7_info {
+    char protocol[MAX_PROTOCOL_LEN];
+    char pattern[MAX_PATTERN_LEN];
+    u_int8_t invert;
+    u_int8_t pkt;
+};
+
+#endif /* _XT_LAYER7_H */
diff -Nru linux-2.6.30.5/include/linux/netfilter_helpers.h linux-2.6.30.5-wrt/include/linux/netfilter_helpers.h
--- linux-2.6.30.5/include/linux/netfilter_helpers.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/include/linux/netfilter_helpers.h	2009-09-06 18:43:48.394667414 +0200
@@ -0,0 +1,133 @@
+/*
+ * Helpers for netfiler modules.  This file provides implementations for basic
+ * functions such as strncasecmp(), etc.
+ *
+ * gcc will warn for defined but unused functions, so we only include the
+ * functions requested.  The following macros are used:
+ *   NF_NEED_STRNCASECMP        nf_strncasecmp()
+ *   NF_NEED_STRTOU16           nf_strtou16()
+ *   NF_NEED_STRTOU32           nf_strtou32()
+ */
+#ifndef _NETFILTER_HELPERS_H
+#define _NETFILTER_HELPERS_H
+
+/* Only include these functions for kernel code. */
+#ifdef __KERNEL__
+
+#include <linux/ctype.h>
+#define iseol(c) ( (c) == '\r' || (c) == '\n' )
+
+/*
+ * The standard strncasecmp()
+ */
+#ifdef NF_NEED_STRNCASECMP
+static int
+nf_strncasecmp(const char* s1, const char* s2, u_int32_t len)
+{
+    if (s1 == NULL || s2 == NULL)
+    {
+        if (s1 == NULL && s2 == NULL)
+        {
+            return 0;
+        }
+        return (s1 == NULL) ? -1 : 1;
+    }
+    while (len > 0 && tolower(*s1) == tolower(*s2))
+    {
+        len--;
+        s1++;
+        s2++;
+    }
+    return ( (len == 0) ? 0 : (tolower(*s1) - tolower(*s2)) );
+}
+#endif /* NF_NEED_STRNCASECMP */
+
+/*
+ * Parse a string containing a 16-bit unsigned integer.
+ * Returns the number of chars used, or zero if no number is found.
+ */
+#ifdef NF_NEED_STRTOU16
+static int
+nf_strtou16(const char* pbuf, u_int16_t* pval)
+{
+    int n = 0;
+
+    *pval = 0;
+    while (isdigit(pbuf[n]))
+    {
+        *pval = (*pval * 10) + (pbuf[n] - '0');
+        n++;
+    }
+
+    return n;
+}
+#endif /* NF_NEED_STRTOU16 */
+
+/*
+ * Parse a string containing a 32-bit unsigned integer.
+ * Returns the number of chars used, or zero if no number is found.
+ */
+#ifdef NF_NEED_STRTOU32
+static int
+nf_strtou32(const char* pbuf, u_int32_t* pval)
+{
+    int n = 0;
+
+    *pval = 0;
+    while (pbuf[n] >= '0' && pbuf[n] <= '9')
+    {
+        *pval = (*pval * 10) + (pbuf[n] - '0');
+        n++;
+    }
+
+    return n;
+}
+#endif /* NF_NEED_STRTOU32 */
+
+/*
+ * Given a buffer and length, advance to the next line and mark the current
+ * line.
+ */
+#ifdef NF_NEED_NEXTLINE
+static int
+nf_nextline(char* p, uint len, uint* poff, uint* plineoff, uint* plinelen)
+{
+    uint    off = *poff;
+    uint    physlen = 0;
+
+    if (off >= len)
+    {
+        return 0;
+    }
+
+    while (p[off] != '\n')
+    {
+        if (len-off <= 1)
+        {
+            return 0;
+        }
+
+        physlen++;
+        off++;
+    }
+
+    /* if we saw a crlf, physlen needs adjusted */
+    if (physlen > 0 && p[off] == '\n' && p[off-1] == '\r')
+    {
+        physlen--;
+    }
+
+    /* advance past the newline */
+    off++;
+
+    *plineoff = *poff;
+    *plinelen = physlen;
+    *poff = off;
+
+    return 1;
+}
+#endif /* NF_NEED_NEXTLINE */
+
+#endif /* __KERNEL__ */
+
+#endif /* _NETFILTER_HELPERS_H */
diff -Nru linux-2.6.30.5/include/linux/netfilter_ipv4/Kbuild linux-2.6.30.5-wrt/include/linux/netfilter_ipv4/Kbuild
--- linux-2.6.30.5/include/linux/netfilter_ipv4/Kbuild	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/include/linux/netfilter_ipv4/Kbuild	2009-09-06 18:43:48.370668913 +0200
@@ -45,3 +45,14 @@
 
 unifdef-y += ip_queue.h
 unifdef-y += ip_tables.h
+
+unifdef-y += ip_set.h
+header-y  += ip_set_iphash.h
+header-y  += ip_set_ipmap.h
+header-y  += ip_set_ipporthash.h
+unifdef-y += ip_set_iptree.h
+unifdef-y += ip_set_iptreemap.h
+header-y  += ip_set_jhash.h
+header-y  += ip_set_macipmap.h
+unifdef-y += ip_set_nethash.h
+header-y  += ip_set_portmap.h
diff -Nru linux-2.6.30.5/include/linux/netfilter_ipv4/ip_set.h linux-2.6.30.5-wrt/include/linux/netfilter_ipv4/ip_set.h
--- linux-2.6.30.5/include/linux/netfilter_ipv4/ip_set.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/include/linux/netfilter_ipv4/ip_set.h	2009-09-06 18:43:48.370668913 +0200
@@ -0,0 +1,498 @@
+#ifndef _IP_SET_H
+#define _IP_SET_H
+
+/* Copyright (C) 2000-2002 Joakim Axelsson <gozem@linux.nu>
+ *                         Patrick Schaaf <bof@bof.de>
+ *                         Martin Josefsson <gandalf@wlug.westbo.se>
+ * Copyright (C) 2003-2004 Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#if 0
+#define IP_SET_DEBUG
+#endif
+
+/*
+ * A sockopt of such quality has hardly ever been seen before on the open
+ * market!  This little beauty, hardly ever used: above 64, so it's
+ * traditionally used for firewalling, not touched (even once!) by the
+ * 2.0, 2.2 and 2.4 kernels!
+ *
+ * Comes with its own certificate of authenticity, valid anywhere in the
+ * Free world!
+ *
+ * Rusty, 19.4.2000
+ */
+#define SO_IP_SET 		83
+
+/*
+ * Heavily modify by Joakim Axelsson 08.03.2002
+ * - Made it more modulebased
+ *
+ * Additional heavy modifications by Jozsef Kadlecsik 22.02.2004
+ * - bindings added
+ * - in order to "deal with" backward compatibility, renamed to ipset
+ */
+
+/*
+ * Used so that the kernel module and ipset-binary can match their versions
+ */
+#define IP_SET_PROTOCOL_VERSION 2
+
+#define IP_SET_MAXNAMELEN 32	/* set names and set typenames */
+
+/* Lets work with our own typedef for representing an IP address.
+ * We hope to make the code more portable, possibly to IPv6...
+ *
+ * The representation works in HOST byte order, because most set types
+ * will perform arithmetic operations and compare operations.
+ *
+ * For now the type is an uint32_t.
+ *
+ * Make sure to ONLY use the functions when translating and parsing
+ * in order to keep the host byte order and make it more portable:
+ *  parse_ip()
+ *  parse_mask()
+ *  parse_ipandmask()
+ *  ip_tostring()
+ * (Joakim: where are they???)
+ */
+
+typedef uint32_t ip_set_ip_t;
+
+/* Sets are identified by an id in kernel space. Tweak with ip_set_id_t
+ * and IP_SET_INVALID_ID if you want to increase the max number of sets.
+ */
+typedef uint16_t ip_set_id_t;
+
+#define IP_SET_INVALID_ID	65535
+
+/* How deep we follow bindings */
+#define IP_SET_MAX_BINDINGS	6
+
+/*
+ * Option flags for kernel operations (ipt_set_info)
+ */
+#define IPSET_SRC 		0x01	/* Source match/add */
+#define IPSET_DST		0x02	/* Destination match/add */
+#define IPSET_MATCH_INV		0x04	/* Inverse matching */
+
+/*
+ * Set features
+ */
+#define IPSET_TYPE_IP		0x01	/* IP address type of set */
+#define IPSET_TYPE_PORT		0x02	/* Port type of set */
+#define IPSET_DATA_SINGLE	0x04	/* Single data storage */
+#define IPSET_DATA_DOUBLE	0x08	/* Double data storage */
+
+/* Reserved keywords */
+#define IPSET_TOKEN_DEFAULT	":default:"
+#define IPSET_TOKEN_ALL		":all:"
+
+/* SO_IP_SET operation constants, and their request struct types.
+ *
+ * Operation ids:
+ *	  0-99:	 commands with version checking
+ *	100-199: add/del/test/bind/unbind
+ *	200-299: list, save, restore
+ */
+
+/* Single shot operations:
+ * version, create, destroy, flush, rename and swap
+ *
+ * Sets are identified by name.
+ */
+
+#define IP_SET_REQ_STD		\
+	unsigned op;		\
+	unsigned version;	\
+	char name[IP_SET_MAXNAMELEN]
+
+#define IP_SET_OP_CREATE	0x00000001	/* Create a new (empty) set */
+struct ip_set_req_create {
+	IP_SET_REQ_STD;
+	char typename[IP_SET_MAXNAMELEN];
+};
+
+#define IP_SET_OP_DESTROY	0x00000002	/* Remove a (empty) set */
+struct ip_set_req_std {
+	IP_SET_REQ_STD;
+};
+
+#define IP_SET_OP_FLUSH		0x00000003	/* Remove all IPs in a set */
+/* Uses ip_set_req_std */
+
+#define IP_SET_OP_RENAME	0x00000004	/* Rename a set */
+/* Uses ip_set_req_create */
+
+#define IP_SET_OP_SWAP		0x00000005	/* Swap two sets */
+/* Uses ip_set_req_create */
+
+union ip_set_name_index {
+	char name[IP_SET_MAXNAMELEN];
+	ip_set_id_t index;
+};
+
+#define IP_SET_OP_GET_BYNAME	0x00000006	/* Get set index by name */
+struct ip_set_req_get_set {
+	unsigned op;
+	unsigned version;
+	union ip_set_name_index set;
+};
+
+#define IP_SET_OP_GET_BYINDEX	0x00000007	/* Get set name by index */
+/* Uses ip_set_req_get_set */
+
+#define IP_SET_OP_VERSION	0x00000100	/* Ask kernel version */
+struct ip_set_req_version {
+	unsigned op;
+	unsigned version;
+};
+
+/* Double shots operations:
+ * add, del, test, bind and unbind.
+ *
+ * First we query the kernel to get the index and type of the target set,
+ * then issue the command. Validity of IP is checked in kernel in order
+ * to minimalize sockopt operations.
+ */
+
+/* Get minimal set data for add/del/test/bind/unbind IP */
+#define IP_SET_OP_ADT_GET	0x00000010	/* Get set and type */
+struct ip_set_req_adt_get {
+	unsigned op;
+	unsigned version;
+	union ip_set_name_index set;
+	char typename[IP_SET_MAXNAMELEN];
+};
+
+#define IP_SET_REQ_BYINDEX	\
+	unsigned op;		\
+	ip_set_id_t index;
+
+struct ip_set_req_adt {
+	IP_SET_REQ_BYINDEX;
+};
+
+#define IP_SET_OP_ADD_IP	0x00000101	/* Add an IP to a set */
+/* Uses ip_set_req_adt, with type specific addage */
+
+#define IP_SET_OP_DEL_IP	0x00000102	/* Remove an IP from a set */
+/* Uses ip_set_req_adt, with type specific addage */
+
+#define IP_SET_OP_TEST_IP	0x00000103	/* Test an IP in a set */
+/* Uses ip_set_req_adt, with type specific addage */
+
+#define IP_SET_OP_BIND_SET	0x00000104	/* Bind an IP to a set */
+/* Uses ip_set_req_bind, with type specific addage */
+struct ip_set_req_bind {
+	IP_SET_REQ_BYINDEX;
+	char binding[IP_SET_MAXNAMELEN];
+};
+
+#define IP_SET_OP_UNBIND_SET	0x00000105	/* Unbind an IP from a set */
+/* Uses ip_set_req_bind, with type speficic addage
+ * index = 0 means unbinding for all sets */
+
+#define IP_SET_OP_TEST_BIND_SET	0x00000106	/* Test binding an IP to a set */
+/* Uses ip_set_req_bind, with type specific addage */
+
+/* Multiple shots operations: list, save, restore.
+ *
+ * - check kernel version and query the max number of sets
+ * - get the basic information on all sets
+ *   and size required for the next step
+ * - get actual set data: header, data, bindings
+ */
+
+/* Get max_sets and the index of a queried set
+ */
+#define IP_SET_OP_MAX_SETS	0x00000020
+struct ip_set_req_max_sets {
+	unsigned op;
+	unsigned version;
+	ip_set_id_t max_sets;		/* max_sets */
+	ip_set_id_t sets;		/* real number of sets */
+	union ip_set_name_index set;	/* index of set if name used */
+};
+
+/* Get the id and name of the sets plus size for next step */
+#define IP_SET_OP_LIST_SIZE	0x00000201
+#define IP_SET_OP_SAVE_SIZE	0x00000202
+struct ip_set_req_setnames {
+	unsigned op;
+	ip_set_id_t index;		/* set to list/save */
+	size_t size;			/* size to get setdata/bindings */
+	/* followed by sets number of struct ip_set_name_list */
+};
+
+struct ip_set_name_list {
+	char name[IP_SET_MAXNAMELEN];
+	char typename[IP_SET_MAXNAMELEN];
+	ip_set_id_t index;
+	ip_set_id_t id;
+};
+
+/* The actual list operation */
+#define IP_SET_OP_LIST		0x00000203
+struct ip_set_req_list {
+	IP_SET_REQ_BYINDEX;
+	/* sets number of struct ip_set_list in reply */
+};
+
+struct ip_set_list {
+	ip_set_id_t index;
+	ip_set_id_t binding;
+	u_int32_t ref;
+	size_t header_size;	/* Set header data of header_size */
+	size_t members_size;	/* Set members data of members_size */
+	size_t bindings_size;	/* Set bindings data of bindings_size */
+};
+
+struct ip_set_hash_list {
+	ip_set_ip_t ip;
+	ip_set_id_t binding;
+};
+
+/* The save operation */
+#define IP_SET_OP_SAVE		0x00000204
+/* Uses ip_set_req_list, in the reply replaced by
+ * sets number of struct ip_set_save plus a marker
+ * ip_set_save followed by ip_set_hash_save structures.
+ */
+struct ip_set_save {
+	ip_set_id_t index;
+	ip_set_id_t binding;
+	size_t header_size;	/* Set header data of header_size */
+	size_t members_size;	/* Set members data of members_size */
+};
+
+/* At restoring, ip == 0 means default binding for the given set: */
+struct ip_set_hash_save {
+	ip_set_ip_t ip;
+	ip_set_id_t id;
+	ip_set_id_t binding;
+};
+
+/* The restore operation */
+#define IP_SET_OP_RESTORE	0x00000205
+/* Uses ip_set_req_setnames followed by ip_set_restore structures
+ * plus a marker ip_set_restore, followed by ip_set_hash_save
+ * structures.
+ */
+struct ip_set_restore {
+	char name[IP_SET_MAXNAMELEN];
+	char typename[IP_SET_MAXNAMELEN];
+	ip_set_id_t index;
+	size_t header_size;	/* Create data of header_size */
+	size_t members_size;	/* Set members data of members_size */
+};
+
+static inline int bitmap_bytes(ip_set_ip_t a, ip_set_ip_t b)
+{
+	return 4 * ((((b - a + 8) / 8) + 3) / 4);
+}
+
+#ifdef __KERNEL__
+
+#define ip_set_printk(format, args...) 			\
+	do {							\
+		printk("%s: %s: ", __FILE__, __FUNCTION__);	\
+		printk(format "\n" , ## args);			\
+	} while (0)
+
+#if defined(IP_SET_DEBUG)
+#define DP(format, args...) 					\
+	do {							\
+		printk("%s: %s (DBG): ", __FILE__, __FUNCTION__);\
+		printk(format "\n" , ## args);			\
+	} while (0)
+#define IP_SET_ASSERT(x)					\
+	do {							\
+		if (!(x))					\
+			printk("IP_SET_ASSERT: %s:%i(%s)\n",	\
+				__FILE__, __LINE__, __FUNCTION__); \
+	} while (0)
+#else
+#define DP(format, args...)
+#define IP_SET_ASSERT(x)
+#endif
+
+struct ip_set;
+
+/*
+ * The ip_set_type definition - one per set type, e.g. "ipmap".
+ *
+ * Each individual set has a pointer, set->type, going to one
+ * of these structures. Function pointers inside the structure implement
+ * the real behaviour of the sets.
+ *
+ * If not mentioned differently, the implementation behind the function
+ * pointers of a set_type, is expected to return 0 if ok, and a negative
+ * errno (e.g. -EINVAL) on error.
+ */
+struct ip_set_type {
+	struct list_head list;	/* next in list of set types */
+
+	/* test for IP in set (kernel: iptables -m set src|dst)
+	 * return 0 if not in set, 1 if in set.
+	 */
+	int (*testip_kernel) (struct ip_set *set,
+			      const struct sk_buff * skb,
+			      ip_set_ip_t *ip,
+			      const u_int32_t *flags,
+			      unsigned char index);
+
+	/* test for IP in set (userspace: ipset -T set IP)
+	 * return 0 if not in set, 1 if in set.
+	 */
+	int (*testip) (struct ip_set *set,
+		       const void *data, size_t size,
+		       ip_set_ip_t *ip);
+
+	/*
+	 * Size of the data structure passed by when
+	 * adding/deletin/testing an entry.
+	 */
+	size_t reqsize;
+
+	/* Add IP into set (userspace: ipset -A set IP)
+	 * Return -EEXIST if the address is already in the set,
+	 * and -ERANGE if the address lies outside the set bounds.
+	 * If the address was not already in the set, 0 is returned.
+	 */
+	int (*addip) (struct ip_set *set,
+		      const void *data, size_t size,
+		      ip_set_ip_t *ip);
+
+	/* Add IP into set (kernel: iptables ... -j SET set src|dst)
+	 * Return -EEXIST if the address is already in the set,
+	 * and -ERANGE if the address lies outside the set bounds.
+	 * If the address was not already in the set, 0 is returned.
+	 */
+	int (*addip_kernel) (struct ip_set *set,
+			     const struct sk_buff * skb,
+			     ip_set_ip_t *ip,
+			     const u_int32_t *flags,
+			     unsigned char index);
+
+	/* remove IP from set (userspace: ipset -D set --entry x)
+	 * Return -EEXIST if the address is NOT in the set,
+	 * and -ERANGE if the address lies outside the set bounds.
+	 * If the address really was in the set, 0 is returned.
+	 */
+	int (*delip) (struct ip_set *set,
+		      const void *data, size_t size,
+		      ip_set_ip_t *ip);
+
+	/* remove IP from set (kernel: iptables ... -j SET --entry x)
+	 * Return -EEXIST if the address is NOT in the set,
+	 * and -ERANGE if the address lies outside the set bounds.
+	 * If the address really was in the set, 0 is returned.
+	 */
+	int (*delip_kernel) (struct ip_set *set,
+			     const struct sk_buff * skb,
+			     ip_set_ip_t *ip,
+			     const u_int32_t *flags,
+			     unsigned char index);
+
+	/* new set creation - allocated type specific items
+	 */
+	int (*create) (struct ip_set *set,
+		       const void *data, size_t size);
+
+	/* retry the operation after successfully tweaking the set
+	 */
+	int (*retry) (struct ip_set *set);
+
+	/* set destruction - free type specific items
+	 * There is no return value.
+	 * Can be called only when child sets are destroyed.
+	 */
+	void (*destroy) (struct ip_set *set);
+
+	/* set flushing - reset all bits in the set, or something similar.
+	 * There is no return value.
+	 */
+	void (*flush) (struct ip_set *set);
+
+	/* Listing: size needed for header
+	 */
+	size_t header_size;
+
+	/* Listing: Get the header
+	 *
+	 * Fill in the information in "data".
+	 * This function is always run after list_header_size() under a
+	 * writelock on the set. Therefor is the length of "data" always
+	 * correct.
+	 */
+	void (*list_header) (const struct ip_set *set,
+			     void *data);
+
+	/* Listing: Get the size for the set members
+	 */
+	int (*list_members_size) (const struct ip_set *set);
+
+	/* Listing: Get the set members
+	 *
+	 * Fill in the information in "data".
+	 * This function is always run after list_member_size() under a
+	 * writelock on the set. Therefor is the length of "data" always
+	 * correct.
+	 */
+	void (*list_members) (const struct ip_set *set,
+			      void *data);
+
+	char typename[IP_SET_MAXNAMELEN];
+	unsigned char features;
+	int protocol_version;
+
+	/* Set this to THIS_MODULE if you are a module, otherwise NULL */
+	struct module *me;
+};
+
+extern int ip_set_register_set_type(struct ip_set_type *set_type);
+extern void ip_set_unregister_set_type(struct ip_set_type *set_type);
+
+/* A generic ipset */
+struct ip_set {
+	char name[IP_SET_MAXNAMELEN];	/* the name of the set */
+	rwlock_t lock;			/* lock for concurrency control */
+	ip_set_id_t id;			/* set id for swapping */
+	ip_set_id_t binding;		/* default binding for the set */
+	atomic_t ref;			/* in kernel and in hash references */
+	struct ip_set_type *type; 	/* the set types */
+	void *data;			/* pooltype specific data */
+};
+
+/* Structure to bind set elements to sets */
+struct ip_set_hash {
+	struct list_head list;		/* list of clashing entries in hash */
+	ip_set_ip_t ip;			/* ip from set */
+	ip_set_id_t id;			/* set id */
+	ip_set_id_t binding;		/* set we bind the element to */
+};
+
+/* register and unregister set references */
+extern ip_set_id_t ip_set_get_byname(const char name[IP_SET_MAXNAMELEN]);
+extern ip_set_id_t ip_set_get_byindex(ip_set_id_t id);
+extern void ip_set_put(ip_set_id_t id);
+
+/* API for iptables set match, and SET target */
+extern void ip_set_addip_kernel(ip_set_id_t id,
+				const struct sk_buff *skb,
+				const u_int32_t *flags);
+extern void ip_set_delip_kernel(ip_set_id_t id,
+				const struct sk_buff *skb,
+				const u_int32_t *flags);
+extern int ip_set_testip_kernel(ip_set_id_t id,
+				const struct sk_buff *skb,
+				const u_int32_t *flags);
+
+#endif				/* __KERNEL__ */
+
+#endif /*_IP_SET_H*/
diff -Nru linux-2.6.30.5/include/linux/netfilter_ipv4/ip_set_iphash.h linux-2.6.30.5-wrt/include/linux/netfilter_ipv4/ip_set_iphash.h
--- linux-2.6.30.5/include/linux/netfilter_ipv4/ip_set_iphash.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/include/linux/netfilter_ipv4/ip_set_iphash.h	2009-09-06 18:43:48.370668913 +0200
@@ -0,0 +1,30 @@
+#ifndef __IP_SET_IPHASH_H
+#define __IP_SET_IPHASH_H
+
+#include <linux/netfilter_ipv4/ip_set.h>
+
+#define SETTYPE_NAME "iphash"
+#define MAX_RANGE 0x0000FFFF
+
+struct ip_set_iphash {
+	ip_set_ip_t *members;		/* the iphash proper */
+	uint32_t elements;		/* number of elements */
+	uint32_t hashsize;		/* hash size */
+	uint16_t probes;		/* max number of probes  */
+	uint16_t resize;		/* resize factor in percent */
+	ip_set_ip_t netmask;		/* netmask */
+	void *initval[0];		/* initvals for jhash_1word */
+};
+
+struct ip_set_req_iphash_create {
+	uint32_t hashsize;
+	uint16_t probes;
+	uint16_t resize;
+	ip_set_ip_t netmask;
+};
+
+struct ip_set_req_iphash {
+	ip_set_ip_t ip;
+};
+
+#endif	/* __IP_SET_IPHASH_H */
diff -Nru linux-2.6.30.5/include/linux/netfilter_ipv4/ip_set_ipmap.h linux-2.6.30.5-wrt/include/linux/netfilter_ipv4/ip_set_ipmap.h
--- linux-2.6.30.5/include/linux/netfilter_ipv4/ip_set_ipmap.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/include/linux/netfilter_ipv4/ip_set_ipmap.h	2009-09-06 18:43:48.370668913 +0200
@@ -0,0 +1,56 @@
+#ifndef __IP_SET_IPMAP_H
+#define __IP_SET_IPMAP_H
+
+#include <linux/netfilter_ipv4/ip_set.h>
+
+#define SETTYPE_NAME "ipmap"
+#define MAX_RANGE 0x0000FFFF
+
+struct ip_set_ipmap {
+	void *members;			/* the ipmap proper */
+	ip_set_ip_t first_ip;		/* host byte order, included in range */
+	ip_set_ip_t last_ip;		/* host byte order, included in range */
+	ip_set_ip_t netmask;		/* subnet netmask */
+	ip_set_ip_t sizeid;		/* size of set in IPs */
+	ip_set_ip_t hosts;		/* number of hosts in a subnet */
+};
+
+struct ip_set_req_ipmap_create {
+	ip_set_ip_t from;
+	ip_set_ip_t to;
+	ip_set_ip_t netmask;
+};
+
+struct ip_set_req_ipmap {
+	ip_set_ip_t ip;
+};
+
+unsigned int
+mask_to_bits(ip_set_ip_t mask)
+{
+	unsigned int bits = 32;
+	ip_set_ip_t maskaddr;
+
+	if (mask == 0xFFFFFFFF)
+		return bits;
+
+	maskaddr = 0xFFFFFFFE;
+	while (--bits >= 0 && maskaddr != mask)
+		maskaddr <<= 1;
+
+	return bits;
+}
+
+ip_set_ip_t
+range_to_mask(ip_set_ip_t from, ip_set_ip_t to, unsigned int *bits)
+{
+	ip_set_ip_t mask = 0xFFFFFFFE;
+
+	*bits = 32;
+	while (--(*bits) >= 0 && mask && (to & mask) != from)
+		mask <<= 1;
+
+	return mask;
+}
+
+#endif /* __IP_SET_IPMAP_H */
diff -Nru linux-2.6.30.5/include/linux/netfilter_ipv4/ip_set_ipporthash.h linux-2.6.30.5-wrt/include/linux/netfilter_ipv4/ip_set_ipporthash.h
--- linux-2.6.30.5/include/linux/netfilter_ipv4/ip_set_ipporthash.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/include/linux/netfilter_ipv4/ip_set_ipporthash.h	2009-09-06 18:43:48.370668913 +0200
@@ -0,0 +1,34 @@
+#ifndef __IP_SET_IPPORTHASH_H
+#define __IP_SET_IPPORTHASH_H
+
+#include <linux/netfilter_ipv4/ip_set.h>
+
+#define SETTYPE_NAME "ipporthash"
+#define MAX_RANGE 0x0000FFFF
+#define INVALID_PORT	(MAX_RANGE + 1)
+
+struct ip_set_ipporthash {
+	ip_set_ip_t *members;		/* the ipporthash proper */
+	uint32_t elements;		/* number of elements */
+	uint32_t hashsize;		/* hash size */
+	uint16_t probes;		/* max number of probes  */
+	uint16_t resize;		/* resize factor in percent */
+	ip_set_ip_t first_ip;		/* host byte order, included in range */
+	ip_set_ip_t last_ip;		/* host byte order, included in range */
+	void *initval[0];		/* initvals for jhash_1word */
+};
+
+struct ip_set_req_ipporthash_create {
+	uint32_t hashsize;
+	uint16_t probes;
+	uint16_t resize;
+	ip_set_ip_t from;
+	ip_set_ip_t to;
+};
+
+struct ip_set_req_ipporthash {
+	ip_set_ip_t ip;
+	ip_set_ip_t port;
+};
+
+#endif	/* __IP_SET_IPPORTHASH_H */
diff -Nru linux-2.6.30.5/include/linux/netfilter_ipv4/ip_set_iptree.h linux-2.6.30.5-wrt/include/linux/netfilter_ipv4/ip_set_iptree.h
--- linux-2.6.30.5/include/linux/netfilter_ipv4/ip_set_iptree.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/include/linux/netfilter_ipv4/ip_set_iptree.h	2009-09-06 18:43:48.374667723 +0200
@@ -0,0 +1,40 @@
+#ifndef __IP_SET_IPTREE_H
+#define __IP_SET_IPTREE_H
+
+#include <linux/netfilter_ipv4/ip_set.h>
+
+#define SETTYPE_NAME "iptree"
+#define MAX_RANGE 0x0000FFFF
+
+struct ip_set_iptreed {
+	unsigned long expires[256];	   	/* x.x.x.ADDR */
+};
+
+struct ip_set_iptreec {
+	struct ip_set_iptreed *tree[256];	/* x.x.ADDR.* */
+};
+
+struct ip_set_iptreeb {
+	struct ip_set_iptreec *tree[256];	/* x.ADDR.*.* */
+};
+
+struct ip_set_iptree {
+	unsigned int timeout;
+	unsigned int gc_interval;
+#ifdef __KERNEL__
+	uint32_t elements;		/* number of elements */
+	struct timer_list gc;
+	struct ip_set_iptreeb *tree[256];	/* ADDR.*.*.* */
+#endif
+};
+
+struct ip_set_req_iptree_create {
+	unsigned int timeout;
+};
+
+struct ip_set_req_iptree {
+	ip_set_ip_t ip;
+	unsigned int timeout;
+};
+
+#endif	/* __IP_SET_IPTREE_H */
diff -Nru linux-2.6.30.5/include/linux/netfilter_ipv4/ip_set_iptreemap.h linux-2.6.30.5-wrt/include/linux/netfilter_ipv4/ip_set_iptreemap.h
--- linux-2.6.30.5/include/linux/netfilter_ipv4/ip_set_iptreemap.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/include/linux/netfilter_ipv4/ip_set_iptreemap.h	2009-09-06 18:43:48.374667723 +0200
@@ -0,0 +1,40 @@
+#ifndef __IP_SET_IPTREEMAP_H
+#define __IP_SET_IPTREEMAP_H
+
+#include <linux/netfilter_ipv4/ip_set.h>
+
+#define SETTYPE_NAME "iptreemap"
+
+#ifdef __KERNEL__
+struct ip_set_iptreemap_d {
+	unsigned char bitmap[32]; /* x.x.x.y */
+};
+
+struct ip_set_iptreemap_c {
+	struct ip_set_iptreemap_d *tree[256]; /* x.x.y.x */
+};
+
+struct ip_set_iptreemap_b {
+	struct ip_set_iptreemap_c *tree[256]; /* x.y.x.x */
+	unsigned char dirty[32];
+};
+#endif
+
+struct ip_set_iptreemap {
+	unsigned int gc_interval;
+#ifdef __KERNEL__
+	struct timer_list gc;
+	struct ip_set_iptreemap_b *tree[256]; /* y.x.x.x */
+#endif
+};
+
+struct ip_set_req_iptreemap_create {
+	unsigned int gc_interval;
+};
+
+struct ip_set_req_iptreemap {
+	ip_set_ip_t start;
+	ip_set_ip_t end;
+};
+
+#endif /* __IP_SET_IPTREEMAP_H */
diff -Nru linux-2.6.30.5/include/linux/netfilter_ipv4/ip_set_jhash.h linux-2.6.30.5-wrt/include/linux/netfilter_ipv4/ip_set_jhash.h
--- linux-2.6.30.5/include/linux/netfilter_ipv4/ip_set_jhash.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/include/linux/netfilter_ipv4/ip_set_jhash.h	2009-09-06 18:43:48.374667723 +0200
@@ -0,0 +1,148 @@
+#ifndef _LINUX_IPSET_JHASH_H
+#define _LINUX_IPSET_JHASH_H
+
+/* This is a copy of linux/jhash.h but the types u32/u8 are changed
+ * to __u32/__u8 so that the header file can be included into
+ * userspace code as well. Jozsef Kadlecsik (kadlec@blackhole.kfki.hu)
+ */
+
+/* jhash.h: Jenkins hash support.
+ *
+ * Copyright (C) 1996 Bob Jenkins (bob_jenkins@burtleburtle.net)
+ *
+ * http://burtleburtle.net/bob/hash/
+ *
+ * These are the credits from Bob's sources:
+ *
+ * lookup2.c, by Bob Jenkins, December 1996, Public Domain.
+ * hash(), hash2(), hash3, and mix() are externally useful functions.
+ * Routines to test the hash are included if SELF_TEST is defined.
+ * You can use this free for any purpose.  It has no warranty.
+ *
+ * Copyright (C) 2003 David S. Miller (davem@redhat.com)
+ *
+ * I've modified Bob's hash to be useful in the Linux kernel, and
+ * any bugs present are surely my fault.  -DaveM
+ */
+
+/* NOTE: Arguments are modified. */
+#define __jhash_mix(a, b, c) \
+{ \
+  a -= b; a -= c; a ^= (c>>13); \
+  b -= c; b -= a; b ^= (a<<8); \
+  c -= a; c -= b; c ^= (b>>13); \
+  a -= b; a -= c; a ^= (c>>12);  \
+  b -= c; b -= a; b ^= (a<<16); \
+  c -= a; c -= b; c ^= (b>>5); \
+  a -= b; a -= c; a ^= (c>>3);  \
+  b -= c; b -= a; b ^= (a<<10); \
+  c -= a; c -= b; c ^= (b>>15); \
+}
+
+/* The golden ration: an arbitrary value */
+#define JHASH_GOLDEN_RATIO	0x9e3779b9
+
+/* The most generic version, hashes an arbitrary sequence
+ * of bytes.  No alignment or length assumptions are made about
+ * the input key.
+ */
+static inline __u32 jhash(void *key, __u32 length, __u32 initval)
+{
+	__u32 a, b, c, len;
+	__u8 *k = key;
+
+	len = length;
+	a = b = JHASH_GOLDEN_RATIO;
+	c = initval;
+
+	while (len >= 12) {
+		a += (k[0] +((__u32)k[1]<<8) +((__u32)k[2]<<16) +((__u32)k[3]<<24));
+		b += (k[4] +((__u32)k[5]<<8) +((__u32)k[6]<<16) +((__u32)k[7]<<24));
+		c += (k[8] +((__u32)k[9]<<8) +((__u32)k[10]<<16)+((__u32)k[11]<<24));
+
+		__jhash_mix(a,b,c);
+
+		k += 12;
+		len -= 12;
+	}
+
+	c += length;
+	switch (len) {
+	case 11: c += ((__u32)k[10]<<24);
+	case 10: c += ((__u32)k[9]<<16);
+	case 9 : c += ((__u32)k[8]<<8);
+	case 8 : b += ((__u32)k[7]<<24);
+	case 7 : b += ((__u32)k[6]<<16);
+	case 6 : b += ((__u32)k[5]<<8);
+	case 5 : b += k[4];
+	case 4 : a += ((__u32)k[3]<<24);
+	case 3 : a += ((__u32)k[2]<<16);
+	case 2 : a += ((__u32)k[1]<<8);
+	case 1 : a += k[0];
+	};
+
+	__jhash_mix(a,b,c);
+
+	return c;
+}
+
+/* A special optimized version that handles 1 or more of __u32s.
+ * The length parameter here is the number of __u32s in the key.
+ */
+static inline __u32 jhash2(__u32 *k, __u32 length, __u32 initval)
+{
+	__u32 a, b, c, len;
+
+	a = b = JHASH_GOLDEN_RATIO;
+	c = initval;
+	len = length;
+
+	while (len >= 3) {
+		a += k[0];
+		b += k[1];
+		c += k[2];
+		__jhash_mix(a, b, c);
+		k += 3; len -= 3;
+	}
+
+	c += length * 4;
+
+	switch (len) {
+	case 2 : b += k[1];
+	case 1 : a += k[0];
+	};
+
+	__jhash_mix(a,b,c);
+
+	return c;
+}
+
+
+/* A special ultra-optimized versions that knows they are hashing exactly
+ * 3, 2 or 1 word(s).
+ *
+ * NOTE: In partilar the "c += length; __jhash_mix(a,b,c);" normally
+ *       done at the end is not done here.
+ */
+static inline __u32 jhash_3words(__u32 a, __u32 b, __u32 c, __u32 initval)
+{
+	a += JHASH_GOLDEN_RATIO;
+	b += JHASH_GOLDEN_RATIO;
+	c += initval;
+
+	__jhash_mix(a, b, c);
+
+	return c;
+}
+
+static inline __u32 jhash_2words(__u32 a, __u32 b, __u32 initval)
+{
+	return jhash_3words(a, b, 0, initval);
+}
+
+static inline __u32 jhash_1word(__u32 a, __u32 initval)
+{
+	return jhash_3words(a, 0, 0, initval);
+}
+
+#endif /* _LINUX_IPSET_JHASH_H */
diff -Nru linux-2.6.30.5/include/linux/netfilter_ipv4/ip_set_macipmap.h linux-2.6.30.5-wrt/include/linux/netfilter_ipv4/ip_set_macipmap.h
--- linux-2.6.30.5/include/linux/netfilter_ipv4/ip_set_macipmap.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/include/linux/netfilter_ipv4/ip_set_macipmap.h	2009-09-06 18:43:48.374667723 +0200
@@ -0,0 +1,38 @@
+#ifndef __IP_SET_MACIPMAP_H
+#define __IP_SET_MACIPMAP_H
+
+#include <linux/netfilter_ipv4/ip_set.h>
+
+#define SETTYPE_NAME "macipmap"
+#define MAX_RANGE 0x0000FFFF
+
+/* general flags */
+#define IPSET_MACIP_MATCHUNSET	1
+
+/* per ip flags */
+#define IPSET_MACIP_ISSET	1
+
+struct ip_set_macipmap {
+	void *members;			/* the macipmap proper */
+	ip_set_ip_t first_ip;		/* host byte order, included in range */
+	ip_set_ip_t last_ip;		/* host byte order, included in range */
+	u_int32_t flags;
+};
+
+struct ip_set_req_macipmap_create {
+	ip_set_ip_t from;
+	ip_set_ip_t to;
+	u_int32_t flags;
+};
+
+struct ip_set_req_macipmap {
+	ip_set_ip_t ip;
+	unsigned char ethernet[ETH_ALEN];
+};
+
+struct ip_set_macip {
+	unsigned short flags;
+	unsigned char ethernet[ETH_ALEN];
+};
+
+#endif	/* __IP_SET_MACIPMAP_H */
diff -Nru linux-2.6.30.5/include/linux/netfilter_ipv4/ip_set_malloc.h linux-2.6.30.5-wrt/include/linux/netfilter_ipv4/ip_set_malloc.h
--- linux-2.6.30.5/include/linux/netfilter_ipv4/ip_set_malloc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/include/linux/netfilter_ipv4/ip_set_malloc.h	2009-09-06 18:43:48.374667723 +0200
@@ -0,0 +1,116 @@
+#ifndef _IP_SET_MALLOC_H
+#define _IP_SET_MALLOC_H
+
+#ifdef __KERNEL__
+
+/* Memory allocation and deallocation */
+static size_t max_malloc_size = 0;
+
+static inline void init_max_malloc_size(void)
+{
+#define CACHE(x) max_malloc_size = x;
+#include <linux/kmalloc_sizes.h>
+#undef CACHE
+}
+
+static inline void * ip_set_malloc(size_t bytes)
+{
+	if (bytes > max_malloc_size)
+		return vmalloc(bytes);
+	else
+		return kmalloc(bytes, GFP_KERNEL);
+}
+
+static inline void ip_set_free(void * data, size_t bytes)
+{
+	if (bytes > max_malloc_size)
+		vfree(data);
+	else
+		kfree(data);
+}
+
+struct harray {
+	size_t max_elements;
+	void *arrays[0];
+};
+
+static inline void *
+harray_malloc(size_t hashsize, size_t typesize, int flags)
+{
+	struct harray *harray;
+	size_t max_elements, size, i, j;
+
+	if (!max_malloc_size)
+		init_max_malloc_size();
+
+	if (typesize > max_malloc_size)
+		return NULL;
+
+	max_elements = max_malloc_size/typesize;
+	size = hashsize/max_elements;
+	if (hashsize % max_elements)
+		size++;
+
+	/* Last pointer signals end of arrays */
+	harray = kmalloc(sizeof(struct harray) + (size + 1) * sizeof(void *),
+			 flags);
+
+	if (!harray)
+		return NULL;
+
+	for (i = 0; i < size - 1; i++) {
+		harray->arrays[i] = kmalloc(max_elements * typesize, flags);
+		if (!harray->arrays[i])
+			goto undo;
+		memset(harray->arrays[i], 0, max_elements * typesize);
+	}
+	harray->arrays[i] = kmalloc((hashsize - i * max_elements) * typesize,
+				    flags);
+	if (!harray->arrays[i])
+		goto undo;
+	memset(harray->arrays[i], 0, (hashsize - i * max_elements) * typesize);
+
+	harray->max_elements = max_elements;
+	harray->arrays[size] = NULL;
+
+	return (void *)harray;
+
+    undo:
+    	for (j = 0; j < i; j++) {
+    		kfree(harray->arrays[j]);
+    	}
+    	kfree(harray);
+    	return NULL;
+}
+
+static inline void harray_free(void *h)
+{
+	struct harray *harray = (struct harray *) h;
+	size_t i;
+
+    	for (i = 0; harray->arrays[i] != NULL; i++)
+    		kfree(harray->arrays[i]);
+    	kfree(harray);
+}
+
+static inline void harray_flush(void *h, size_t hashsize, size_t typesize)
+{
+	struct harray *harray = (struct harray *) h;
+	size_t i;
+
+    	for (i = 0; harray->arrays[i+1] != NULL; i++)
+		memset(harray->arrays[i], 0, harray->max_elements * typesize);
+	memset(harray->arrays[i], 0,
+	       (hashsize - i * harray->max_elements) * typesize);
+}
+
+#define HARRAY_ELEM(h, type, which)				\
+({								\
+	struct harray *__h = (struct harray *)(h);		\
+	((type)((__h)->arrays[(which)/(__h)->max_elements])	\
+		+ (which)%(__h)->max_elements);			\
+})
+
+#endif				/* __KERNEL__ */
+
+#endif /*_IP_SET_MALLOC_H*/
diff -Nru linux-2.6.30.5/include/linux/netfilter_ipv4/ip_set_nethash.h linux-2.6.30.5-wrt/include/linux/netfilter_ipv4/ip_set_nethash.h
--- linux-2.6.30.5/include/linux/netfilter_ipv4/ip_set_nethash.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/include/linux/netfilter_ipv4/ip_set_nethash.h	2009-09-06 18:43:48.374667723 +0200
@@ -0,0 +1,55 @@
+#ifndef __IP_SET_NETHASH_H
+#define __IP_SET_NETHASH_H
+
+#include <linux/netfilter_ipv4/ip_set.h>
+
+#define SETTYPE_NAME "nethash"
+#define MAX_RANGE 0x0000FFFF
+
+struct ip_set_nethash {
+	ip_set_ip_t *members;		/* the nethash proper */
+	uint32_t elements;		/* number of elements */
+	uint32_t hashsize;		/* hash size */
+	uint16_t probes;		/* max number of probes  */
+	uint16_t resize;		/* resize factor in percent */
+	unsigned char cidr[30];		/* CIDR sizes */
+	void *initval[0];		/* initvals for jhash_1word */
+};
+
+struct ip_set_req_nethash_create {
+	uint32_t hashsize;
+	uint16_t probes;
+	uint16_t resize;
+};
+
+struct ip_set_req_nethash {
+	ip_set_ip_t ip;
+	unsigned char cidr;
+};
+
+static unsigned char shifts[] = {255, 253, 249, 241, 225, 193, 129, 1};
+
+static inline ip_set_ip_t
+pack(ip_set_ip_t ip, unsigned char cidr)
+{
+	ip_set_ip_t addr, *paddr = &addr;
+	unsigned char n, t, *a;
+
+	addr = htonl(ip & (0xFFFFFFFF << (32 - (cidr))));
+#ifdef __KERNEL__
+	DP("ip:%u.%u.%u.%u/%u", NIPQUAD(addr), cidr);
+#endif
+	n = cidr / 8;
+	t = cidr % 8;
+	a = &((unsigned char *)paddr)[n];
+	*a = *a /(1 << (8 - t)) + shifts[t];
+#ifdef __KERNEL__
+	DP("n: %u, t: %u, a: %u", n, t, *a);
+	DP("ip:%u.%u.%u.%u/%u, %u.%u.%u.%u",
+	   HIPQUAD(ip), cidr, NIPQUAD(addr));
+#endif
+
+	return ntohl(addr);
+}
+
+#endif	/* __IP_SET_NETHASH_H */
diff -Nru linux-2.6.30.5/include/linux/netfilter_ipv4/ip_set_portmap.h linux-2.6.30.5-wrt/include/linux/netfilter_ipv4/ip_set_portmap.h
--- linux-2.6.30.5/include/linux/netfilter_ipv4/ip_set_portmap.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/include/linux/netfilter_ipv4/ip_set_portmap.h	2009-09-06 18:43:48.374667723 +0200
@@ -0,0 +1,25 @@
+#ifndef __IP_SET_PORTMAP_H
+#define __IP_SET_PORTMAP_H
+
+#include <linux/netfilter_ipv4/ip_set.h>
+
+#define SETTYPE_NAME	"portmap"
+#define MAX_RANGE	0x0000FFFF
+#define INVALID_PORT	(MAX_RANGE + 1)
+
+struct ip_set_portmap {
+	void *members;			/* the portmap proper */
+	ip_set_ip_t first_port;		/* host byte order, included in range */
+	ip_set_ip_t last_port;		/* host byte order, included in range */
+};
+
+struct ip_set_req_portmap_create {
+	ip_set_ip_t from;
+	ip_set_ip_t to;
+};
+
+struct ip_set_req_portmap {
+	ip_set_ip_t port;
+};
+
+#endif /* __IP_SET_PORTMAP_H */
diff -Nru linux-2.6.30.5/include/linux/netfilter_ipv4/ip_tables.h linux-2.6.30.5-wrt/include/linux/netfilter_ipv4/ip_tables.h
--- linux-2.6.30.5/include/linux/netfilter_ipv4/ip_tables.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/include/linux/netfilter_ipv4/ip_tables.h	2009-09-06 18:43:48.370668913 +0200
@@ -62,6 +62,7 @@
 #define IPT_F_FRAG		0x01	/* Set if rule is a fragment rule */
 #define IPT_F_GOTO		0x02	/* Set if jump is a goto */
 #define IPT_F_MASK		0x03	/* All possible flag bits mask. */
+#define IPT_F_NO_DEF_MATCH	0x80	/* Internal: no default match rules present */
 
 /* Values for "inv" field in struct ipt_ip. */
 #define IPT_INV_VIA_IN		0x01	/* Invert the sense of IN IFACE. */
diff -Nru linux-2.6.30.5/include/linux/netfilter_ipv4/ipt_IMQ.h linux-2.6.30.5-wrt/include/linux/netfilter_ipv4/ipt_IMQ.h
--- linux-2.6.30.5/include/linux/netfilter_ipv4/ipt_IMQ.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/include/linux/netfilter_ipv4/ipt_IMQ.h	2009-09-06 18:43:48.382672077 +0200
@@ -0,0 +1,10 @@
+#ifndef _IPT_IMQ_H
+#define _IPT_IMQ_H
+
+/* Backwards compatibility for old userspace */
+#include <linux/netfilter/xt_IMQ.h>
+
+#define ipt_imq_info xt_imq_info
+
+#endif /* _IPT_IMQ_H */
+
diff -Nru linux-2.6.30.5/include/linux/netfilter_ipv4/ipt_set.h linux-2.6.30.5-wrt/include/linux/netfilter_ipv4/ipt_set.h
--- linux-2.6.30.5/include/linux/netfilter_ipv4/ipt_set.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/include/linux/netfilter_ipv4/ipt_set.h	2009-09-06 18:43:48.374667723 +0200
@@ -0,0 +1,21 @@
+#ifndef _IPT_SET_H
+#define _IPT_SET_H
+
+#include <linux/netfilter_ipv4/ip_set.h>
+
+struct ipt_set_info {
+	ip_set_id_t index;
+	u_int32_t flags[IP_SET_MAX_BINDINGS + 1];
+};
+
+/* match info */
+struct ipt_set_info_match {
+	struct ipt_set_info match_set;
+};
+
+struct ipt_set_info_target {
+	struct ipt_set_info add_set;
+	struct ipt_set_info del_set;
+};
+
+#endif /*_IPT_SET_H*/
diff -Nru linux-2.6.30.5/include/linux/netfilter_ipv6/ip6t_IMQ.h linux-2.6.30.5-wrt/include/linux/netfilter_ipv6/ip6t_IMQ.h
--- linux-2.6.30.5/include/linux/netfilter_ipv6/ip6t_IMQ.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/include/linux/netfilter_ipv6/ip6t_IMQ.h	2009-09-06 18:43:48.382672077 +0200
@@ -0,0 +1,10 @@
+#ifndef _IP6T_IMQ_H
+#define _IP6T_IMQ_H
+
+/* Backwards compatibility for old userspace */
+#include <linux/netfilter/xt_IMQ.h>
+
+#define ip6t_imq_info xt_imq_info
+
+#endif /* _IP6T_IMQ_H */
+
diff -Nru linux-2.6.30.5/include/linux/netfilter_mime.h linux-2.6.30.5-wrt/include/linux/netfilter_mime.h
--- linux-2.6.30.5/include/linux/netfilter_mime.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/include/linux/netfilter_mime.h	2009-09-06 18:43:48.394667414 +0200
@@ -0,0 +1,89 @@
+/*
+ * MIME functions for netfilter modules.  This file provides implementations
+ * for basic MIME parsing.  MIME headers are used in many protocols, such as
+ * HTTP, RTSP, SIP, etc.
+ *
+ * gcc will warn for defined but unused functions, so we only include the
+ * functions requested.  The following macros are used:
+ *   NF_NEED_MIME_NEXTLINE      nf_mime_nextline()
+ */
+#ifndef _NETFILTER_MIME_H
+#define _NETFILTER_MIME_H
+
+/* Only include these functions for kernel code. */
+#ifdef __KERNEL__
+
+#include <linux/ctype.h>
+
+/*
+ * Given a buffer and length, advance to the next line and mark the current
+ * line.  If the current line is empty, *plinelen will be set to zero.  If
+ * not, it will be set to the actual line length (including CRLF).
+ *
+ * 'line' in this context means logical line (includes LWS continuations).
+ * Returns 1 on success, 0 on failure.
+ */
+#ifdef NF_NEED_MIME_NEXTLINE
+static int
+nf_mime_nextline(char* p, uint len, uint* poff, uint* plineoff, uint* plinelen)
+{
+    uint    off = *poff;
+    uint    physlen = 0;
+    int     is_first_line = 1;
+
+    if (off >= len)
+    {
+        return 0;
+    }
+
+    do
+    {
+        while (p[off] != '\n')
+        {
+            if (len-off <= 1)
+            {
+                return 0;
+            }
+
+            physlen++;
+            off++;
+        }
+
+        /* if we saw a crlf, physlen needs adjusted */
+        if (physlen > 0 && p[off] == '\n' && p[off-1] == '\r')
+        {
+            physlen--;
+        }
+
+        /* advance past the newline */
+        off++;
+
+        /* check for an empty line */
+        if (physlen == 0)
+        {
+            break;
+        }
+
+        /* check for colon on the first physical line */
+        if (is_first_line)
+        {
+            is_first_line = 0;
+            if (memchr(p+(*poff), ':', physlen) == NULL)
+            {
+                return 0;
+            }
+        }
+    }
+    while (p[off] == ' ' || p[off] == '\t');
+
+    *plineoff = *poff;
+    *plinelen = (physlen == 0) ? 0 : (off - *poff);
+    *poff = off;
+
+    return 1;
+}
+#endif /* NF_NEED_MIME_NEXTLINE */
+
+#endif /* __KERNEL__ */
+
+#endif /* _NETFILTER_MIME_H */
diff -Nru linux-2.6.30.5/include/linux/pci_ids.h linux-2.6.30.5-wrt/include/linux/pci_ids.h
--- linux-2.6.30.5/include/linux/pci_ids.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/include/linux/pci_ids.h	2009-09-06 18:47:53.767178905 +0200
@@ -2106,6 +2106,7 @@
 #define PCI_DEVICE_ID_TIGON3_5906M	0x1713
 #define PCI_DEVICE_ID_BCM4401		0x4401
 #define PCI_DEVICE_ID_BCM4401B0		0x4402
+#define PCI_DEVICE_ID_BCM4713		0x4713
 
 #define PCI_VENDOR_ID_TOPIC		0x151f
 #define PCI_DEVICE_ID_TOPIC_TP560	0x0000
diff -Nru linux-2.6.30.5/include/linux/phy.h linux-2.6.30.5-wrt/include/linux/phy.h
--- linux-2.6.30.5/include/linux/phy.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/include/linux/phy.h	2009-09-06 18:44:06.779167612 +0200
@@ -325,6 +325,20 @@
 	void (*adjust_link)(struct net_device *dev);
 
 	void (*adjust_state)(struct net_device *dev);
+
+	/*
+	 * By default these point to the original functions
+	 * with the same name. adding them to the phy_device
+	 * allows the phy driver to override them for packet
+	 * mangling if the ethernet driver supports it
+	 * This is required to support some really horrible
+	 * switches such as the Marvell 88E6060
+	 */
+	int (*netif_receive_skb)(struct sk_buff *skb);
+	int (*netif_rx)(struct sk_buff *skb);
+
+	/* alignment offset for packets */
+	int pkt_align;
 };
 #define to_phy_device(d) container_of(d, struct phy_device, dev)
 
@@ -483,6 +497,7 @@
 void phy_stop_machine(struct phy_device *phydev);
 int phy_ethtool_sset(struct phy_device *phydev, struct ethtool_cmd *cmd);
 int phy_ethtool_gset(struct phy_device *phydev, struct ethtool_cmd *cmd);
+int phy_ethtool_ioctl(struct phy_device *phydev, void *useraddr);
 int phy_mii_ioctl(struct phy_device *phydev,
 		struct mii_ioctl_data *mii_data, int cmd);
 int phy_start_interrupts(struct phy_device *phydev);
diff -Nru linux-2.6.30.5/include/linux/pkt_sched.h linux-2.6.30.5-wrt/include/linux/pkt_sched.h
--- linux-2.6.30.5/include/linux/pkt_sched.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/include/linux/pkt_sched.h	2009-09-06 18:43:48.402669044 +0200
@@ -182,8 +182,37 @@
  *
  *	The only reason for this is efficiency, it is possible
  *	to change these parameters in compile time.
+ *
+ *	If you need to play with these values, use esfq instead.
  */
 
+/* ESFQ section */
+
+enum
+{
+        /* traditional */
+	TCA_SFQ_HASH_CLASSIC,
+	TCA_SFQ_HASH_DST,
+	TCA_SFQ_HASH_SRC,
+	TCA_SFQ_HASH_FWMARK,
+	/* conntrack */
+	TCA_SFQ_HASH_CTORIGDST,
+	TCA_SFQ_HASH_CTORIGSRC,
+	TCA_SFQ_HASH_CTREPLDST,
+	TCA_SFQ_HASH_CTREPLSRC,
+	TCA_SFQ_HASH_CTNATCHG,
+};
+
+struct tc_esfq_qopt
+{
+	unsigned	quantum;	/* Bytes per round allocated to flow */
+	int		perturb_period;	/* Period of hash perturbation */
+	__u32		limit;		/* Maximal packets in queue */
+	unsigned	divisor;	/* Hash divisor  */
+	unsigned	flows;		/* Maximal number of flows  */
+	unsigned	hash_kind;	/* Hash function to use for flow identification */
+};
+
 /* RED section */
 
 enum
diff -Nru linux-2.6.30.5/include/linux/random.h linux-2.6.30.5-wrt/include/linux/random.h
--- linux-2.6.30.5/include/linux/random.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/include/linux/random.h	2009-09-06 18:44:06.835168037 +0200
@@ -34,6 +34,30 @@
 /* Clear the entropy pool and associated counters.  (Superuser only.) */
 #define RNDCLEARPOOL	_IO( 'R', 0x06 )
 
+#ifdef CONFIG_FIPS_RNG
+
+/* Size of seed value - equal to AES blocksize */
+#define AES_BLOCK_SIZE_BYTES	16
+#define SEED_SIZE_BYTES			AES_BLOCK_SIZE_BYTES
+/* Size of AES key */
+#define KEY_SIZE_BYTES		16
+
+/* ioctl() structure used by FIPS 140-2 Tests */
+struct rand_fips_test {
+	unsigned char key[KEY_SIZE_BYTES];			/* Input */
+	unsigned char datetime[SEED_SIZE_BYTES];	/* Input */
+	unsigned char seed[SEED_SIZE_BYTES];		/* Input */
+	unsigned char result[SEED_SIZE_BYTES];		/* Output */
+};
+
+/* FIPS 140-2 RNG Variable Seed Test. (Superuser only.) */
+#define RNDFIPSVST	_IOWR('R', 0x10, struct rand_fips_test)
+
+/* FIPS 140-2 RNG Monte Carlo Test. (Superuser only.) */
+#define RNDFIPSMCT	_IOWR('R', 0x11, struct rand_fips_test)
+
+#endif /* #ifdef CONFIG_FIPS_RNG */
+
 struct rand_pool_info {
 	int	entropy_count;
 	int	buf_size;
@@ -50,6 +74,10 @@
 				 unsigned int value);
 extern void add_interrupt_randomness(int irq);
 
+extern void random_input_words(__u32 *buf, size_t wordcount, int ent_count);
+extern int random_input_wait(void);
+#define HAS_RANDOM_INPUT_WAIT 1
+
 extern void get_random_bytes(void *buf, int nbytes);
 void generate_random_uuid(unsigned char uuid_out[16]);
 
diff -Nru linux-2.6.30.5/include/linux/skbuff.h linux-2.6.30.5-wrt/include/linux/skbuff.h
--- linux-2.6.30.5/include/linux/skbuff.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/include/linux/skbuff.h	2009-09-06 18:44:06.815168492 +0200
@@ -28,6 +28,9 @@
 #include <linux/rcupdate.h>
 #include <linux/dmaengine.h>
 #include <linux/hrtimer.h>
+#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
+#include <linux/imq.h>
+#endif
 
 /* Don't change this without changing skb_csum_unnecessary! */
 #define CHECKSUM_NONE 0
@@ -333,6 +336,9 @@
 	 * first. This is owned by whoever has the skb queued ATM.
 	 */
 	char			cb[48];
+#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
+	void			*cb_next;
+#endif
 
 	unsigned int		len,
 				data_len;
@@ -363,6 +369,9 @@
 	struct nf_conntrack	*nfct;
 	struct sk_buff		*nfct_reasm;
 #endif
+#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
+	struct nf_queue_entry	*nf_queue_entry;
+#endif
 #ifdef CONFIG_BRIDGE_NETFILTER
 	struct nf_bridge_info	*nf_bridge;
 #endif
@@ -378,11 +387,14 @@
 #ifdef CONFIG_IPV6_NDISC_NODETYPE
 	__u8			ndisc_nodetype:2;
 #endif
-#if defined(CONFIG_MAC80211) || defined(CONFIG_MAC80211_MODULE)
+#if 1
 	__u8			do_not_encrypt:1;
 	__u8			requeue:1;
 #endif
 	/* 0/13/14 bit hole */
+#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
+	__u8			imq_flags:IMQ_F_BITS;
+#endif
 
 #ifdef CONFIG_NET_DMA
 	dma_cookie_t		dma_cookie;
@@ -423,6 +435,12 @@
 			  enum dma_data_direction dir);
 #endif
 
+
+#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
+extern int skb_save_cb(struct sk_buff *skb);
+extern int skb_restore_cb(struct sk_buff *skb);
+#endif
+
 extern void kfree_skb(struct sk_buff *skb);
 extern void consume_skb(struct sk_buff *skb);
 extern void	       __kfree_skb(struct sk_buff *skb);
@@ -1351,11 +1369,18 @@
  *
  * Various parts of the networking layer expect at least 32 bytes of
  * headroom, you should not reduce this.
+ *
+ * This has been changed to 64 to acommodate for routing between ethernet
+ * and wireless, but only for new allocations
  */
 #ifndef NET_SKB_PAD
 #define NET_SKB_PAD	32
 #endif
 
+#ifndef NET_SKB_PAD_ALLOC
+#define NET_SKB_PAD_ALLOC	64
+#endif
+
 extern int ___pskb_trim(struct sk_buff *skb, unsigned int len);
 
 static inline void __skb_trim(struct sk_buff *skb, unsigned int len)
@@ -1445,9 +1470,9 @@
 static inline struct sk_buff *__dev_alloc_skb(unsigned int length,
 					      gfp_t gfp_mask)
 {
-	struct sk_buff *skb = alloc_skb(length + NET_SKB_PAD, gfp_mask);
+	struct sk_buff *skb = alloc_skb(length + NET_SKB_PAD_ALLOC, gfp_mask);
 	if (likely(skb))
-		skb_reserve(skb, NET_SKB_PAD);
+		skb_reserve(skb, NET_SKB_PAD_ALLOC);
 	return skb;
 }
 
@@ -1520,7 +1545,7 @@
 		delta = headroom - skb_headroom(skb);
 
 	if (delta || cloned)
-		return pskb_expand_head(skb, ALIGN(delta, NET_SKB_PAD), 0,
+		return pskb_expand_head(skb, ALIGN(delta, NET_SKB_PAD_ALLOC), 0,
 					GFP_ATOMIC);
 	return 0;
 }
@@ -1931,6 +1956,10 @@
 	dst->nfct_reasm = src->nfct_reasm;
 	nf_conntrack_get_reasm(src->nfct_reasm);
 #endif
+#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
+	dst->imq_flags = src->imq_flags;
+	dst->nf_queue_entry = src->nf_queue_entry;
+#endif
 #ifdef CONFIG_BRIDGE_NETFILTER
 	dst->nf_bridge  = src->nf_bridge;
 	nf_bridge_get(src->nf_bridge);
diff -Nru linux-2.6.30.5/include/linux/slab.h linux-2.6.30.5-wrt/include/linux/slab.h
--- linux-2.6.30.5/include/linux/slab.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/include/linux/slab.h	2009-09-06 18:43:48.406667725 +0200
@@ -115,8 +115,8 @@
  * to do various tricks to work around compiler limitations in order to
  * ensure proper constant folding.
  */
-#define KMALLOC_SHIFT_HIGH	((MAX_ORDER + PAGE_SHIFT - 1) <= 25 ? \
-				(MAX_ORDER + PAGE_SHIFT - 1) : 25)
+#define KMALLOC_SHIFT_HIGH	((MAX_ORDER + PAGE_SHIFT - 1) <= 17 ? \
+				(MAX_ORDER + PAGE_SHIFT - 1) : 17)
 
 #define KMALLOC_MAX_SIZE	(1UL << KMALLOC_SHIFT_HIGH)
 #define KMALLOC_MAX_ORDER	(KMALLOC_SHIFT_HIGH - PAGE_SHIFT)
diff -Nru linux-2.6.30.5/include/linux/spi/spi_gpio_old.h linux-2.6.30.5-wrt/include/linux/spi/spi_gpio_old.h
--- linux-2.6.30.5/include/linux/spi/spi_gpio_old.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/include/linux/spi/spi_gpio_old.h	2009-09-06 18:44:06.807166783 +0200
@@ -0,0 +1,73 @@
+/*
+ * spi_gpio interface to platform code
+ *
+ * Copyright (c) 2008 Piotr Skamruk
+ * Copyright (c) 2008 Michael Buesch
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _LINUX_SPI_SPI_GPIO
+#define _LINUX_SPI_SPI_GPIO
+
+#include <linux/types.h>
+#include <linux/spi/spi.h>
+
+
+/**
+ * struct spi_gpio_platform_data - Data definitions for a SPI-GPIO device.
+ *
+ * This structure holds information about a GPIO-based SPI device.
+ *
+ * @pin_clk: The GPIO pin number of the CLOCK pin.
+ *
+ * @pin_miso: The GPIO pin number of the MISO pin.
+ *
+ * @pin_mosi: The GPIO pin number of the MOSI pin.
+ *
+ * @pin_cs: The GPIO pin number of the CHIPSELECT pin.
+ *
+ * @cs_activelow: If true, the chip is selected when the CS line is low.
+ *
+ * @no_spi_delay: If true, no delay is done in the lowlevel bitbanging.
+ *                Note that doing no delay is not standards compliant,
+ *                but it might be needed to speed up transfers on some
+ *                slow embedded machines.
+ *
+ * @boardinfo_setup: This callback is called after the
+ *                   SPI master device was registered, but before the
+ *                   device is registered.
+ * @boardinfo_setup_data: Data argument passed to boardinfo_setup().
+ */
+struct spi_gpio_platform_data {
+	unsigned int pin_clk;
+	unsigned int pin_miso;
+	unsigned int pin_mosi;
+	unsigned int pin_cs;
+	bool cs_activelow;
+	bool no_spi_delay;
+	int (*boardinfo_setup)(struct spi_board_info *bi,
+			       struct spi_master *master,
+			       void *data);
+	void *boardinfo_setup_data;
+};
+
+/**
+ * SPI_GPIO_PLATDEV_NAME - The platform device name string.
+ *
+ * The name string that has to be used for platform_device_alloc
+ * when allocating a spi-gpio device.
+ */
+#define SPI_GPIO_PLATDEV_NAME	"spi-gpio"
+
+/**
+ * spi_gpio_next_id - Get another platform device ID number.
+ *
+ * This returns the next platform device ID number that has to be used
+ * for platform_device_alloc. The ID is opaque and should not be used for
+ * anything else.
+ */
+int spi_gpio_next_id(void);
+
+#endif /* _LINUX_SPI_SPI_GPIO */
diff -Nru linux-2.6.30.5/include/linux/stddef.h linux-2.6.30.5-wrt/include/linux/stddef.h
--- linux-2.6.30.5/include/linux/stddef.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/include/linux/stddef.h	2009-09-06 18:44:06.803167207 +0200
@@ -16,6 +16,7 @@
 	false	= 0,
 	true	= 1
 };
+#endif /* __KERNEL__ */
 
 #undef offsetof
 #ifdef __compiler_offsetof
@@ -23,6 +24,5 @@
 #else
 #define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
 #endif
-#endif /* __KERNEL__ */
 
 #endif
diff -Nru linux-2.6.30.5/include/mtd/mtd-abi.h linux-2.6.30.5-wrt/include/mtd/mtd-abi.h
--- linux-2.6.30.5/include/mtd/mtd-abi.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/include/mtd/mtd-abi.h	2009-09-06 18:43:48.350677830 +0200
@@ -95,6 +95,7 @@
 #define ECCGETLAYOUT		_IOR('M', 17, struct nand_ecclayout)
 #define ECCGETSTATS		_IOR('M', 18, struct mtd_ecc_stats)
 #define MTDFILEMODE		_IO('M', 19)
+#define MTDREFRESH		_IO('M', 23)
 
 /*
  * Obsolete legacy interface. Keep it in order not to break userspace
diff -Nru linux-2.6.30.5/include/net/netfilter/nf_conntrack.h linux-2.6.30.5-wrt/include/net/netfilter/nf_conntrack.h
--- linux-2.6.30.5/include/net/netfilter/nf_conntrack.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/include/net/netfilter/nf_conntrack.h	2009-09-06 18:43:48.362668493 +0200
@@ -117,6 +117,22 @@
 	u_int32_t secmark;
 #endif
 
+#if defined(CONFIG_NETFILTER_XT_MATCH_LAYER7) || \
+    defined(CONFIG_NETFILTER_XT_MATCH_LAYER7_MODULE)
+	struct {
+		/*
+		 * e.g. "http". NULL before decision. "unknown" after decision
+		 * if no match.
+		 */
+		char *app_proto;
+		/*
+		 * application layer data so far. NULL after match decision.
+		 */
+		char *app_data;
+		unsigned int app_data_len;
+	} layer7;
+#endif
+
 	/* Storage reserved for other modules: */
 	union nf_conntrack_proto proto;
 
diff -Nru linux-2.6.30.5/include/net/netfilter/nf_queue.h linux-2.6.30.5-wrt/include/net/netfilter/nf_queue.h
--- linux-2.6.30.5/include/net/netfilter/nf_queue.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/include/net/netfilter/nf_queue.h	2009-09-06 18:43:48.390666560 +0200
@@ -13,6 +13,12 @@
 	struct net_device	*indev;
 	struct net_device	*outdev;
 	int			(*okfn)(struct sk_buff *);
+
+#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
+	int			(*next_outfn)(struct nf_queue_entry *entry,
+					      unsigned int queuenum);
+	unsigned int		next_queuenum;
+#endif
 };
 
 #define nf_queue_entry_reroute(x) ((void *)x + sizeof(struct nf_queue_entry))
@@ -30,5 +36,11 @@
 				       const struct nf_queue_handler *qh);
 extern void nf_unregister_queue_handlers(const struct nf_queue_handler *qh);
 extern void nf_reinject(struct nf_queue_entry *entry, unsigned int verdict);
+extern void nf_queue_entry_release_refs(struct nf_queue_entry *entry);
+
+#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
+extern void nf_register_queue_imq_handler(const struct nf_queue_handler *qh);
+extern void nf_unregister_queue_imq_handler(void);
+#endif
 
 #endif /* _NF_QUEUE_H */
diff -Nru linux-2.6.30.5/init/main.c linux-2.6.30.5-wrt/init/main.c
--- linux-2.6.30.5/init/main.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/init/main.c	2009-09-07 00:48:21.235678762 +0200
@@ -811,7 +811,7 @@
 	numa_default_policy();
 
 	if (sys_open((const char __user *) "/dev/console", O_RDWR, 0) < 0)
-		printk(KERN_WARNING "Warning: unable to open an initial console.\n");
+		printk(KERN_WARNING "Please be patient, while OpenWrt loads ...\n");
 
 	(void) sys_dup(0);
 	(void) sys_dup(0);
@@ -835,9 +835,8 @@
 		printk(KERN_WARNING "Failed to execute %s.  Attempting "
 					"defaults...\n", execute_command);
 	}
+	run_init_process("/etc/preinit");
 	run_init_process("/sbin/init");
-	run_init_process("/etc/init");
-	run_init_process("/bin/init");
 	run_init_process("/bin/sh");
 
 	panic("No init found.  Try passing init= option to kernel.");
diff -Nru linux-2.6.30.5/kernel/exit.c linux-2.6.30.5-wrt/kernel/exit.c
--- linux-2.6.30.5/kernel/exit.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/kernel/exit.c	2009-09-06 18:44:12.063168773 +0200
@@ -508,6 +508,7 @@
 
 	return files;
 }
+EXPORT_SYMBOL_GPL(get_files_struct);
 
 void put_files_struct(struct files_struct *files)
 {
@@ -527,6 +528,7 @@
 		free_fdtable(fdt);
 	}
 }
+EXPORT_SYMBOL_GPL(put_files_struct);
 
 void reset_files_struct(struct files_struct *files)
 {
diff -Nru linux-2.6.30.5/kernel/fork.c linux-2.6.30.5-wrt/kernel/fork.c
--- linux-2.6.30.5/kernel/fork.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/kernel/fork.c	2009-09-06 18:44:12.063168773 +0200
@@ -160,6 +160,7 @@
 	if (!profile_handoff_task(tsk))
 		free_task(tsk);
 }
+EXPORT_SYMBOL_GPL(__put_task_struct);
 
 /*
  * macro override instead of weak attribute alias, to workaround
diff -Nru linux-2.6.30.5/kernel/sched.c linux-2.6.30.5-wrt/kernel/sched.c
--- linux-2.6.30.5/kernel/sched.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/kernel/sched.c	2009-09-06 18:44:12.063168773 +0200
@@ -5666,6 +5666,7 @@
 	return (nice_rlim <= p->signal->rlim[RLIMIT_NICE].rlim_cur ||
 		capable(CAP_SYS_NICE));
 }
+EXPORT_SYMBOL_GPL(can_nice);
 
 #ifdef __ARCH_WANT_SYS_NICE
 
diff -Nru linux-2.6.30.5/kernel/signal.c linux-2.6.30.5-wrt/kernel/signal.c
--- linux-2.6.30.5/kernel/signal.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/kernel/signal.c	2009-09-06 18:44:12.067169104 +0200
@@ -1053,6 +1053,7 @@
 
 	return sighand;
 }
+EXPORT_SYMBOL(lock_task_sighand);
 
 /*
  * send signal info to all the members of a group
diff -Nru linux-2.6.30.5/lib/Kconfig linux-2.6.30.5-wrt/lib/Kconfig
--- linux-2.6.30.5/lib/Kconfig	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/lib/Kconfig	2009-09-06 18:44:12.034667436 +0200
@@ -142,16 +142,16 @@
 # Textsearch support is select'ed if needed
 #
 config TEXTSEARCH
-	boolean
+	boolean	"Textsearch support"
 
 config TEXTSEARCH_KMP
-	tristate
+	tristate "Textsearch KMP"
 
 config TEXTSEARCH_BM
-	tristate
+	tristate "Textsearch BM"
 
 config TEXTSEARCH_FSM
-	tristate
+	tristate "Textsearch FSM"
 
 config HAS_IOMEM
 	boolean
diff -Nru linux-2.6.30.5/lib/decompress.c linux-2.6.30.5-wrt/lib/decompress.c
--- linux-2.6.30.5/lib/decompress.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/lib/decompress.c	2009-09-06 18:44:12.075167378 +0200
@@ -32,6 +32,7 @@
 	{ {037, 0236}, "gzip", gunzip },
 	{ {0x42, 0x5a}, "bzip2", bunzip2 },
 	{ {0x5d, 0x00}, "lzma", unlzma },
+	{ {0x6d, 0x00}, "lzma-openwrt", unlzma },
 	{ {0, 0}, NULL, NULL }
 };
 
diff -Nru linux-2.6.30.5/lib/kobject_uevent.c linux-2.6.30.5-wrt/lib/kobject_uevent.c
--- linux-2.6.30.5/lib/kobject_uevent.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/lib/kobject_uevent.c	2009-09-06 18:43:48.434699261 +0200
@@ -29,7 +29,8 @@
 char uevent_helper[UEVENT_HELPER_PATH_LEN] = CONFIG_UEVENT_HELPER_PATH;
 static DEFINE_SPINLOCK(sequence_lock);
 #if defined(CONFIG_NET)
-static struct sock *uevent_sock;
+struct sock *uevent_sock = NULL;
+EXPORT_SYMBOL_GPL(uevent_sock);
 #endif
 
 /* the strings here must match the enum in include/linux/kobject.h */
@@ -42,6 +43,18 @@
 	[KOBJ_OFFLINE] =	"offline",
 };
 
+u64 uevent_next_seqnum(void)
+{
+	u64 seq;
+
+	spin_lock(&sequence_lock);
+	seq = ++uevent_seqnum;
+	spin_unlock(&sequence_lock);
+
+	return seq;
+}
+EXPORT_SYMBOL_GPL(uevent_next_seqnum);
+
 /**
  * kobject_action_type - translate action string to numeric type
  *
@@ -201,9 +214,7 @@
 		kobj->state_remove_uevent_sent = 1;
 
 	/* we will send an event, so request a new sequence number */
-	spin_lock(&sequence_lock);
-	seq = ++uevent_seqnum;
-	spin_unlock(&sequence_lock);
+	seq = uevent_next_seqnum();
 	retval = add_uevent_var(env, "SEQNUM=%llu", (unsigned long long)seq);
 	if (retval)
 		goto exit;
diff -Nru linux-2.6.30.5/mm/memory.c linux-2.6.30.5-wrt/mm/memory.c
--- linux-2.6.30.5/mm/memory.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/mm/memory.c	2009-09-06 18:44:12.067169104 +0200
@@ -1063,6 +1063,7 @@
 		tlb_finish_mmu(tlb, address, end);
 	return end;
 }
+EXPORT_SYMBOL_GPL(zap_page_range);
 
 /**
  * zap_vma_ptes - remove ptes mapping the vma
@@ -2438,6 +2439,7 @@
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(vmtruncate_range);
 
 /*
  * We enter with non-exclusive mmap_sem (to exclude vma changes,
diff -Nru linux-2.6.30.5/mm/shmem.c linux-2.6.30.5-wrt/mm/shmem.c
--- linux-2.6.30.5/mm/shmem.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/mm/shmem.c	2009-09-06 18:44:12.042666084 +0200
@@ -2606,6 +2606,16 @@
 
 /* common code */
 
+void shmem_set_file(struct vm_area_struct *vma, struct file *file)
+{
+	ima_shm_check(file);
+	if (vma->vm_file)
+		fput(vma->vm_file);
+	vma->vm_file = file;
+	vma->vm_ops = &shmem_vm_ops;
+}
+EXPORT_SYMBOL_GPL(shmem_set_file);
+
 /**
  * shmem_file_setup - get an unlinked file living in tmpfs
  * @name: name for dentry (to be seen in /proc/<pid>/maps
@@ -2684,11 +2694,7 @@
 	if (IS_ERR(file))
 		return PTR_ERR(file);
 
-	ima_shm_check(file);
-	if (vma->vm_file)
-		fput(vma->vm_file);
-	vma->vm_file = file;
-	vma->vm_ops = &shmem_vm_ops;
+	shmem_set_file(vma, file);
 	return 0;
 }
 
diff -Nru linux-2.6.30.5/mm/vmalloc.c linux-2.6.30.5-wrt/mm/vmalloc.c
--- linux-2.6.30.5/mm/vmalloc.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/mm/vmalloc.c	2009-09-06 18:44:12.067169104 +0200
@@ -1101,6 +1101,7 @@
 	vunmap_page_range(addr, end);
 	flush_tlb_kernel_range(addr, end);
 }
+EXPORT_SYMBOL_GPL(unmap_kernel_range);
 
 int map_vm_area(struct vm_struct *area, pgprot_t prot, struct page ***pages)
 {
@@ -1214,6 +1215,7 @@
 	return __get_vm_area_node(size, flags, VMALLOC_START, VMALLOC_END,
 				-1, GFP_KERNEL, __builtin_return_address(0));
 }
+EXPORT_SYMBOL_GPL(get_vm_area);
 
 struct vm_struct *get_vm_area_caller(unsigned long size, unsigned long flags,
 				void *caller)
diff -Nru linux-2.6.30.5/net/core/dev.c linux-2.6.30.5-wrt/net/core/dev.c
--- linux-2.6.30.5/net/core/dev.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/net/core/dev.c	2009-09-06 18:43:48.386669749 +0200
@@ -96,6 +96,9 @@
 #include <net/net_namespace.h>
 #include <net/sock.h>
 #include <linux/rtnetlink.h>
+#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
+#include <linux/imq.h>
+#endif
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 #include <linux/stat.h>
@@ -1678,7 +1681,11 @@
 	int rc;
 
 	if (likely(!skb->next)) {
-		if (!list_empty(&ptype_all))
+		if (!list_empty(&ptype_all)
+#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
+		    && !(skb->imq_flags & IMQ_F_ENQUEUE)
+#endif
+		    )
 			dev_queue_xmit_nit(skb, dev);
 
 		if (netif_needs_gso(dev, skb)) {
@@ -1749,8 +1756,7 @@
 }
 EXPORT_SYMBOL(skb_tx_hash);
 
-static struct netdev_queue *dev_pick_tx(struct net_device *dev,
-					struct sk_buff *skb)
+struct netdev_queue *dev_pick_tx(struct net_device *dev, struct sk_buff *skb)
 {
 	const struct net_device_ops *ops = dev->netdev_ops;
 	u16 queue_index = 0;
@@ -1763,6 +1769,7 @@
 	skb_set_queue_mapping(skb, queue_index);
 	return netdev_get_tx_queue(dev, queue_index);
 }
+EXPORT_SYMBOL(dev_pick_tx);
 
 /**
  *	dev_queue_xmit - transmit a buffer
diff -Nru linux-2.6.30.5/net/core/skbuff.c linux-2.6.30.5-wrt/net/core/skbuff.c
--- linux-2.6.30.5/net/core/skbuff.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/net/core/skbuff.c	2009-09-06 18:43:48.410667457 +0200
@@ -71,6 +71,9 @@
 
 static struct kmem_cache *skbuff_head_cache __read_mostly;
 static struct kmem_cache *skbuff_fclone_cache __read_mostly;
+#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
+static struct kmem_cache *skbuff_cb_store_cache __read_mostly;
+#endif
 
 static void sock_pipe_buf_release(struct pipe_inode_info *pipe,
 				  struct pipe_buffer *buf)
@@ -90,6 +93,80 @@
 	return 1;
 }
 
+#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
+/* Control buffer save/restore for IMQ devices */
+struct skb_cb_table {
+	void			*cb_next;
+	atomic_t		refcnt;
+	char      		cb[48];
+};
+
+static DEFINE_SPINLOCK(skb_cb_store_lock);
+
+int skb_save_cb(struct sk_buff *skb)
+{
+	struct skb_cb_table *next;
+
+	next = kmem_cache_alloc(skbuff_cb_store_cache, GFP_ATOMIC);
+	if (!next)
+		return -ENOMEM;
+
+	BUILD_BUG_ON(sizeof(skb->cb) != sizeof(next->cb));
+
+	memcpy(next->cb, skb->cb, sizeof(skb->cb));
+	next->cb_next = skb->cb_next;
+
+	atomic_set(&next->refcnt, 1);
+
+	skb->cb_next = next;
+	return 0;
+}
+EXPORT_SYMBOL(skb_save_cb);
+
+int skb_restore_cb(struct sk_buff *skb)
+{
+	struct skb_cb_table *next;
+
+	if (!skb->cb_next)
+		return 0;
+
+	next = skb->cb_next;
+
+	BUILD_BUG_ON(sizeof(skb->cb) != sizeof(next->cb));
+
+	memcpy(skb->cb, next->cb, sizeof(skb->cb));
+	skb->cb_next = next->cb_next;
+
+	spin_lock(&skb_cb_store_lock);
+
+	if (atomic_dec_and_test(&next->refcnt)) {
+		kmem_cache_free(skbuff_cb_store_cache, next);
+	}
+
+	spin_unlock(&skb_cb_store_lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(skb_restore_cb);
+
+static void skb_copy_stored_cb(struct sk_buff *new, struct sk_buff *old)
+{
+	struct skb_cb_table *next;
+
+	if (!old->cb_next) {
+		new->cb_next = 0;
+		return;
+	}
+
+	spin_lock(&skb_cb_store_lock);
+
+	next = old->cb_next;
+	atomic_inc(&next->refcnt);
+	new->cb_next = next;
+
+	spin_unlock(&skb_cb_store_lock);
+}
+#endif
 
 /* Pipe buffer operations for a socket. */
 static struct pipe_buf_operations sock_pipe_buf_ops = {
@@ -250,9 +327,9 @@
 	int node = dev->dev.parent ? dev_to_node(dev->dev.parent) : -1;
 	struct sk_buff *skb;
 
-	skb = __alloc_skb(length + NET_SKB_PAD, gfp_mask, 0, node);
+	skb = __alloc_skb(length + NET_SKB_PAD_ALLOC, gfp_mask, 0, node);
 	if (likely(skb)) {
-		skb_reserve(skb, NET_SKB_PAD);
+		skb_reserve(skb, NET_SKB_PAD_ALLOC);
 		skb->dev = dev;
 	}
 	return skb;
@@ -389,6 +466,15 @@
 		WARN_ON(in_irq());
 		skb->destructor(skb);
 	}
+#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
+	/* This should not happen. When it does, avoid memleak by restoring
+	the chain of cb-backups. */
+	while(skb->cb_next != NULL) {
+		printk(KERN_WARNING "kfree_skb: skb->cb_next: %08x\n",
+			skb->cb_next);
+		skb_restore_cb(skb);
+	}
+#endif
 #if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
 	nf_conntrack_put(skb->nfct);
 	nf_conntrack_put_reasm(skb->nfct_reasm);
@@ -526,6 +612,9 @@
 	new->sp			= secpath_get(old->sp);
 #endif
 	memcpy(new->cb, old->cb, sizeof(old->cb));
+#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
+	skb_copy_stored_cb(new, old);
+#endif
 	new->csum_start		= old->csum_start;
 	new->csum_offset	= old->csum_offset;
 	new->local_df		= old->local_df;
@@ -2769,6 +2858,13 @@
 						0,
 						SLAB_HWCACHE_ALIGN|SLAB_PANIC,
 						NULL);
+#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
+	skbuff_cb_store_cache = kmem_cache_create("skbuff_cb_store_cache",
+						  sizeof(struct skb_cb_table),
+						  0,
+						  SLAB_HWCACHE_ALIGN|SLAB_PANIC,
+						  NULL);
+#endif
 }
 
 /**
diff -Nru linux-2.6.30.5/net/ipv4/netfilter/Kconfig linux-2.6.30.5-wrt/net/ipv4/netfilter/Kconfig
--- linux-2.6.30.5/net/ipv4/netfilter/Kconfig	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/net/ipv4/netfilter/Kconfig	2009-09-06 18:43:48.398678472 +0200
@@ -257,6 +257,11 @@
 	depends on NF_CONNTRACK && NF_NAT
 	default NF_NAT && NF_CONNTRACK_IRC
 
+config NF_NAT_RTSP
+	tristate
+ 	depends on IP_NF_IPTABLES && NF_CONNTRACK && NF_NAT
+ 	default NF_NAT && NF_CONNTRACK_RTSP
+
 config NF_NAT_TFTP
 	tristate
 	depends on NF_CONNTRACK && NF_NAT
@@ -388,5 +393,122 @@
 
 endif # IP_NF_ARPTABLES
 
+config IP_NF_SET
+	tristate "IP set support"
+	depends on INET && NETFILTER
+	help
+	  This option adds IP set support to the kernel.
+	  In order to define and use sets, you need the userspace utility
+	  ipset(8).
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
+config IP_NF_SET_MAX
+	int "Maximum number of IP sets"
+	default 256
+	range 2 65534
+	depends on IP_NF_SET
+	help
+	  You can define here default value of the maximum number 
+	  of IP sets for the kernel.
+
+	  The value can be overriden by the 'max_sets' module
+	  parameter of the 'ip_set' module.
+
+config IP_NF_SET_HASHSIZE
+	int "Hash size for bindings of IP sets"
+	default 1024
+	depends on IP_NF_SET
+	help
+	  You can define here default value of the hash size for
+	  bindings of IP sets.
+
+	  The value can be overriden by the 'hash_size' module
+	  parameter of the 'ip_set' module.
+
+config IP_NF_SET_IPMAP
+	tristate "ipmap set support"
+	depends on IP_NF_SET
+	help
+	  This option adds the ipmap set type support.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
+config IP_NF_SET_MACIPMAP
+	tristate "macipmap set support"
+	depends on IP_NF_SET
+	help
+	  This option adds the macipmap set type support.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
+config IP_NF_SET_PORTMAP
+	tristate "portmap set support"
+	depends on IP_NF_SET
+	help
+	  This option adds the portmap set type support.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
+config IP_NF_SET_IPHASH
+	tristate "iphash set support"
+	depends on IP_NF_SET
+	help
+	  This option adds the iphash set type support.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
+config IP_NF_SET_NETHASH
+	tristate "nethash set support"
+	depends on IP_NF_SET
+	help
+	  This option adds the nethash set type support.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
+config IP_NF_SET_IPPORTHASH
+	tristate "ipporthash set support"
+	depends on IP_NF_SET
+	help
+	  This option adds the ipporthash set type support.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
+config IP_NF_SET_IPTREE
+	tristate "iptree set support"
+	depends on IP_NF_SET
+	help
+	  This option adds the iptree set type support.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
+config IP_NF_SET_IPTREEMAP
+	tristate "iptreemap set support"
+	depends on IP_NF_SET
+	help
+	  This option adds the iptreemap set type support.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
+config IP_NF_MATCH_SET
+	tristate "set match support"
+	depends on IP_NF_SET
+	help
+	  Set matching matches against given IP sets.
+	  You need the ipset utility to create and set up the sets.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
+config IP_NF_TARGET_SET
+	tristate "SET target support"
+	depends on IP_NF_SET
+	help
+	  The SET target makes possible to add/delete entries
+	  in IP sets.
+	  You need the ipset utility to create and set up the sets.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
+
 endmenu
 
diff -Nru linux-2.6.30.5/net/ipv4/netfilter/Makefile linux-2.6.30.5-wrt/net/ipv4/netfilter/Makefile
--- linux-2.6.30.5/net/ipv4/netfilter/Makefile	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/net/ipv4/netfilter/Makefile	2009-09-06 18:43:48.394667414 +0200
@@ -26,6 +26,7 @@
 obj-$(CONFIG_NF_NAT_FTP) += nf_nat_ftp.o
 obj-$(CONFIG_NF_NAT_H323) += nf_nat_h323.o
 obj-$(CONFIG_NF_NAT_IRC) += nf_nat_irc.o
+obj-$(CONFIG_NF_NAT_RTSP) += nf_nat_rtsp.o
 obj-$(CONFIG_NF_NAT_PPTP) += nf_nat_pptp.o
 obj-$(CONFIG_NF_NAT_SIP) += nf_nat_sip.o
 obj-$(CONFIG_NF_NAT_SNMP_BASIC) += nf_nat_snmp_basic.o
@@ -51,6 +52,7 @@
 obj-$(CONFIG_IP_NF_MATCH_ADDRTYPE) += ipt_addrtype.o
 obj-$(CONFIG_IP_NF_MATCH_AH) += ipt_ah.o
 obj-$(CONFIG_IP_NF_MATCH_ECN) += ipt_ecn.o
+obj-$(CONFIG_IP_NF_MATCH_SET) += ipt_set.o
 
 # targets
 obj-$(CONFIG_IP_NF_TARGET_CLUSTERIP) += ipt_CLUSTERIP.o
@@ -61,6 +63,18 @@
 obj-$(CONFIG_IP_NF_TARGET_REDIRECT) += ipt_REDIRECT.o
 obj-$(CONFIG_IP_NF_TARGET_REJECT) += ipt_REJECT.o
 obj-$(CONFIG_IP_NF_TARGET_ULOG) += ipt_ULOG.o
+obj-$(CONFIG_IP_NF_TARGET_SET) += ipt_SET.o
+
+# sets
+obj-$(CONFIG_IP_NF_SET) += ip_set.o
+obj-$(CONFIG_IP_NF_SET_IPMAP) += ip_set_ipmap.o
+obj-$(CONFIG_IP_NF_SET_PORTMAP) += ip_set_portmap.o
+obj-$(CONFIG_IP_NF_SET_MACIPMAP) += ip_set_macipmap.o
+obj-$(CONFIG_IP_NF_SET_IPHASH) += ip_set_iphash.o
+obj-$(CONFIG_IP_NF_SET_NETHASH) += ip_set_nethash.o
+obj-$(CONFIG_IP_NF_SET_IPPORTHASH) += ip_set_ipporthash.o
+obj-$(CONFIG_IP_NF_SET_IPTREE) += ip_set_iptree.o
+obj-$(CONFIG_IP_NF_SET_IPTREEMAP) += ip_set_iptreemap.o
 
 # generic ARP tables
 obj-$(CONFIG_IP_NF_ARPTABLES) += arp_tables.o
diff -Nru linux-2.6.30.5/net/ipv4/netfilter/ip_set.c linux-2.6.30.5-wrt/net/ipv4/netfilter/ip_set.c
--- linux-2.6.30.5/net/ipv4/netfilter/ip_set.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/net/ipv4/netfilter/ip_set.c	2009-09-06 18:43:48.374667723 +0200
@@ -0,0 +1,2003 @@
+/* Copyright (C) 2000-2002 Joakim Axelsson <gozem@linux.nu>
+ *                         Patrick Schaaf <bof@bof.de>
+ * Copyright (C) 2003-2004 Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/* Kernel module for IP set management */
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+#include <linux/config.h>
+#endif
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kmod.h>
+#include <linux/ip.h>
+#include <linux/skbuff.h>
+#include <linux/random.h>
+#include <linux/jhash.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/errno.h>
+#include <linux/semaphore.h>
+#include <asm/uaccess.h>
+#include <asm/bitops.h>
+#include <linux/spinlock.h>
+#include <linux/vmalloc.h>
+
+#define ASSERT_READ_LOCK(x)
+#define ASSERT_WRITE_LOCK(x)
+#include <linux/netfilter_ipv4/ip_set.h>
+
+static struct list_head set_type_list;		/* all registered sets */
+static struct ip_set **ip_set_list;		/* all individual sets */
+static DEFINE_RWLOCK(ip_set_lock);		/* protects the lists and the hash */
+static DECLARE_MUTEX(ip_set_app_mutex);		/* serializes user access */
+static ip_set_id_t ip_set_max = CONFIG_IP_NF_SET_MAX;
+static ip_set_id_t ip_set_bindings_hash_size =  CONFIG_IP_NF_SET_HASHSIZE;
+static struct list_head *ip_set_hash;		/* hash of bindings */
+static unsigned int ip_set_hash_random;		/* random seed */
+
+/*
+ * Sets are identified either by the index in ip_set_list or by id.
+ * The id never changes and is used to find a key in the hash.
+ * The index may change by swapping and used at all other places
+ * (set/SET netfilter modules, binding value, etc.)
+ *
+ * Userspace requests are serialized by ip_set_mutex and sets can
+ * be deleted only from userspace. Therefore ip_set_list locking
+ * must obey the following rules:
+ *
+ * - kernel requests: read and write locking mandatory
+ * - user requests: read locking optional, write locking mandatory
+ */
+
+static inline void
+__ip_set_get(ip_set_id_t index)
+{
+	atomic_inc(&ip_set_list[index]->ref);
+}
+
+static inline void
+__ip_set_put(ip_set_id_t index)
+{
+	atomic_dec(&ip_set_list[index]->ref);
+}
+
+/*
+ * Binding routines
+ */
+
+static inline struct ip_set_hash *
+__ip_set_find(u_int32_t key, ip_set_id_t id, ip_set_ip_t ip)
+{
+	struct ip_set_hash *set_hash;
+
+	list_for_each_entry(set_hash, &ip_set_hash[key], list)
+		if (set_hash->id == id && set_hash->ip == ip)
+			return set_hash;
+
+	return NULL;
+}
+
+static ip_set_id_t
+ip_set_find_in_hash(ip_set_id_t id, ip_set_ip_t ip)
+{
+	u_int32_t key = jhash_2words(id, ip, ip_set_hash_random)
+				% ip_set_bindings_hash_size;
+	struct ip_set_hash *set_hash;
+
+	ASSERT_READ_LOCK(&ip_set_lock);
+	IP_SET_ASSERT(ip_set_list[id]);
+	DP("set: %s, ip: %u.%u.%u.%u", ip_set_list[id]->name, HIPQUAD(ip));
+
+	set_hash = __ip_set_find(key, id, ip);
+
+	DP("set: %s, ip: %u.%u.%u.%u, binding: %s", ip_set_list[id]->name,
+	   HIPQUAD(ip),
+	   set_hash != NULL ? ip_set_list[set_hash->binding]->name : "");
+
+	return (set_hash != NULL ? set_hash->binding : IP_SET_INVALID_ID);
+}
+
+static inline void
+__set_hash_del(struct ip_set_hash *set_hash)
+{
+	ASSERT_WRITE_LOCK(&ip_set_lock);
+	IP_SET_ASSERT(ip_set_list[set_hash->binding]);
+
+	__ip_set_put(set_hash->binding);
+	list_del(&set_hash->list);
+	kfree(set_hash);
+}
+
+static int
+ip_set_hash_del(ip_set_id_t id, ip_set_ip_t ip)
+{
+	u_int32_t key = jhash_2words(id, ip, ip_set_hash_random)
+				% ip_set_bindings_hash_size;
+	struct ip_set_hash *set_hash;
+
+	IP_SET_ASSERT(ip_set_list[id]);
+	DP("set: %s, ip: %u.%u.%u.%u", ip_set_list[id]->name, HIPQUAD(ip));
+	write_lock_bh(&ip_set_lock);
+	set_hash = __ip_set_find(key, id, ip);
+	DP("set: %s, ip: %u.%u.%u.%u, binding: %s", ip_set_list[id]->name,
+	   HIPQUAD(ip),
+	   set_hash != NULL ? ip_set_list[set_hash->binding]->name : "");
+
+	if (set_hash != NULL)
+		__set_hash_del(set_hash);
+	write_unlock_bh(&ip_set_lock);
+	return 0;
+}
+
+static int
+ip_set_hash_add(ip_set_id_t id, ip_set_ip_t ip, ip_set_id_t binding)
+{
+	u_int32_t key = jhash_2words(id, ip, ip_set_hash_random)
+				% ip_set_bindings_hash_size;
+	struct ip_set_hash *set_hash;
+	int ret = 0;
+
+	IP_SET_ASSERT(ip_set_list[id]);
+	IP_SET_ASSERT(ip_set_list[binding]);
+	DP("set: %s, ip: %u.%u.%u.%u, binding: %s", ip_set_list[id]->name,
+	   HIPQUAD(ip), ip_set_list[binding]->name);
+	write_lock_bh(&ip_set_lock);
+	set_hash = __ip_set_find(key, id, ip);
+	if (!set_hash) {
+		set_hash = kmalloc(sizeof(struct ip_set_hash), GFP_ATOMIC);
+		if (!set_hash) {
+			ret = -ENOMEM;
+			goto unlock;
+		}
+		INIT_LIST_HEAD(&set_hash->list);
+		set_hash->id = id;
+		set_hash->ip = ip;
+		list_add(&set_hash->list, &ip_set_hash[key]);
+	} else {
+		IP_SET_ASSERT(ip_set_list[set_hash->binding]);
+		DP("overwrite binding: %s",
+		   ip_set_list[set_hash->binding]->name);
+		__ip_set_put(set_hash->binding);
+	}
+	set_hash->binding = binding;
+	__ip_set_get(set_hash->binding);
+	DP("stored: key %u, id %u (%s), ip %u.%u.%u.%u, binding %u (%s)",
+	   key, id, ip_set_list[id]->name,
+	   HIPQUAD(ip), binding, ip_set_list[binding]->name);
+    unlock:
+	write_unlock_bh(&ip_set_lock);
+	return ret;
+}
+
+#define FOREACH_HASH_DO(fn, args...) 						\
+({										\
+	ip_set_id_t __key;							\
+	struct ip_set_hash *__set_hash;						\
+										\
+	for (__key = 0; __key < ip_set_bindings_hash_size; __key++) {		\
+		list_for_each_entry(__set_hash, &ip_set_hash[__key], list)	\
+			fn(__set_hash , ## args);				\
+	}									\
+})
+
+#define FOREACH_HASH_RW_DO(fn, args...) 						\
+({										\
+	ip_set_id_t __key;							\
+	struct ip_set_hash *__set_hash, *__n;					\
+										\
+	ASSERT_WRITE_LOCK(&ip_set_lock);					\
+	for (__key = 0; __key < ip_set_bindings_hash_size; __key++) {		\
+		list_for_each_entry_safe(__set_hash, __n, &ip_set_hash[__key], list)\
+			fn(__set_hash , ## args);				\
+	}									\
+})
+
+/* Add, del and test set entries from kernel */
+
+#define follow_bindings(index, set, ip)					\
+((index = ip_set_find_in_hash((set)->id, ip)) != IP_SET_INVALID_ID	\
+ || (index = (set)->binding) != IP_SET_INVALID_ID)
+
+int
+ip_set_testip_kernel(ip_set_id_t index,
+		     const struct sk_buff *skb,
+		     const u_int32_t *flags)
+{
+	struct ip_set *set;
+	ip_set_ip_t ip;
+	int res;
+	unsigned char i = 0;
+
+	IP_SET_ASSERT(flags[i]);
+	read_lock_bh(&ip_set_lock);
+	do {
+		set = ip_set_list[index];
+		IP_SET_ASSERT(set);
+		DP("set %s, index %u", set->name, index);
+		read_lock_bh(&set->lock);
+		res = set->type->testip_kernel(set, skb, &ip, flags, i++);
+		read_unlock_bh(&set->lock);
+		i += !!(set->type->features & IPSET_DATA_DOUBLE);
+	} while (res > 0
+		 && flags[i]
+		 && follow_bindings(index, set, ip));
+	read_unlock_bh(&ip_set_lock);
+
+	return res;
+}
+
+void
+ip_set_addip_kernel(ip_set_id_t index,
+		    const struct sk_buff *skb,
+		    const u_int32_t *flags)
+{
+	struct ip_set *set;
+	ip_set_ip_t ip;
+	int res;
+	unsigned char i = 0;
+
+	IP_SET_ASSERT(flags[i]);
+   retry:
+	read_lock_bh(&ip_set_lock);
+	do {
+		set = ip_set_list[index];
+		IP_SET_ASSERT(set);
+		DP("set %s, index %u", set->name, index);
+		write_lock_bh(&set->lock);
+		res = set->type->addip_kernel(set, skb, &ip, flags, i++);
+		write_unlock_bh(&set->lock);
+		i += !!(set->type->features & IPSET_DATA_DOUBLE);
+	} while ((res == 0 || res == -EEXIST)
+		 && flags[i]
+		 && follow_bindings(index, set, ip));
+	read_unlock_bh(&ip_set_lock);
+
+	if (res == -EAGAIN
+	    && set->type->retry
+	    && (res = set->type->retry(set)) == 0)
+	    	goto retry;
+}
+
+void
+ip_set_delip_kernel(ip_set_id_t index,
+		    const struct sk_buff *skb,
+		    const u_int32_t *flags)
+{
+	struct ip_set *set;
+	ip_set_ip_t ip;
+	int res;
+	unsigned char i = 0;
+
+	IP_SET_ASSERT(flags[i]);
+	read_lock_bh(&ip_set_lock);
+	do {
+		set = ip_set_list[index];
+		IP_SET_ASSERT(set);
+		DP("set %s, index %u", set->name, index);
+		write_lock_bh(&set->lock);
+		res = set->type->delip_kernel(set, skb, &ip, flags, i++);
+		write_unlock_bh(&set->lock);
+		i += !!(set->type->features & IPSET_DATA_DOUBLE);
+	} while ((res == 0 || res == -EEXIST)
+		 && flags[i]
+		 && follow_bindings(index, set, ip));
+	read_unlock_bh(&ip_set_lock);
+}
+
+/* Register and deregister settype */
+
+static inline struct ip_set_type *
+find_set_type(const char *name)
+{
+	struct ip_set_type *set_type;
+
+	list_for_each_entry(set_type, &set_type_list, list)
+		if (!strncmp(set_type->typename, name, IP_SET_MAXNAMELEN - 1))
+			return set_type;
+	return NULL;
+}
+
+int
+ip_set_register_set_type(struct ip_set_type *set_type)
+{
+	int ret = 0;
+
+	if (set_type->protocol_version != IP_SET_PROTOCOL_VERSION) {
+		ip_set_printk("'%s' uses wrong protocol version %u (want %u)",
+			      set_type->typename,
+			      set_type->protocol_version,
+			      IP_SET_PROTOCOL_VERSION);
+		return -EINVAL;
+	}
+
+	write_lock_bh(&ip_set_lock);
+	if (find_set_type(set_type->typename)) {
+		/* Duplicate! */
+		ip_set_printk("'%s' already registered!",
+			      set_type->typename);
+		ret = -EINVAL;
+		goto unlock;
+	}
+	if (!try_module_get(THIS_MODULE)) {
+		ret = -EFAULT;
+		goto unlock;
+	}
+	list_add(&set_type->list, &set_type_list);
+	DP("'%s' registered.", set_type->typename);
+   unlock:
+	write_unlock_bh(&ip_set_lock);
+	return ret;
+}
+
+void
+ip_set_unregister_set_type(struct ip_set_type *set_type)
+{
+	write_lock_bh(&ip_set_lock);
+	if (!find_set_type(set_type->typename)) {
+		ip_set_printk("'%s' not registered?",
+			      set_type->typename);
+		goto unlock;
+	}
+	list_del(&set_type->list);
+	module_put(THIS_MODULE);
+	DP("'%s' unregistered.", set_type->typename);
+   unlock:
+	write_unlock_bh(&ip_set_lock);
+
+}
+
+/*
+ * Userspace routines
+ */
+
+/*
+ * Find set by name, reference it once. The reference makes sure the
+ * thing pointed to, does not go away under our feet. Drop the reference
+ * later, using ip_set_put().
+ */
+ip_set_id_t
+ip_set_get_byname(const char *name)
+{
+	ip_set_id_t i, index = IP_SET_INVALID_ID;
+
+	down(&ip_set_app_mutex);
+	for (i = 0; i < ip_set_max; i++) {
+		if (ip_set_list[i] != NULL
+		    && strcmp(ip_set_list[i]->name, name) == 0) {
+			__ip_set_get(i);
+			index = i;
+			break;
+		}
+	}
+	up(&ip_set_app_mutex);
+	return index;
+}
+
+/*
+ * Find set by index, reference it once. The reference makes sure the
+ * thing pointed to, does not go away under our feet. Drop the reference
+ * later, using ip_set_put().
+ */
+ip_set_id_t
+ip_set_get_byindex(ip_set_id_t index)
+{
+	down(&ip_set_app_mutex);
+
+	if (index >= ip_set_max)
+		return IP_SET_INVALID_ID;
+
+	if (ip_set_list[index])
+		__ip_set_get(index);
+	else
+		index = IP_SET_INVALID_ID;
+
+	up(&ip_set_app_mutex);
+	return index;
+}
+
+/*
+ * If the given set pointer points to a valid set, decrement
+ * reference count by 1. The caller shall not assume the index
+ * to be valid, after calling this function.
+ */
+void ip_set_put(ip_set_id_t index)
+{
+	down(&ip_set_app_mutex);
+	if (ip_set_list[index])
+		__ip_set_put(index);
+	up(&ip_set_app_mutex);
+}
+
+/* Find a set by name or index */
+static ip_set_id_t
+ip_set_find_byname(const char *name)
+{
+	ip_set_id_t i, index = IP_SET_INVALID_ID;
+
+	for (i = 0; i < ip_set_max; i++) {
+		if (ip_set_list[i] != NULL
+		    && strcmp(ip_set_list[i]->name, name) == 0) {
+			index = i;
+			break;
+		}
+	}
+	return index;
+}
+
+static ip_set_id_t
+ip_set_find_byindex(ip_set_id_t index)
+{
+	if (index >= ip_set_max || ip_set_list[index] == NULL)
+		index = IP_SET_INVALID_ID;
+
+	return index;
+}
+
+/*
+ * Add, del, test, bind and unbind
+ */
+
+static inline int
+__ip_set_testip(struct ip_set *set,
+	        const void *data,
+	        size_t size,
+	        ip_set_ip_t *ip)
+{
+	int res;
+
+	read_lock_bh(&set->lock);
+	res = set->type->testip(set, data, size, ip);
+	read_unlock_bh(&set->lock);
+
+	return res;
+}
+
+static int
+__ip_set_addip(ip_set_id_t index,
+	       const void *data,
+	       size_t size)
+{
+	struct ip_set *set = ip_set_list[index];
+	ip_set_ip_t ip;
+	int res;
+
+	IP_SET_ASSERT(set);
+	do {
+		write_lock_bh(&set->lock);
+		res = set->type->addip(set, data, size, &ip);
+		write_unlock_bh(&set->lock);
+	} while (res == -EAGAIN
+		 && set->type->retry
+		 && (res = set->type->retry(set)) == 0);
+
+	return res;
+}
+
+static int
+ip_set_addip(ip_set_id_t index,
+	     const void *data,
+	     size_t size)
+{
+
+	return __ip_set_addip(index,
+			      data + sizeof(struct ip_set_req_adt),
+			      size - sizeof(struct ip_set_req_adt));
+}
+
+static int
+ip_set_delip(ip_set_id_t index,
+	     const void *data,
+	     size_t size)
+{
+	struct ip_set *set = ip_set_list[index];
+	ip_set_ip_t ip;
+	int res;
+
+	IP_SET_ASSERT(set);
+	write_lock_bh(&set->lock);
+	res = set->type->delip(set,
+			       data + sizeof(struct ip_set_req_adt),
+			       size - sizeof(struct ip_set_req_adt),
+			       &ip);
+	write_unlock_bh(&set->lock);
+
+	return res;
+}
+
+static int
+ip_set_testip(ip_set_id_t index,
+	      const void *data,
+	      size_t size)
+{
+	struct ip_set *set = ip_set_list[index];
+	ip_set_ip_t ip;
+	int res;
+
+	IP_SET_ASSERT(set);
+	res = __ip_set_testip(set,
+			      data + sizeof(struct ip_set_req_adt),
+			      size - sizeof(struct ip_set_req_adt),
+			      &ip);
+
+	return (res > 0 ? -EEXIST : res);
+}
+
+static int
+ip_set_bindip(ip_set_id_t index,
+	      const void *data,
+	      size_t size)
+{
+	struct ip_set *set = ip_set_list[index];
+	struct ip_set_req_bind *req_bind;
+	ip_set_id_t binding;
+	ip_set_ip_t ip;
+	int res;
+
+	IP_SET_ASSERT(set);
+	if (size < sizeof(struct ip_set_req_bind))
+		return -EINVAL;
+
+	req_bind = (struct ip_set_req_bind *) data;
+	req_bind->binding[IP_SET_MAXNAMELEN - 1] = '\0';
+
+	if (strcmp(req_bind->binding, IPSET_TOKEN_DEFAULT) == 0) {
+		/* Default binding of a set */
+		char *binding_name;
+
+		if (size != sizeof(struct ip_set_req_bind) + IP_SET_MAXNAMELEN)
+			return -EINVAL;
+
+		binding_name = (char *)(data + sizeof(struct ip_set_req_bind));
+		binding_name[IP_SET_MAXNAMELEN - 1] = '\0';
+
+		binding = ip_set_find_byname(binding_name);
+		if (binding == IP_SET_INVALID_ID)
+			return -ENOENT;
+
+		write_lock_bh(&ip_set_lock);
+		/* Sets as binding values are referenced */
+		if (set->binding != IP_SET_INVALID_ID)
+			__ip_set_put(set->binding);
+		set->binding = binding;
+		__ip_set_get(set->binding);
+		write_unlock_bh(&ip_set_lock);
+
+		return 0;
+	}
+	binding = ip_set_find_byname(req_bind->binding);
+	if (binding == IP_SET_INVALID_ID)
+		return -ENOENT;
+
+	res = __ip_set_testip(set,
+			      data + sizeof(struct ip_set_req_bind),
+			      size - sizeof(struct ip_set_req_bind),
+			      &ip);
+	DP("set %s, ip: %u.%u.%u.%u, binding %s",
+	   set->name, HIPQUAD(ip), ip_set_list[binding]->name);
+
+	if (res >= 0)
+		res = ip_set_hash_add(set->id, ip, binding);
+
+	return res;
+}
+
+#define FOREACH_SET_DO(fn, args...) 				\
+({								\
+	ip_set_id_t __i;					\
+	struct ip_set *__set;					\
+								\
+	for (__i = 0; __i < ip_set_max; __i++) {		\
+		__set = ip_set_list[__i];			\
+		if (__set != NULL)				\
+			fn(__set , ##args);			\
+	}							\
+})
+
+static inline void
+__set_hash_del_byid(struct ip_set_hash *set_hash, ip_set_id_t id)
+{
+	if (set_hash->id == id)
+		__set_hash_del(set_hash);
+}
+
+static inline void
+__unbind_default(struct ip_set *set)
+{
+	if (set->binding != IP_SET_INVALID_ID) {
+		/* Sets as binding values are referenced */
+		__ip_set_put(set->binding);
+		set->binding = IP_SET_INVALID_ID;
+	}
+}
+
+static int
+ip_set_unbindip(ip_set_id_t index,
+	        const void *data,
+	        size_t size)
+{
+	struct ip_set *set;
+	struct ip_set_req_bind *req_bind;
+	ip_set_ip_t ip;
+	int res;
+
+	DP("");
+	if (size < sizeof(struct ip_set_req_bind))
+		return -EINVAL;
+
+	req_bind = (struct ip_set_req_bind *) data;
+	req_bind->binding[IP_SET_MAXNAMELEN - 1] = '\0';
+
+	DP("%u %s", index, req_bind->binding);
+	if (index == IP_SET_INVALID_ID) {
+		/* unbind :all: */
+		if (strcmp(req_bind->binding, IPSET_TOKEN_DEFAULT) == 0) {
+			/* Default binding of sets */
+			write_lock_bh(&ip_set_lock);
+			FOREACH_SET_DO(__unbind_default);
+			write_unlock_bh(&ip_set_lock);
+			return 0;
+		} else if (strcmp(req_bind->binding, IPSET_TOKEN_ALL) == 0) {
+			/* Flush all bindings of all sets*/
+			write_lock_bh(&ip_set_lock);
+			FOREACH_HASH_RW_DO(__set_hash_del);
+			write_unlock_bh(&ip_set_lock);
+			return 0;
+		}
+		DP("unreachable reached!");
+		return -EINVAL;
+	}
+
+	set = ip_set_list[index];
+	IP_SET_ASSERT(set);
+	if (strcmp(req_bind->binding, IPSET_TOKEN_DEFAULT) == 0) {
+		/* Default binding of set */
+		ip_set_id_t binding = ip_set_find_byindex(set->binding);
+
+		if (binding == IP_SET_INVALID_ID)
+			return -ENOENT;
+
+		write_lock_bh(&ip_set_lock);
+		/* Sets in hash values are referenced */
+		__ip_set_put(set->binding);
+		set->binding = IP_SET_INVALID_ID;
+		write_unlock_bh(&ip_set_lock);
+
+		return 0;
+	} else if (strcmp(req_bind->binding, IPSET_TOKEN_ALL) == 0) {
+		/* Flush all bindings */
+
+		write_lock_bh(&ip_set_lock);
+		FOREACH_HASH_RW_DO(__set_hash_del_byid, set->id);
+		write_unlock_bh(&ip_set_lock);
+		return 0;
+	}
+
+	res = __ip_set_testip(set,
+			      data + sizeof(struct ip_set_req_bind),
+			      size - sizeof(struct ip_set_req_bind),
+			      &ip);
+
+	DP("set %s, ip: %u.%u.%u.%u", set->name, HIPQUAD(ip));
+	if (res >= 0)
+		res = ip_set_hash_del(set->id, ip);
+
+	return res;
+}
+
+static int
+ip_set_testbind(ip_set_id_t index,
+	        const void *data,
+	        size_t size)
+{
+	struct ip_set *set = ip_set_list[index];
+	struct ip_set_req_bind *req_bind;
+	ip_set_id_t binding;
+	ip_set_ip_t ip;
+	int res;
+
+	IP_SET_ASSERT(set);
+	if (size < sizeof(struct ip_set_req_bind))
+		return -EINVAL;
+
+	req_bind = (struct ip_set_req_bind *) data;
+	req_bind->binding[IP_SET_MAXNAMELEN - 1] = '\0';
+
+	if (strcmp(req_bind->binding, IPSET_TOKEN_DEFAULT) == 0) {
+		/* Default binding of set */
+		char *binding_name;
+
+		if (size != sizeof(struct ip_set_req_bind) + IP_SET_MAXNAMELEN)
+			return -EINVAL;
+
+		binding_name = (char *)(data + sizeof(struct ip_set_req_bind));
+		binding_name[IP_SET_MAXNAMELEN - 1] = '\0';
+
+		binding = ip_set_find_byname(binding_name);
+		if (binding == IP_SET_INVALID_ID)
+			return -ENOENT;
+
+		res = (set->binding == binding) ? -EEXIST : 0;
+
+		return res;
+	}
+	binding = ip_set_find_byname(req_bind->binding);
+	if (binding == IP_SET_INVALID_ID)
+		return -ENOENT;
+
+
+	res = __ip_set_testip(set,
+			      data + sizeof(struct ip_set_req_bind),
+			      size - sizeof(struct ip_set_req_bind),
+			      &ip);
+	DP("set %s, ip: %u.%u.%u.%u, binding %s",
+	   set->name, HIPQUAD(ip), ip_set_list[binding]->name);
+
+	if (res >= 0)
+		res = (ip_set_find_in_hash(set->id, ip) == binding)
+			? -EEXIST : 0;
+
+	return res;
+}
+
+static struct ip_set_type *
+find_set_type_rlock(const char *typename)
+{
+	struct ip_set_type *type;
+
+	read_lock_bh(&ip_set_lock);
+	type = find_set_type(typename);
+	if (type == NULL)
+		read_unlock_bh(&ip_set_lock);
+
+	return type;
+}
+
+static int
+find_free_id(const char *name,
+	     ip_set_id_t *index,
+	     ip_set_id_t *id)
+{
+	ip_set_id_t i;
+
+	*id = IP_SET_INVALID_ID;
+	for (i = 0;  i < ip_set_max; i++) {
+		if (ip_set_list[i] == NULL) {
+			if (*id == IP_SET_INVALID_ID)
+				*id = *index = i;
+		} else if (strcmp(name, ip_set_list[i]->name) == 0)
+			/* Name clash */
+			return -EEXIST;
+	}
+	if (*id == IP_SET_INVALID_ID)
+		/* No free slot remained */
+		return -ERANGE;
+	/* Check that index is usable as id (swapping) */
+    check:
+	for (i = 0;  i < ip_set_max; i++) {
+		if (ip_set_list[i] != NULL
+		    && ip_set_list[i]->id == *id) {
+		    *id = i;
+		    goto check;
+		}
+	}
+	return 0;
+}
+
+/*
+ * Create a set
+ */
+static int
+ip_set_create(const char *name,
+	      const char *typename,
+	      ip_set_id_t restore,
+	      const void *data,
+	      size_t size)
+{
+	struct ip_set *set;
+	ip_set_id_t index = 0, id;
+	int res = 0;
+
+	DP("setname: %s, typename: %s, id: %u", name, typename, restore);
+	/*
+	 * First, and without any locks, allocate and initialize
+	 * a normal base set structure.
+	 */
+	set = kmalloc(sizeof(struct ip_set), GFP_KERNEL);
+	if (!set)
+		return -ENOMEM;
+	set->lock = RW_LOCK_UNLOCKED;
+	strncpy(set->name, name, IP_SET_MAXNAMELEN);
+	set->binding = IP_SET_INVALID_ID;
+	atomic_set(&set->ref, 0);
+
+	/*
+	 * Next, take the &ip_set_lock, check that we know the type,
+	 * and take a reference on the type, to make sure it
+	 * stays available while constructing our new set.
+	 *
+	 * After referencing the type, we drop the &ip_set_lock,
+	 * and let the new set construction run without locks.
+	 */
+	set->type = find_set_type_rlock(typename);
+	if (set->type == NULL) {
+		/* Try loading the module */
+		char modulename[IP_SET_MAXNAMELEN + strlen("ip_set_") + 1];
+		strcpy(modulename, "ip_set_");
+		strcat(modulename, typename);
+		DP("try to load %s", modulename);
+		request_module(modulename);
+		set->type = find_set_type_rlock(typename);
+	}
+	if (set->type == NULL) {
+		ip_set_printk("no set type '%s', set '%s' not created",
+			      typename, name);
+		res = -ENOENT;
+		goto out;
+	}
+	if (!try_module_get(set->type->me)) {
+		read_unlock_bh(&ip_set_lock);
+		res = -EFAULT;
+		goto out;
+	}
+	read_unlock_bh(&ip_set_lock);
+
+	/*
+	 * Without holding any locks, create private part.
+	 */
+	res = set->type->create(set, data, size);
+	if (res != 0)
+		goto put_out;
+
+	/* BTW, res==0 here. */
+
+	/*
+	 * Here, we have a valid, constructed set. &ip_set_lock again,
+	 * find free id/index and check that it is not already in
+	 * ip_set_list.
+	 */
+	write_lock_bh(&ip_set_lock);
+	if ((res = find_free_id(set->name, &index, &id)) != 0) {
+		DP("no free id!");
+		goto cleanup;
+	}
+
+	/* Make sure restore gets the same index */
+	if (restore != IP_SET_INVALID_ID && index != restore) {
+		DP("Can't restore, sets are screwed up");
+		res = -ERANGE;
+		goto cleanup;
+	}
+
+	/*
+	 * Finally! Add our shiny new set to the list, and be done.
+	 */
+	DP("create: '%s' created with index %u, id %u!", set->name, index, id);
+	set->id = id;
+	ip_set_list[index] = set;
+	write_unlock_bh(&ip_set_lock);
+	return res;
+
+    cleanup:
+	write_unlock_bh(&ip_set_lock);
+	set->type->destroy(set);
+    put_out:
+	module_put(set->type->me);
+    out:
+	kfree(set);
+	return res;
+}
+
+/*
+ * Destroy a given existing set
+ */
+static void
+ip_set_destroy_set(ip_set_id_t index)
+{
+	struct ip_set *set = ip_set_list[index];
+
+	IP_SET_ASSERT(set);
+	DP("set: %s",  set->name);
+	write_lock_bh(&ip_set_lock);
+	FOREACH_HASH_RW_DO(__set_hash_del_byid, set->id);
+	if (set->binding != IP_SET_INVALID_ID)
+		__ip_set_put(set->binding);
+	ip_set_list[index] = NULL;
+	write_unlock_bh(&ip_set_lock);
+
+	/* Must call it without holding any lock */
+	set->type->destroy(set);
+	module_put(set->type->me);
+	kfree(set);
+}
+
+/*
+ * Destroy a set - or all sets
+ * Sets must not be referenced/used.
+ */
+static int
+ip_set_destroy(ip_set_id_t index)
+{
+	ip_set_id_t i;
+
+	/* ref modification always protected by the mutex */
+	if (index != IP_SET_INVALID_ID) {
+		if (atomic_read(&ip_set_list[index]->ref))
+			return -EBUSY;
+		ip_set_destroy_set(index);
+	} else {
+		for (i = 0; i < ip_set_max; i++) {
+			if (ip_set_list[i] != NULL
+			    && (atomic_read(&ip_set_list[i]->ref)))
+			    	return -EBUSY;
+		}
+
+		for (i = 0; i < ip_set_max; i++) {
+			if (ip_set_list[i] != NULL)
+				ip_set_destroy_set(i);
+		}
+	}
+	return 0;
+}
+
+static void
+ip_set_flush_set(struct ip_set *set)
+{
+	DP("set: %s %u",  set->name, set->id);
+
+	write_lock_bh(&set->lock);
+	set->type->flush(set);
+	write_unlock_bh(&set->lock);
+}
+
+/*
+ * Flush data in a set - or in all sets
+ */
+static int
+ip_set_flush(ip_set_id_t index)
+{
+	if (index != IP_SET_INVALID_ID) {
+		IP_SET_ASSERT(ip_set_list[index]);
+		ip_set_flush_set(ip_set_list[index]);
+	} else
+		FOREACH_SET_DO(ip_set_flush_set);
+
+	return 0;
+}
+
+/* Rename a set */
+static int
+ip_set_rename(ip_set_id_t index, const char *name)
+{
+	struct ip_set *set = ip_set_list[index];
+	ip_set_id_t i;
+	int res = 0;
+
+	DP("set: %s to %s",  set->name, name);
+	write_lock_bh(&ip_set_lock);
+	for (i = 0; i < ip_set_max; i++) {
+		if (ip_set_list[i] != NULL
+		    && strncmp(ip_set_list[i]->name,
+			       name,
+			       IP_SET_MAXNAMELEN - 1) == 0) {
+			res = -EEXIST;
+			goto unlock;
+		}
+	}
+	strncpy(set->name, name, IP_SET_MAXNAMELEN);
+    unlock:
+	write_unlock_bh(&ip_set_lock);
+	return res;
+}
+
+/*
+ * Swap two sets so that name/index points to the other.
+ * References are also swapped.
+ */
+static int
+ip_set_swap(ip_set_id_t from_index, ip_set_id_t to_index)
+{
+	struct ip_set *from = ip_set_list[from_index];
+	struct ip_set *to = ip_set_list[to_index];
+	char from_name[IP_SET_MAXNAMELEN];
+	u_int32_t from_ref;
+
+	DP("set: %s to %s",  from->name, to->name);
+	/* Features must not change. Artifical restriction. */
+	if (from->type->features != to->type->features)
+		return -ENOEXEC;
+
+	/* No magic here: ref munging protected by the mutex */
+	write_lock_bh(&ip_set_lock);
+	strncpy(from_name, from->name, IP_SET_MAXNAMELEN);
+	from_ref = atomic_read(&from->ref);
+
+	strncpy(from->name, to->name, IP_SET_MAXNAMELEN);
+	atomic_set(&from->ref, atomic_read(&to->ref));
+	strncpy(to->name, from_name, IP_SET_MAXNAMELEN);
+	atomic_set(&to->ref, from_ref);
+
+	ip_set_list[from_index] = to;
+	ip_set_list[to_index] = from;
+
+	write_unlock_bh(&ip_set_lock);
+	return 0;
+}
+
+/*
+ * List set data
+ */
+
+static inline void
+__set_hash_bindings_size_list(struct ip_set_hash *set_hash,
+			      ip_set_id_t id, size_t *size)
+{
+	if (set_hash->id == id)
+		*size += sizeof(struct ip_set_hash_list);
+}
+
+static inline void
+__set_hash_bindings_size_save(struct ip_set_hash *set_hash,
+			      ip_set_id_t id, size_t *size)
+{
+	if (set_hash->id == id)
+		*size += sizeof(struct ip_set_hash_save);
+}
+
+static inline void
+__set_hash_bindings(struct ip_set_hash *set_hash,
+		    ip_set_id_t id, void *data, int *used)
+{
+	if (set_hash->id == id) {
+		struct ip_set_hash_list *hash_list =
+			(struct ip_set_hash_list *)(data + *used);
+
+		hash_list->ip = set_hash->ip;
+		hash_list->binding = set_hash->binding;
+		*used += sizeof(struct ip_set_hash_list);
+	}
+}
+
+static int ip_set_list_set(ip_set_id_t index,
+			   void *data,
+			   int *used,
+			   int len)
+{
+	struct ip_set *set = ip_set_list[index];
+	struct ip_set_list *set_list;
+
+	/* Pointer to our header */
+	set_list = (struct ip_set_list *) (data + *used);
+
+	DP("set: %s, used: %d %p %p", set->name, *used, data, data + *used);
+
+	/* Get and ensure header size */
+	if (*used + sizeof(struct ip_set_list) > len)
+		goto not_enough_mem;
+	*used += sizeof(struct ip_set_list);
+
+	read_lock_bh(&set->lock);
+	/* Get and ensure set specific header size */
+	set_list->header_size = set->type->header_size;
+	if (*used + set_list->header_size > len)
+		goto unlock_set;
+
+	/* Fill in the header */
+	set_list->index = index;
+	set_list->binding = set->binding;
+	set_list->ref = atomic_read(&set->ref);
+
+	/* Fill in set spefific header data */
+	set->type->list_header(set, data + *used);
+	*used += set_list->header_size;
+
+	/* Get and ensure set specific members size */
+	set_list->members_size = set->type->list_members_size(set);
+	if (*used + set_list->members_size > len)
+		goto unlock_set;
+
+	/* Fill in set spefific members data */
+	set->type->list_members(set, data + *used);
+	*used += set_list->members_size;
+	read_unlock_bh(&set->lock);
+
+	/* Bindings */
+
+	/* Get and ensure set specific bindings size */
+	set_list->bindings_size = 0;
+	FOREACH_HASH_DO(__set_hash_bindings_size_list,
+			set->id, &set_list->bindings_size);
+	if (*used + set_list->bindings_size > len)
+		goto not_enough_mem;
+
+	/* Fill in set spefific bindings data */
+	FOREACH_HASH_DO(__set_hash_bindings, set->id, data, used);
+
+	return 0;
+
+    unlock_set:
+	read_unlock_bh(&set->lock);
+    not_enough_mem:
+	DP("not enough mem, try again");
+	return -EAGAIN;
+}
+
+/*
+ * Save sets
+ */
+static int ip_set_save_set(ip_set_id_t index,
+			   void *data,
+			   int *used,
+			   int len)
+{
+	struct ip_set *set;
+	struct ip_set_save *set_save;
+
+	/* Pointer to our header */
+	set_save = (struct ip_set_save *) (data + *used);
+
+	/* Get and ensure header size */
+	if (*used + sizeof(struct ip_set_save) > len)
+		goto not_enough_mem;
+	*used += sizeof(struct ip_set_save);
+
+	set = ip_set_list[index];
+	DP("set: %s, used: %u(%u) %p %p", set->name, *used, len,
+	   data, data + *used);
+
+	read_lock_bh(&set->lock);
+	/* Get and ensure set specific header size */
+	set_save->header_size = set->type->header_size;
+	if (*used + set_save->header_size > len)
+		goto unlock_set;
+
+	/* Fill in the header */
+	set_save->index = index;
+	set_save->binding = set->binding;
+
+	/* Fill in set spefific header data */
+	set->type->list_header(set, data + *used);
+	*used += set_save->header_size;
+
+	DP("set header filled: %s, used: %u(%u) %p %p", set->name, *used,
+	   set_save->header_size, data, data + *used);
+	/* Get and ensure set specific members size */
+	set_save->members_size = set->type->list_members_size(set);
+	if (*used + set_save->members_size > len)
+		goto unlock_set;
+
+	/* Fill in set spefific members data */
+	set->type->list_members(set, data + *used);
+	*used += set_save->members_size;
+	read_unlock_bh(&set->lock);
+	DP("set members filled: %s, used: %u(%u) %p %p", set->name, *used,
+	   set_save->members_size, data, data + *used);
+	return 0;
+
+    unlock_set:
+	read_unlock_bh(&set->lock);
+    not_enough_mem:
+	DP("not enough mem, try again");
+	return -EAGAIN;
+}
+
+static inline void
+__set_hash_save_bindings(struct ip_set_hash *set_hash,
+			 ip_set_id_t id,
+			 void *data,
+			 int *used,
+			 int len,
+			 int *res)
+{
+	if (*res == 0
+	    && (id == IP_SET_INVALID_ID || set_hash->id == id)) {
+		struct ip_set_hash_save *hash_save =
+			(struct ip_set_hash_save *)(data + *used);
+		/* Ensure bindings size */
+		if (*used + sizeof(struct ip_set_hash_save) > len) {
+			*res = -ENOMEM;
+			return;
+		}
+		hash_save->id = set_hash->id;
+		hash_save->ip = set_hash->ip;
+		hash_save->binding = set_hash->binding;
+		*used += sizeof(struct ip_set_hash_save);
+	}
+}
+
+static int ip_set_save_bindings(ip_set_id_t index,
+			   	void *data,
+			   	int *used,
+			   	int len)
+{
+	int res = 0;
+	struct ip_set_save *set_save;
+
+	DP("used %u, len %u", *used, len);
+	/* Get and ensure header size */
+	if (*used + sizeof(struct ip_set_save) > len)
+		return -ENOMEM;
+
+	/* Marker */
+	set_save = (struct ip_set_save *) (data + *used);
+	set_save->index = IP_SET_INVALID_ID;
+	set_save->header_size = 0;
+	set_save->members_size = 0;
+	*used += sizeof(struct ip_set_save);
+
+	DP("marker added used %u, len %u", *used, len);
+	/* Fill in bindings data */
+	if (index != IP_SET_INVALID_ID)
+		/* Sets are identified by id in hash */
+		index = ip_set_list[index]->id;
+	FOREACH_HASH_DO(__set_hash_save_bindings, index, data, used, len, &res);
+
+	return res;
+}
+
+/*
+ * Restore sets
+ */
+static int ip_set_restore(void *data,
+			  int len)
+{
+	int res = 0;
+	int line = 0, used = 0, members_size;
+	struct ip_set *set;
+	struct ip_set_hash_save *hash_save;
+	struct ip_set_restore *set_restore;
+	ip_set_id_t index;
+
+	/* Loop to restore sets */
+	while (1) {
+		line++;
+
+		DP("%u %u %u", used, sizeof(struct ip_set_restore), len);
+		/* Get and ensure header size */
+		if (used + sizeof(struct ip_set_restore) > len)
+			return line;
+		set_restore = (struct ip_set_restore *) (data + used);
+		used += sizeof(struct ip_set_restore);
+
+		/* Ensure data size */
+		if (used
+		    + set_restore->header_size
+		    + set_restore->members_size > len)
+			return line;
+
+		/* Check marker */
+		if (set_restore->index == IP_SET_INVALID_ID) {
+			line--;
+			goto bindings;
+		}
+
+		/* Try to create the set */
+		DP("restore %s %s", set_restore->name, set_restore->typename);
+		res = ip_set_create(set_restore->name,
+				    set_restore->typename,
+				    set_restore->index,
+				    data + used,
+				    set_restore->header_size);
+
+		if (res != 0)
+			return line;
+		used += set_restore->header_size;
+
+		index = ip_set_find_byindex(set_restore->index);
+		DP("index %u, restore_index %u", index, set_restore->index);
+		if (index != set_restore->index)
+			return line;
+		/* Try to restore members data */
+		set = ip_set_list[index];
+		members_size = 0;
+		DP("members_size %u reqsize %u",
+		   set_restore->members_size, set->type->reqsize);
+		while (members_size + set->type->reqsize <=
+		       set_restore->members_size) {
+			line++;
+		       	DP("members: %u, line %u", members_size, line);
+			res = __ip_set_addip(index,
+					   data + used + members_size,
+					   set->type->reqsize);
+			if (!(res == 0 || res == -EEXIST))
+				return line;
+			members_size += set->type->reqsize;
+		}
+
+		DP("members_size %u  %u",
+		   set_restore->members_size, members_size);
+		if (members_size != set_restore->members_size)
+			return line++;
+		used += set_restore->members_size;
+	}
+
+   bindings:
+   	/* Loop to restore bindings */
+   	while (used < len) {
+		line++;
+
+		DP("restore binding, line %u", line);
+		/* Get and ensure size */
+		if (used + sizeof(struct ip_set_hash_save) > len)
+			return line;
+		hash_save = (struct ip_set_hash_save *) (data + used);
+		used += sizeof(struct ip_set_hash_save);
+
+		/* hash_save->id is used to store the index */
+		index = ip_set_find_byindex(hash_save->id);
+		DP("restore binding index %u, id %u, %u -> %u",
+		   index, hash_save->id, hash_save->ip, hash_save->binding);
+		if (index != hash_save->id)
+			return line;
+		if (ip_set_find_byindex(hash_save->binding) == IP_SET_INVALID_ID) {
+			DP("corrupt binding set index %u", hash_save->binding);
+			return line;
+		}
+		set = ip_set_list[hash_save->id];
+		/* Null valued IP means default binding */
+		if (hash_save->ip)
+			res = ip_set_hash_add(set->id,
+					      hash_save->ip,
+					      hash_save->binding);
+		else {
+			IP_SET_ASSERT(set->binding == IP_SET_INVALID_ID);
+			write_lock_bh(&ip_set_lock);
+			set->binding = hash_save->binding;
+			__ip_set_get(set->binding);
+			write_unlock_bh(&ip_set_lock);
+			DP("default binding: %u", set->binding);
+		}
+		if (res != 0)
+			return line;
+   	}
+   	if (used != len)
+   		return line;
+
+	return 0;
+}
+
+static int
+ip_set_sockfn_set(struct sock *sk, int optval, void *user, unsigned int len)
+{
+	void *data;
+	int res = 0;		/* Assume OK */
+	unsigned *op;
+	struct ip_set_req_adt *req_adt;
+	ip_set_id_t index = IP_SET_INVALID_ID;
+	int (*adtfn)(ip_set_id_t index,
+		     const void *data, size_t size);
+	struct fn_table {
+		int (*fn)(ip_set_id_t index,
+			  const void *data, size_t size);
+	} adtfn_table[] =
+	{ { ip_set_addip }, { ip_set_delip }, { ip_set_testip},
+	  { ip_set_bindip}, { ip_set_unbindip }, { ip_set_testbind },
+	};
+
+	DP("optval=%d, user=%p, len=%d", optval, user, len);
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+	if (optval != SO_IP_SET)
+		return -EBADF;
+	if (len <= sizeof(unsigned)) {
+		ip_set_printk("short userdata (want >%zu, got %u)",
+			      sizeof(unsigned), len);
+		return -EINVAL;
+	}
+	data = vmalloc(len);
+	if (!data) {
+		DP("out of mem for %u bytes", len);
+		return -ENOMEM;
+	}
+	if (copy_from_user(data, user, len) != 0) {
+		res = -EFAULT;
+		goto done;
+	}
+	if (down_interruptible(&ip_set_app_mutex)) {
+		res = -EINTR;
+		goto done;
+	}
+
+	op = (unsigned *)data;
+	DP("op=%x", *op);
+
+	if (*op < IP_SET_OP_VERSION) {
+		/* Check the version at the beginning of operations */
+		struct ip_set_req_version *req_version =
+			(struct ip_set_req_version *) data;
+		if (req_version->version != IP_SET_PROTOCOL_VERSION) {
+			res = -EPROTO;
+			goto done;
+		}
+	}
+
+	switch (*op) {
+	case IP_SET_OP_CREATE:{
+		struct ip_set_req_create *req_create
+			= (struct ip_set_req_create *) data;
+
+		if (len < sizeof(struct ip_set_req_create)) {
+			ip_set_printk("short CREATE data (want >=%zu, got %u)",
+				      sizeof(struct ip_set_req_create), len);
+			res = -EINVAL;
+			goto done;
+		}
+		req_create->name[IP_SET_MAXNAMELEN - 1] = '\0';
+		req_create->typename[IP_SET_MAXNAMELEN - 1] = '\0';
+		res = ip_set_create(req_create->name,
+				    req_create->typename,
+				    IP_SET_INVALID_ID,
+				    data + sizeof(struct ip_set_req_create),
+				    len - sizeof(struct ip_set_req_create));
+		goto done;
+	}
+	case IP_SET_OP_DESTROY:{
+		struct ip_set_req_std *req_destroy
+			= (struct ip_set_req_std *) data;
+
+		if (len != sizeof(struct ip_set_req_std)) {
+			ip_set_printk("invalid DESTROY data (want %zu, got %u)",
+				      sizeof(struct ip_set_req_std), len);
+			res = -EINVAL;
+			goto done;
+		}
+		if (strcmp(req_destroy->name, IPSET_TOKEN_ALL) == 0) {
+			/* Destroy all sets */
+			index = IP_SET_INVALID_ID;
+		} else {
+			req_destroy->name[IP_SET_MAXNAMELEN - 1] = '\0';
+			index = ip_set_find_byname(req_destroy->name);
+
+			if (index == IP_SET_INVALID_ID) {
+				res = -ENOENT;
+				goto done;
+			}
+		}
+
+		res = ip_set_destroy(index);
+		goto done;
+	}
+	case IP_SET_OP_FLUSH:{
+		struct ip_set_req_std *req_flush =
+			(struct ip_set_req_std *) data;
+
+		if (len != sizeof(struct ip_set_req_std)) {
+			ip_set_printk("invalid FLUSH data (want %zu, got %u)",
+				      sizeof(struct ip_set_req_std), len);
+			res = -EINVAL;
+			goto done;
+		}
+		if (strcmp(req_flush->name, IPSET_TOKEN_ALL) == 0) {
+			/* Flush all sets */
+			index = IP_SET_INVALID_ID;
+		} else {
+			req_flush->name[IP_SET_MAXNAMELEN - 1] = '\0';
+			index = ip_set_find_byname(req_flush->name);
+
+			if (index == IP_SET_INVALID_ID) {
+				res = -ENOENT;
+				goto done;
+			}
+		}
+		res = ip_set_flush(index);
+		goto done;
+	}
+	case IP_SET_OP_RENAME:{
+		struct ip_set_req_create *req_rename
+			= (struct ip_set_req_create *) data;
+
+		if (len != sizeof(struct ip_set_req_create)) {
+			ip_set_printk("invalid RENAME data (want %zu, got %u)",
+				      sizeof(struct ip_set_req_create), len);
+			res = -EINVAL;
+			goto done;
+		}
+
+		req_rename->name[IP_SET_MAXNAMELEN - 1] = '\0';
+		req_rename->typename[IP_SET_MAXNAMELEN - 1] = '\0';
+
+		index = ip_set_find_byname(req_rename->name);
+		if (index == IP_SET_INVALID_ID) {
+			res = -ENOENT;
+			goto done;
+		}
+		res = ip_set_rename(index, req_rename->typename);
+		goto done;
+	}
+	case IP_SET_OP_SWAP:{
+		struct ip_set_req_create *req_swap
+			= (struct ip_set_req_create *) data;
+		ip_set_id_t to_index;
+
+		if (len != sizeof(struct ip_set_req_create)) {
+			ip_set_printk("invalid SWAP data (want %zu, got %u)",
+				      sizeof(struct ip_set_req_create), len);
+			res = -EINVAL;
+			goto done;
+		}
+
+		req_swap->name[IP_SET_MAXNAMELEN - 1] = '\0';
+		req_swap->typename[IP_SET_MAXNAMELEN - 1] = '\0';
+
+		index = ip_set_find_byname(req_swap->name);
+		if (index == IP_SET_INVALID_ID) {
+			res = -ENOENT;
+			goto done;
+		}
+		to_index = ip_set_find_byname(req_swap->typename);
+		if (to_index == IP_SET_INVALID_ID) {
+			res = -ENOENT;
+			goto done;
+		}
+		res = ip_set_swap(index, to_index);
+		goto done;
+	}
+	default:
+		break;	/* Set identified by id */
+	}
+
+	/* There we may have add/del/test/bind/unbind/test_bind operations */
+	if (*op < IP_SET_OP_ADD_IP || *op > IP_SET_OP_TEST_BIND_SET) {
+		res = -EBADMSG;
+		goto done;
+	}
+	adtfn = adtfn_table[*op - IP_SET_OP_ADD_IP].fn;
+
+	if (len < sizeof(struct ip_set_req_adt)) {
+		ip_set_printk("short data in adt request (want >=%zu, got %u)",
+			      sizeof(struct ip_set_req_adt), len);
+		res = -EINVAL;
+		goto done;
+	}
+	req_adt = (struct ip_set_req_adt *) data;
+
+	/* -U :all: :all:|:default: uses IP_SET_INVALID_ID */
+	if (!(*op == IP_SET_OP_UNBIND_SET
+	      && req_adt->index == IP_SET_INVALID_ID)) {
+		index = ip_set_find_byindex(req_adt->index);
+		if (index == IP_SET_INVALID_ID) {
+			res = -ENOENT;
+			goto done;
+		}
+	}
+	res = adtfn(index, data, len);
+
+    done:
+	up(&ip_set_app_mutex);
+	vfree(data);
+	if (res > 0)
+		res = 0;
+	DP("final result %d", res);
+	return res;
+}
+
+static int
+ip_set_sockfn_get(struct sock *sk, int optval, void *user, int *len)
+{
+	int res = 0;
+	unsigned *op;
+	ip_set_id_t index = IP_SET_INVALID_ID;
+	void *data;
+	int copylen = *len;
+
+	DP("optval=%d, user=%p, len=%d", optval, user, *len);
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+	if (optval != SO_IP_SET)
+		return -EBADF;
+	if (*len < sizeof(unsigned)) {
+		ip_set_printk("short userdata (want >=%zu, got %d)",
+			      sizeof(unsigned), *len);
+		return -EINVAL;
+	}
+	data = vmalloc(*len);
+	if (!data) {
+		DP("out of mem for %d bytes", *len);
+		return -ENOMEM;
+	}
+	if (copy_from_user(data, user, *len) != 0) {
+		res = -EFAULT;
+		goto done;
+	}
+	if (down_interruptible(&ip_set_app_mutex)) {
+		res = -EINTR;
+		goto done;
+	}
+
+	op = (unsigned *) data;
+	DP("op=%x", *op);
+
+	if (*op < IP_SET_OP_VERSION) {
+		/* Check the version at the beginning of operations */
+		struct ip_set_req_version *req_version =
+			(struct ip_set_req_version *) data;
+		if (req_version->version != IP_SET_PROTOCOL_VERSION) {
+			res = -EPROTO;
+			goto done;
+		}
+	}
+
+	switch (*op) {
+	case IP_SET_OP_VERSION: {
+		struct ip_set_req_version *req_version =
+		    (struct ip_set_req_version *) data;
+
+		if (*len != sizeof(struct ip_set_req_version)) {
+			ip_set_printk("invalid VERSION (want %zu, got %d)",
+				      sizeof(struct ip_set_req_version),
+				      *len);
+			res = -EINVAL;
+			goto done;
+		}
+
+		req_version->version = IP_SET_PROTOCOL_VERSION;
+		res = copy_to_user(user, req_version,
+				   sizeof(struct ip_set_req_version));
+		goto done;
+	}
+	case IP_SET_OP_GET_BYNAME: {
+		struct ip_set_req_get_set *req_get
+			= (struct ip_set_req_get_set *) data;
+
+		if (*len != sizeof(struct ip_set_req_get_set)) {
+			ip_set_printk("invalid GET_BYNAME (want %zu, got %d)",
+				      sizeof(struct ip_set_req_get_set), *len);
+			res = -EINVAL;
+			goto done;
+		}
+		req_get->set.name[IP_SET_MAXNAMELEN - 1] = '\0';
+		index = ip_set_find_byname(req_get->set.name);
+		req_get->set.index = index;
+		goto copy;
+	}
+	case IP_SET_OP_GET_BYINDEX: {
+		struct ip_set_req_get_set *req_get
+			= (struct ip_set_req_get_set *) data;
+
+		if (*len != sizeof(struct ip_set_req_get_set)) {
+			ip_set_printk("invalid GET_BYINDEX (want %zu, got %d)",
+				      sizeof(struct ip_set_req_get_set), *len);
+			res = -EINVAL;
+			goto done;
+		}
+		req_get->set.name[IP_SET_MAXNAMELEN - 1] = '\0';
+		index = ip_set_find_byindex(req_get->set.index);
+		strncpy(req_get->set.name,
+			index == IP_SET_INVALID_ID ? ""
+			: ip_set_list[index]->name, IP_SET_MAXNAMELEN);
+		goto copy;
+	}
+	case IP_SET_OP_ADT_GET: {
+		struct ip_set_req_adt_get *req_get
+			= (struct ip_set_req_adt_get *) data;
+
+		if (*len != sizeof(struct ip_set_req_adt_get)) {
+			ip_set_printk("invalid ADT_GET (want %zu, got %d)",
+				      sizeof(struct ip_set_req_adt_get), *len);
+			res = -EINVAL;
+			goto done;
+		}
+		req_get->set.name[IP_SET_MAXNAMELEN - 1] = '\0';
+		index = ip_set_find_byname(req_get->set.name);
+		if (index != IP_SET_INVALID_ID) {
+			req_get->set.index = index;
+			strncpy(req_get->typename,
+				ip_set_list[index]->type->typename,
+				IP_SET_MAXNAMELEN - 1);
+		} else {
+			res = -ENOENT;
+			goto done;
+		}
+		goto copy;
+	}
+	case IP_SET_OP_MAX_SETS: {
+		struct ip_set_req_max_sets *req_max_sets
+			= (struct ip_set_req_max_sets *) data;
+		ip_set_id_t i;
+
+		if (*len != sizeof(struct ip_set_req_max_sets)) {
+			ip_set_printk("invalid MAX_SETS (want %zu, got %d)",
+				      sizeof(struct ip_set_req_max_sets), *len);
+			res = -EINVAL;
+			goto done;
+		}
+
+		if (strcmp(req_max_sets->set.name, IPSET_TOKEN_ALL) == 0) {
+			req_max_sets->set.index = IP_SET_INVALID_ID;
+		} else {
+			req_max_sets->set.name[IP_SET_MAXNAMELEN - 1] = '\0';
+			req_max_sets->set.index =
+				ip_set_find_byname(req_max_sets->set.name);
+			if (req_max_sets->set.index == IP_SET_INVALID_ID) {
+				res = -ENOENT;
+				goto done;
+			}
+		}
+		req_max_sets->max_sets = ip_set_max;
+		req_max_sets->sets = 0;
+		for (i = 0; i < ip_set_max; i++) {
+			if (ip_set_list[i] != NULL)
+				req_max_sets->sets++;
+		}
+		goto copy;
+	}
+	case IP_SET_OP_LIST_SIZE:
+	case IP_SET_OP_SAVE_SIZE: {
+		struct ip_set_req_setnames *req_setnames
+			= (struct ip_set_req_setnames *) data;
+		struct ip_set_name_list *name_list;
+		struct ip_set *set;
+		ip_set_id_t i;
+		int used;
+
+		if (*len < sizeof(struct ip_set_req_setnames)) {
+			ip_set_printk("short LIST_SIZE (want >=%zu, got %d)",
+				      sizeof(struct ip_set_req_setnames), *len);
+			res = -EINVAL;
+			goto done;
+		}
+
+		req_setnames->size = 0;
+		used = sizeof(struct ip_set_req_setnames);
+		for (i = 0; i < ip_set_max; i++) {
+			if (ip_set_list[i] == NULL)
+				continue;
+			name_list = (struct ip_set_name_list *)
+				(data + used);
+			used += sizeof(struct ip_set_name_list);
+			if (used > copylen) {
+				res = -EAGAIN;
+				goto done;
+			}
+			set = ip_set_list[i];
+			/* Fill in index, name, etc. */
+			name_list->index = i;
+			name_list->id = set->id;
+			strncpy(name_list->name,
+				set->name,
+				IP_SET_MAXNAMELEN - 1);
+			strncpy(name_list->typename,
+				set->type->typename,
+				IP_SET_MAXNAMELEN - 1);
+			DP("filled %s of type %s, index %u\n",
+			   name_list->name, name_list->typename,
+			   name_list->index);
+			if (!(req_setnames->index == IP_SET_INVALID_ID
+			      || req_setnames->index == i))
+			      continue;
+			/* Update size */
+			switch (*op) {
+			case IP_SET_OP_LIST_SIZE: {
+				req_setnames->size += sizeof(struct ip_set_list)
+					+ set->type->header_size
+					+ set->type->list_members_size(set);
+				/* Sets are identified by id in the hash */
+				FOREACH_HASH_DO(__set_hash_bindings_size_list,
+						set->id, &req_setnames->size);
+				break;
+			}
+			case IP_SET_OP_SAVE_SIZE: {
+				req_setnames->size += sizeof(struct ip_set_save)
+					+ set->type->header_size
+					+ set->type->list_members_size(set);
+				FOREACH_HASH_DO(__set_hash_bindings_size_save,
+						set->id, &req_setnames->size);
+				break;
+			}
+			default:
+				break;
+			}
+		}
+		if (copylen != used) {
+			res = -EAGAIN;
+			goto done;
+		}
+		goto copy;
+	}
+	case IP_SET_OP_LIST: {
+		struct ip_set_req_list *req_list
+			= (struct ip_set_req_list *) data;
+		ip_set_id_t i;
+		int used;
+
+		if (*len < sizeof(struct ip_set_req_list)) {
+			ip_set_printk("short LIST (want >=%zu, got %d)",
+				      sizeof(struct ip_set_req_list), *len);
+			res = -EINVAL;
+			goto done;
+		}
+		index = req_list->index;
+		if (index != IP_SET_INVALID_ID
+		    && ip_set_find_byindex(index) != index) {
+		    	res = -ENOENT;
+		    	goto done;
+		}
+		used = 0;
+		if (index == IP_SET_INVALID_ID) {
+			/* List all sets */
+			for (i = 0; i < ip_set_max && res == 0; i++) {
+				if (ip_set_list[i] != NULL)
+					res = ip_set_list_set(i, data, &used, *len);
+			}
+		} else {
+			/* List an individual set */
+			res = ip_set_list_set(index, data, &used, *len);
+		}
+		if (res != 0)
+			goto done;
+		else if (copylen != used) {
+			res = -EAGAIN;
+			goto done;
+		}
+		goto copy;
+	}
+	case IP_SET_OP_SAVE: {
+		struct ip_set_req_list *req_save
+			= (struct ip_set_req_list *) data;
+		ip_set_id_t i;
+		int used;
+
+		if (*len < sizeof(struct ip_set_req_list)) {
+			ip_set_printk("short SAVE (want >=%zu, got %d)",
+				      sizeof(struct ip_set_req_list), *len);
+			res = -EINVAL;
+			goto done;
+		}
+		index = req_save->index;
+		if (index != IP_SET_INVALID_ID
+		    && ip_set_find_byindex(index) != index) {
+		    	res = -ENOENT;
+		    	goto done;
+		}
+		used = 0;
+		if (index == IP_SET_INVALID_ID) {
+			/* Save all sets */
+			for (i = 0; i < ip_set_max && res == 0; i++) {
+				if (ip_set_list[i] != NULL)
+					res = ip_set_save_set(i, data, &used, *len);
+			}
+		} else {
+			/* Save an individual set */
+			res = ip_set_save_set(index, data, &used, *len);
+		}
+		if (res == 0)
+			res = ip_set_save_bindings(index, data, &used, *len);
+
+		if (res != 0)
+			goto done;
+		else if (copylen != used) {
+			res = -EAGAIN;
+			goto done;
+		}
+		goto copy;
+	}
+	case IP_SET_OP_RESTORE: {
+		struct ip_set_req_setnames *req_restore
+			= (struct ip_set_req_setnames *) data;
+		int line;
+
+		if (*len < sizeof(struct ip_set_req_setnames)
+		    || *len != req_restore->size) {
+			ip_set_printk("invalid RESTORE (want =%zu, got %d)",
+				      req_restore->size, *len);
+			res = -EINVAL;
+			goto done;
+		}
+		line = ip_set_restore(data + sizeof(struct ip_set_req_setnames),
+				      req_restore->size - sizeof(struct ip_set_req_setnames));
+		DP("ip_set_restore: %u", line);
+		if (line != 0) {
+			res = -EAGAIN;
+			req_restore->size = line;
+			copylen = sizeof(struct ip_set_req_setnames);
+			goto copy;
+		}
+		goto done;
+	}
+	default:
+		res = -EBADMSG;
+		goto done;
+	}	/* end of switch(op) */
+
+    copy:
+   	DP("set %s, copylen %u", index != IP_SET_INVALID_ID
+   	             		 && ip_set_list[index]
+   	             ? ip_set_list[index]->name
+   	             : ":all:", copylen);
+	res = copy_to_user(user, data, copylen);
+
+    done:
+	up(&ip_set_app_mutex);
+	vfree(data);
+	if (res > 0)
+		res = 0;
+	DP("final result %d", res);
+	return res;
+}
+
+static struct nf_sockopt_ops so_set = {
+	.pf 		= PF_INET,
+	.set_optmin 	= SO_IP_SET,
+	.set_optmax 	= SO_IP_SET + 1,
+	.set 		= &ip_set_sockfn_set,
+	.get_optmin 	= SO_IP_SET,
+	.get_optmax	= SO_IP_SET + 1,
+	.get		= &ip_set_sockfn_get,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)
+	.owner		= THIS_MODULE,
+#endif
+};
+
+static int max_sets, hash_size;
+module_param(max_sets, int, 0600);
+MODULE_PARM_DESC(max_sets, "maximal number of sets");
+module_param(hash_size, int, 0600);
+MODULE_PARM_DESC(hash_size, "hash size for bindings");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>");
+MODULE_DESCRIPTION("module implementing core IP set support");
+
+static int __init ip_set_init(void)
+{
+	int res;
+	ip_set_id_t i;
+
+	get_random_bytes(&ip_set_hash_random, 4);
+	if (max_sets)
+		ip_set_max = max_sets;
+	ip_set_list = vmalloc(sizeof(struct ip_set *) * ip_set_max);
+	if (!ip_set_list) {
+		printk(KERN_ERR "Unable to create ip_set_list\n");
+		return -ENOMEM;
+	}
+	memset(ip_set_list, 0, sizeof(struct ip_set *) * ip_set_max);
+	if (hash_size)
+		ip_set_bindings_hash_size = hash_size;
+	ip_set_hash = vmalloc(sizeof(struct list_head) * ip_set_bindings_hash_size);
+	if (!ip_set_hash) {
+		printk(KERN_ERR "Unable to create ip_set_hash\n");
+		vfree(ip_set_list);
+		return -ENOMEM;
+	}
+	for (i = 0; i < ip_set_bindings_hash_size; i++)
+		INIT_LIST_HEAD(&ip_set_hash[i]);
+
+	INIT_LIST_HEAD(&set_type_list);
+
+	res = nf_register_sockopt(&so_set);
+	if (res != 0) {
+		ip_set_printk("SO_SET registry failed: %d", res);
+		vfree(ip_set_list);
+		vfree(ip_set_hash);
+		return res;
+	}
+	return 0;
+}
+
+static void __exit ip_set_fini(void)
+{
+	/* There can't be any existing set or binding */
+	nf_unregister_sockopt(&so_set);
+	vfree(ip_set_list);
+	vfree(ip_set_hash);
+	DP("these are the famous last words");
+}
+
+EXPORT_SYMBOL(ip_set_register_set_type);
+EXPORT_SYMBOL(ip_set_unregister_set_type);
+
+EXPORT_SYMBOL(ip_set_get_byname);
+EXPORT_SYMBOL(ip_set_get_byindex);
+EXPORT_SYMBOL(ip_set_put);
+
+EXPORT_SYMBOL(ip_set_addip_kernel);
+EXPORT_SYMBOL(ip_set_delip_kernel);
+EXPORT_SYMBOL(ip_set_testip_kernel);
+
+module_init(ip_set_init);
+module_exit(ip_set_fini);
diff -Nru linux-2.6.30.5/net/ipv4/netfilter/ip_set_iphash.c linux-2.6.30.5-wrt/net/ipv4/netfilter/ip_set_iphash.c
--- linux-2.6.30.5/net/ipv4/netfilter/ip_set_iphash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/net/ipv4/netfilter/ip_set_iphash.c	2009-09-06 18:43:48.374667723 +0200
@@ -0,0 +1,429 @@
+/* Copyright (C) 2003-2004 Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/* Kernel module implementing an ip hash set */
+
+#include <linux/module.h>
+#include <linux/ip.h>
+#include <linux/skbuff.h>
+#include <linux/version.h>
+#include <linux/jhash.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ip_set.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+#include <asm/bitops.h>
+#include <linux/spinlock.h>
+#include <linux/vmalloc.h>
+#include <linux/random.h>
+
+#include <net/ip.h>
+
+#include <linux/netfilter_ipv4/ip_set_malloc.h>
+#include <linux/netfilter_ipv4/ip_set_iphash.h>
+
+static int limit = MAX_RANGE;
+
+static inline __u32
+jhash_ip(const struct ip_set_iphash *map, uint16_t i, ip_set_ip_t ip)
+{
+	return jhash_1word(ip, *(((uint32_t *) map->initval) + i));
+}
+
+static inline __u32
+hash_id(struct ip_set *set, ip_set_ip_t ip, ip_set_ip_t *hash_ip)
+{
+	struct ip_set_iphash *map = (struct ip_set_iphash *) set->data;
+	__u32 id;
+	u_int16_t i;
+	ip_set_ip_t *elem;
+
+	*hash_ip = ip & map->netmask;
+	DP("set: %s, ip:%u.%u.%u.%u, %u.%u.%u.%u, %u.%u.%u.%u",
+	   set->name, HIPQUAD(ip), HIPQUAD(*hash_ip), HIPQUAD(map->netmask));
+
+	for (i = 0; i < map->probes; i++) {
+		id = jhash_ip(map, i, *hash_ip) % map->hashsize;
+		DP("hash key: %u", id);
+		elem = HARRAY_ELEM(map->members, ip_set_ip_t *, id);
+		if (*elem == *hash_ip)
+			return id;
+		/* No shortcut at testing - there can be deleted
+		 * entries. */
+	}
+	return UINT_MAX;
+}
+
+static inline int
+__testip(struct ip_set *set, ip_set_ip_t ip, ip_set_ip_t *hash_ip)
+{
+	return (ip && hash_id(set, ip, hash_ip) != UINT_MAX);
+}
+
+static int
+testip(struct ip_set *set, const void *data, size_t size,
+       ip_set_ip_t *hash_ip)
+{
+	struct ip_set_req_iphash *req =
+	    (struct ip_set_req_iphash *) data;
+
+	if (size != sizeof(struct ip_set_req_iphash)) {
+		ip_set_printk("data length wrong (want %zu, have %zu)",
+			      sizeof(struct ip_set_req_iphash),
+			      size);
+		return -EINVAL;
+	}
+	return __testip(set, req->ip, hash_ip);
+}
+
+static int
+testip_kernel(struct ip_set *set,
+	      const struct sk_buff *skb,
+	      ip_set_ip_t *hash_ip,
+	      const u_int32_t *flags,
+	      unsigned char index)
+{
+	return __testip(set,
+			ntohl(flags[index] & IPSET_SRC
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+				? ip_hdr(skb)->saddr
+				: ip_hdr(skb)->daddr),
+#else
+				? skb->nh.iph->saddr
+				: skb->nh.iph->daddr),
+#endif
+			hash_ip);
+}
+
+static inline int
+__addip(struct ip_set_iphash *map, ip_set_ip_t ip, ip_set_ip_t *hash_ip)
+{
+	__u32 probe;
+	u_int16_t i;
+	ip_set_ip_t *elem;
+
+	if (!ip || map->elements >= limit)
+		return -ERANGE;
+
+	*hash_ip = ip & map->netmask;
+
+	for (i = 0; i < map->probes; i++) {
+		probe = jhash_ip(map, i, *hash_ip) % map->hashsize;
+		elem = HARRAY_ELEM(map->members, ip_set_ip_t *, probe);
+		if (*elem == *hash_ip)
+			return -EEXIST;
+		if (!*elem) {
+			*elem = *hash_ip;
+			map->elements++;
+			return 0;
+		}
+	}
+	/* Trigger rehashing */
+	return -EAGAIN;
+}
+
+static int
+addip(struct ip_set *set, const void *data, size_t size,
+        ip_set_ip_t *hash_ip)
+{
+	struct ip_set_req_iphash *req =
+	    (struct ip_set_req_iphash *) data;
+
+	if (size != sizeof(struct ip_set_req_iphash)) {
+		ip_set_printk("data length wrong (want %zu, have %zu)",
+			      sizeof(struct ip_set_req_iphash),
+			      size);
+		return -EINVAL;
+	}
+	return __addip((struct ip_set_iphash *) set->data, req->ip, hash_ip);
+}
+
+static int
+addip_kernel(struct ip_set *set,
+	     const struct sk_buff *skb,
+	     ip_set_ip_t *hash_ip,
+	     const u_int32_t *flags,
+	     unsigned char index)
+{
+	return __addip((struct ip_set_iphash *) set->data,
+		       ntohl(flags[index] & IPSET_SRC
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+				? ip_hdr(skb)->saddr
+				: ip_hdr(skb)->daddr),
+#else
+		       		? skb->nh.iph->saddr
+				: skb->nh.iph->daddr),
+#endif
+		       hash_ip);
+}
+
+static int retry(struct ip_set *set)
+{
+	struct ip_set_iphash *map = (struct ip_set_iphash *) set->data;
+	ip_set_ip_t hash_ip, *elem;
+	void *members;
+	u_int32_t i, hashsize = map->hashsize;
+	int res;
+	struct ip_set_iphash *tmp;
+
+	if (map->resize == 0)
+		return -ERANGE;
+
+    again:
+    	res = 0;
+
+	/* Calculate new hash size */
+	hashsize += (hashsize * map->resize)/100;
+	if (hashsize == map->hashsize)
+		hashsize++;
+
+	ip_set_printk("rehashing of set %s triggered: "
+		      "hashsize grows from %u to %u",
+		      set->name, map->hashsize, hashsize);
+
+	tmp = kmalloc(sizeof(struct ip_set_iphash)
+		      + map->probes * sizeof(uint32_t), GFP_ATOMIC);
+	if (!tmp) {
+		DP("out of memory for %d bytes",
+		   sizeof(struct ip_set_iphash)
+		   + map->probes * sizeof(uint32_t));
+		return -ENOMEM;
+	}
+	tmp->members = harray_malloc(hashsize, sizeof(ip_set_ip_t), GFP_ATOMIC);
+	if (!tmp->members) {
+		DP("out of memory for %d bytes", hashsize * sizeof(ip_set_ip_t));
+		kfree(tmp);
+		return -ENOMEM;
+	}
+	tmp->hashsize = hashsize;
+	tmp->elements = 0;
+	tmp->probes = map->probes;
+	tmp->resize = map->resize;
+	tmp->netmask = map->netmask;
+	memcpy(tmp->initval, map->initval, map->probes * sizeof(uint32_t));
+
+	write_lock_bh(&set->lock);
+	map = (struct ip_set_iphash *) set->data; /* Play safe */
+	for (i = 0; i < map->hashsize && res == 0; i++) {
+		elem = HARRAY_ELEM(map->members, ip_set_ip_t *, i);
+		if (*elem)
+			res = __addip(tmp, *elem, &hash_ip);
+	}
+	if (res) {
+		/* Failure, try again */
+		write_unlock_bh(&set->lock);
+		harray_free(tmp->members);
+		kfree(tmp);
+		goto again;
+	}
+
+	/* Success at resizing! */
+	members = map->members;
+
+	map->hashsize = tmp->hashsize;
+	map->members = tmp->members;
+	write_unlock_bh(&set->lock);
+
+	harray_free(members);
+	kfree(tmp);
+
+	return 0;
+}
+
+static inline int
+__delip(struct ip_set *set, ip_set_ip_t ip, ip_set_ip_t *hash_ip)
+{
+	struct ip_set_iphash *map = (struct ip_set_iphash *) set->data;
+	ip_set_ip_t id, *elem;
+
+	if (!ip)
+		return -ERANGE;
+
+	id = hash_id(set, ip, hash_ip);
+	if (id == UINT_MAX)
+		return -EEXIST;
+
+	elem = HARRAY_ELEM(map->members, ip_set_ip_t *, id);
+	*elem = 0;
+	map->elements--;
+
+	return 0;
+}
+
+static int
+delip(struct ip_set *set, const void *data, size_t size,
+        ip_set_ip_t *hash_ip)
+{
+	struct ip_set_req_iphash *req =
+	    (struct ip_set_req_iphash *) data;
+
+	if (size != sizeof(struct ip_set_req_iphash)) {
+		ip_set_printk("data length wrong (want %zu, have %zu)",
+			      sizeof(struct ip_set_req_iphash),
+			      size);
+		return -EINVAL;
+	}
+	return __delip(set, req->ip, hash_ip);
+}
+
+static int
+delip_kernel(struct ip_set *set,
+	     const struct sk_buff *skb,
+	     ip_set_ip_t *hash_ip,
+	     const u_int32_t *flags,
+	     unsigned char index)
+{
+	return __delip(set,
+		       ntohl(flags[index] & IPSET_SRC
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+				? ip_hdr(skb)->saddr
+				: ip_hdr(skb)->daddr),
+#else
+				? skb->nh.iph->saddr
+				: skb->nh.iph->daddr),
+#endif
+		       hash_ip);
+}
+
+static int create(struct ip_set *set, const void *data, size_t size)
+{
+	struct ip_set_req_iphash_create *req =
+	    (struct ip_set_req_iphash_create *) data;
+	struct ip_set_iphash *map;
+	uint16_t i;
+
+	if (size != sizeof(struct ip_set_req_iphash_create)) {
+		ip_set_printk("data length wrong (want %zu, have %zu)",
+			       sizeof(struct ip_set_req_iphash_create),
+			       size);
+		return -EINVAL;
+	}
+
+	if (req->hashsize < 1) {
+		ip_set_printk("hashsize too small");
+		return -ENOEXEC;
+	}
+
+	if (req->probes < 1) {
+		ip_set_printk("probes too small");
+		return -ENOEXEC;
+	}
+
+	map = kmalloc(sizeof(struct ip_set_iphash)
+		      + req->probes * sizeof(uint32_t), GFP_KERNEL);
+	if (!map) {
+		DP("out of memory for %d bytes",
+		   sizeof(struct ip_set_iphash)
+		   + req->probes * sizeof(uint32_t));
+		return -ENOMEM;
+	}
+	for (i = 0; i < req->probes; i++)
+		get_random_bytes(((uint32_t *) map->initval)+i, 4);
+	map->elements = 0;
+	map->hashsize = req->hashsize;
+	map->probes = req->probes;
+	map->resize = req->resize;
+	map->netmask = req->netmask;
+	map->members = harray_malloc(map->hashsize, sizeof(ip_set_ip_t), GFP_KERNEL);
+	if (!map->members) {
+		DP("out of memory for %d bytes", map->hashsize * sizeof(ip_set_ip_t));
+		kfree(map);
+		return -ENOMEM;
+	}
+
+	set->data = map;
+	return 0;
+}
+
+static void destroy(struct ip_set *set)
+{
+	struct ip_set_iphash *map = (struct ip_set_iphash *) set->data;
+
+	harray_free(map->members);
+	kfree(map);
+
+	set->data = NULL;
+}
+
+static void flush(struct ip_set *set)
+{
+	struct ip_set_iphash *map = (struct ip_set_iphash *) set->data;
+	harray_flush(map->members, map->hashsize, sizeof(ip_set_ip_t));
+	map->elements = 0;
+}
+
+static void list_header(const struct ip_set *set, void *data)
+{
+	struct ip_set_iphash *map = (struct ip_set_iphash *) set->data;
+	struct ip_set_req_iphash_create *header =
+	    (struct ip_set_req_iphash_create *) data;
+
+	header->hashsize = map->hashsize;
+	header->probes = map->probes;
+	header->resize = map->resize;
+	header->netmask = map->netmask;
+}
+
+static int list_members_size(const struct ip_set *set)
+{
+	struct ip_set_iphash *map = (struct ip_set_iphash *) set->data;
+
+	return (map->hashsize * sizeof(ip_set_ip_t));
+}
+
+static void list_members(const struct ip_set *set, void *data)
+{
+	struct ip_set_iphash *map = (struct ip_set_iphash *) set->data;
+	ip_set_ip_t i, *elem;
+
+	for (i = 0; i < map->hashsize; i++) {
+		elem = HARRAY_ELEM(map->members, ip_set_ip_t *, i);
+		((ip_set_ip_t *)data)[i] = *elem;
+	}
+}
+
+static struct ip_set_type ip_set_iphash = {
+	.typename		= SETTYPE_NAME,
+	.features		= IPSET_TYPE_IP | IPSET_DATA_SINGLE,
+	.protocol_version	= IP_SET_PROTOCOL_VERSION,
+	.create			= &create,
+	.destroy		= &destroy,
+	.flush			= &flush,
+	.reqsize		= sizeof(struct ip_set_req_iphash),
+	.addip			= &addip,
+	.addip_kernel		= &addip_kernel,
+	.retry			= &retry,
+	.delip			= &delip,
+	.delip_kernel		= &delip_kernel,
+	.testip			= &testip,
+	.testip_kernel		= &testip_kernel,
+	.header_size		= sizeof(struct ip_set_req_iphash_create),
+	.list_header		= &list_header,
+	.list_members_size	= &list_members_size,
+	.list_members		= &list_members,
+	.me			= THIS_MODULE,
+};
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>");
+MODULE_DESCRIPTION("iphash type of IP sets");
+module_param(limit, int, 0600);
+MODULE_PARM_DESC(limit, "maximal number of elements stored in the sets");
+
+static int __init ip_set_iphash_init(void)
+{
+	return ip_set_register_set_type(&ip_set_iphash);
+}
+
+static void __exit ip_set_iphash_fini(void)
+{
+	/* FIXME: possible race with ip_set_create() */
+	ip_set_unregister_set_type(&ip_set_iphash);
+}
+
+module_init(ip_set_iphash_init);
+module_exit(ip_set_iphash_fini);
diff -Nru linux-2.6.30.5/net/ipv4/netfilter/ip_set_ipmap.c linux-2.6.30.5-wrt/net/ipv4/netfilter/ip_set_ipmap.c
--- linux-2.6.30.5/net/ipv4/netfilter/ip_set_ipmap.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/net/ipv4/netfilter/ip_set_ipmap.c	2009-09-06 18:43:48.374667723 +0200
@@ -0,0 +1,336 @@
+/* Copyright (C) 2000-2002 Joakim Axelsson <gozem@linux.nu>
+ *                         Patrick Schaaf <bof@bof.de>
+ * Copyright (C) 2003-2004 Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/* Kernel module implementing an IP set type: the single bitmap type */
+
+#include <linux/module.h>
+#include <linux/ip.h>
+#include <linux/skbuff.h>
+#include <linux/version.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ip_set.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+#include <asm/bitops.h>
+#include <linux/spinlock.h>
+
+#include <linux/netfilter_ipv4/ip_set_ipmap.h>
+
+static inline ip_set_ip_t
+ip_to_id(const struct ip_set_ipmap *map, ip_set_ip_t ip)
+{
+	return (ip - map->first_ip)/map->hosts;
+}
+
+static inline int
+__testip(struct ip_set *set, ip_set_ip_t ip, ip_set_ip_t *hash_ip)
+{
+	struct ip_set_ipmap *map = (struct ip_set_ipmap *) set->data;
+
+	if (ip < map->first_ip || ip > map->last_ip)
+		return -ERANGE;
+
+	*hash_ip = ip & map->netmask;
+	DP("set: %s, ip:%u.%u.%u.%u, %u.%u.%u.%u",
+	   set->name, HIPQUAD(ip), HIPQUAD(*hash_ip));
+	return !!test_bit(ip_to_id(map, *hash_ip), map->members);
+}
+
+static int
+testip(struct ip_set *set, const void *data, size_t size,
+       ip_set_ip_t *hash_ip)
+{
+	struct ip_set_req_ipmap *req =
+	    (struct ip_set_req_ipmap *) data;
+
+	if (size != sizeof(struct ip_set_req_ipmap)) {
+		ip_set_printk("data length wrong (want %zu, have %zu)",
+			      sizeof(struct ip_set_req_ipmap),
+			      size);
+		return -EINVAL;
+	}
+	return __testip(set, req->ip, hash_ip);
+}
+
+static int
+testip_kernel(struct ip_set *set,
+	      const struct sk_buff *skb,
+	      ip_set_ip_t *hash_ip,
+	      const u_int32_t *flags,
+	      unsigned char index)
+{
+	int res =  __testip(set,
+			ntohl(flags[index] & IPSET_SRC
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+				? ip_hdr(skb)->saddr
+				: ip_hdr(skb)->daddr),
+#else
+				? skb->nh.iph->saddr
+				: skb->nh.iph->daddr),
+#endif
+			hash_ip);
+	return (res < 0 ? 0 : res);
+}
+
+static inline int
+__addip(struct ip_set *set, ip_set_ip_t ip, ip_set_ip_t *hash_ip)
+{
+	struct ip_set_ipmap *map = (struct ip_set_ipmap *) set->data;
+
+	if (ip < map->first_ip || ip > map->last_ip)
+		return -ERANGE;
+
+	*hash_ip = ip & map->netmask;
+	DP("%u.%u.%u.%u, %u.%u.%u.%u", HIPQUAD(ip), HIPQUAD(*hash_ip));
+	if (test_and_set_bit(ip_to_id(map, *hash_ip), map->members))
+		return -EEXIST;
+
+	return 0;
+}
+
+static int
+addip(struct ip_set *set, const void *data, size_t size,
+      ip_set_ip_t *hash_ip)
+{
+	struct ip_set_req_ipmap *req =
+	    (struct ip_set_req_ipmap *) data;
+
+	if (size != sizeof(struct ip_set_req_ipmap)) {
+		ip_set_printk("data length wrong (want %zu, have %zu)",
+			      sizeof(struct ip_set_req_ipmap),
+			      size);
+		return -EINVAL;
+	}
+	DP("%u.%u.%u.%u", HIPQUAD(req->ip));
+	return __addip(set, req->ip, hash_ip);
+}
+
+static int
+addip_kernel(struct ip_set *set,
+	     const struct sk_buff *skb,
+	     ip_set_ip_t *hash_ip,
+	     const u_int32_t *flags,
+	     unsigned char index)
+{
+	return __addip(set,
+		       ntohl(flags[index] & IPSET_SRC
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+				? ip_hdr(skb)->saddr
+				: ip_hdr(skb)->daddr),
+#else
+		       		? skb->nh.iph->saddr
+				: skb->nh.iph->daddr),
+#endif
+		       hash_ip);
+}
+
+static inline int
+__delip(struct ip_set *set, ip_set_ip_t ip, ip_set_ip_t *hash_ip)
+{
+	struct ip_set_ipmap *map = (struct ip_set_ipmap *) set->data;
+
+	if (ip < map->first_ip || ip > map->last_ip)
+		return -ERANGE;
+
+	*hash_ip = ip & map->netmask;
+	DP("%u.%u.%u.%u, %u.%u.%u.%u", HIPQUAD(ip), HIPQUAD(*hash_ip));
+	if (!test_and_clear_bit(ip_to_id(map, *hash_ip), map->members))
+		return -EEXIST;
+
+	return 0;
+}
+
+static int
+delip(struct ip_set *set, const void *data, size_t size,
+      ip_set_ip_t *hash_ip)
+{
+	struct ip_set_req_ipmap *req =
+	    (struct ip_set_req_ipmap *) data;
+
+	if (size != sizeof(struct ip_set_req_ipmap)) {
+		ip_set_printk("data length wrong (want %zu, have %zu)",
+			      sizeof(struct ip_set_req_ipmap),
+			      size);
+		return -EINVAL;
+	}
+	return __delip(set, req->ip, hash_ip);
+}
+
+static int
+delip_kernel(struct ip_set *set,
+	     const struct sk_buff *skb,
+	     ip_set_ip_t *hash_ip,
+	     const u_int32_t *flags,
+	     unsigned char index)
+{
+	return __delip(set,
+		       ntohl(flags[index] & IPSET_SRC
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+				? ip_hdr(skb)->saddr
+				: ip_hdr(skb)->daddr),
+#else
+				? skb->nh.iph->saddr
+				: skb->nh.iph->daddr),
+#endif
+		       hash_ip);
+}
+
+static int create(struct ip_set *set, const void *data, size_t size)
+{
+	int newbytes;
+	struct ip_set_req_ipmap_create *req =
+	    (struct ip_set_req_ipmap_create *) data;
+	struct ip_set_ipmap *map;
+
+	if (size != sizeof(struct ip_set_req_ipmap_create)) {
+		ip_set_printk("data length wrong (want %zu, have %zu)",
+			      sizeof(struct ip_set_req_ipmap_create),
+			      size);
+		return -EINVAL;
+	}
+
+	DP("from %u.%u.%u.%u to %u.%u.%u.%u",
+	   HIPQUAD(req->from), HIPQUAD(req->to));
+
+	if (req->from > req->to) {
+		DP("bad ip range");
+		return -ENOEXEC;
+	}
+
+	map = kmalloc(sizeof(struct ip_set_ipmap), GFP_KERNEL);
+	if (!map) {
+		DP("out of memory for %d bytes",
+		   sizeof(struct ip_set_ipmap));
+		return -ENOMEM;
+	}
+	map->first_ip = req->from;
+	map->last_ip = req->to;
+	map->netmask = req->netmask;
+
+	if (req->netmask == 0xFFFFFFFF) {
+		map->hosts = 1;
+		map->sizeid = map->last_ip - map->first_ip + 1;
+	} else {
+		unsigned int mask_bits, netmask_bits;
+		ip_set_ip_t mask;
+
+		map->first_ip &= map->netmask;	/* Should we better bark? */
+
+		mask = range_to_mask(map->first_ip, map->last_ip, &mask_bits);
+		netmask_bits = mask_to_bits(map->netmask);
+
+		if ((!mask && (map->first_ip || map->last_ip != 0xFFFFFFFF))
+		    || netmask_bits <= mask_bits)
+			return -ENOEXEC;
+
+		DP("mask_bits %u, netmask_bits %u",
+		   mask_bits, netmask_bits);
+		map->hosts = 2 << (32 - netmask_bits - 1);
+		map->sizeid = 2 << (netmask_bits - mask_bits - 1);
+	}
+	if (map->sizeid > MAX_RANGE + 1) {
+		ip_set_printk("range too big (max %d addresses)",
+			       MAX_RANGE+1);
+		kfree(map);
+		return -ENOEXEC;
+	}
+	DP("hosts %u, sizeid %u", map->hosts, map->sizeid);
+	newbytes = bitmap_bytes(0, map->sizeid - 1);
+	map->members = kmalloc(newbytes, GFP_KERNEL);
+	if (!map->members) {
+		DP("out of memory for %d bytes", newbytes);
+		kfree(map);
+		return -ENOMEM;
+	}
+	memset(map->members, 0, newbytes);
+
+	set->data = map;
+	return 0;
+}
+
+static void destroy(struct ip_set *set)
+{
+	struct ip_set_ipmap *map = (struct ip_set_ipmap *) set->data;
+
+	kfree(map->members);
+	kfree(map);
+
+	set->data = NULL;
+}
+
+static void flush(struct ip_set *set)
+{
+	struct ip_set_ipmap *map = (struct ip_set_ipmap *) set->data;
+	memset(map->members, 0, bitmap_bytes(0, map->sizeid - 1));
+}
+
+static void list_header(const struct ip_set *set, void *data)
+{
+	struct ip_set_ipmap *map = (struct ip_set_ipmap *) set->data;
+	struct ip_set_req_ipmap_create *header =
+	    (struct ip_set_req_ipmap_create *) data;
+
+	header->from = map->first_ip;
+	header->to = map->last_ip;
+	header->netmask = map->netmask;
+}
+
+static int list_members_size(const struct ip_set *set)
+{
+	struct ip_set_ipmap *map = (struct ip_set_ipmap *) set->data;
+
+	return bitmap_bytes(0, map->sizeid - 1);
+}
+
+static void list_members(const struct ip_set *set, void *data)
+{
+	struct ip_set_ipmap *map = (struct ip_set_ipmap *) set->data;
+	int bytes = bitmap_bytes(0, map->sizeid - 1);
+
+	memcpy(data, map->members, bytes);
+}
+
+static struct ip_set_type ip_set_ipmap = {
+	.typename		= SETTYPE_NAME,
+	.features		= IPSET_TYPE_IP | IPSET_DATA_SINGLE,
+	.protocol_version	= IP_SET_PROTOCOL_VERSION,
+	.create			= &create,
+	.destroy		= &destroy,
+	.flush			= &flush,
+	.reqsize		= sizeof(struct ip_set_req_ipmap),
+	.addip			= &addip,
+	.addip_kernel		= &addip_kernel,
+	.delip			= &delip,
+	.delip_kernel		= &delip_kernel,
+	.testip			= &testip,
+	.testip_kernel		= &testip_kernel,
+	.header_size		= sizeof(struct ip_set_req_ipmap_create),
+	.list_header		= &list_header,
+	.list_members_size	= &list_members_size,
+	.list_members		= &list_members,
+	.me			= THIS_MODULE,
+};
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>");
+MODULE_DESCRIPTION("ipmap type of IP sets");
+
+static int __init ip_set_ipmap_init(void)
+{
+	return ip_set_register_set_type(&ip_set_ipmap);
+}
+
+static void __exit ip_set_ipmap_fini(void)
+{
+	/* FIXME: possible race with ip_set_create() */
+	ip_set_unregister_set_type(&ip_set_ipmap);
+}
+
+module_init(ip_set_ipmap_init);
+module_exit(ip_set_ipmap_fini);
diff -Nru linux-2.6.30.5/net/ipv4/netfilter/ip_set_ipporthash.c linux-2.6.30.5-wrt/net/ipv4/netfilter/ip_set_ipporthash.c
--- linux-2.6.30.5/net/ipv4/netfilter/ip_set_ipporthash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/net/ipv4/netfilter/ip_set_ipporthash.c	2009-09-06 18:43:48.374667723 +0200
@@ -0,0 +1,581 @@
+/* Copyright (C) 2003-2004 Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/* Kernel module implementing an ip+port hash set */
+
+#include <linux/module.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+#include <linux/skbuff.h>
+#include <linux/version.h>
+#include <linux/jhash.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ip_set.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+#include <asm/bitops.h>
+#include <linux/spinlock.h>
+#include <linux/vmalloc.h>
+#include <linux/random.h>
+
+#include <net/ip.h>
+
+#include <linux/netfilter_ipv4/ip_set_malloc.h>
+#include <linux/netfilter_ipv4/ip_set_ipporthash.h>
+
+static int limit = MAX_RANGE;
+
+/* We must handle non-linear skbs */
+static inline ip_set_ip_t
+get_port(const struct sk_buff *skb, u_int32_t flags)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+	struct iphdr *iph = ip_hdr(skb);
+#else
+	struct iphdr *iph = skb->nh.iph;
+#endif
+	u_int16_t offset = ntohs(iph->frag_off) & IP_OFFSET;
+
+	switch (iph->protocol) {
+	case IPPROTO_TCP: {
+		struct tcphdr tcph;
+
+		/* See comments at tcp_match in ip_tables.c */
+		if (offset)
+			return INVALID_PORT;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+		if (skb_copy_bits(skb, ip_hdr(skb)->ihl*4, &tcph, sizeof(tcph)) < 0)
+#else
+		if (skb_copy_bits(skb, skb->nh.iph->ihl*4, &tcph, sizeof(tcph)) < 0)
+#endif
+			/* No choice either */
+			return INVALID_PORT;
+
+	     	return ntohs(flags & IPSET_SRC ?
+			     tcph.source : tcph.dest);
+	    }
+	case IPPROTO_UDP: {
+		struct udphdr udph;
+
+		if (offset)
+			return INVALID_PORT;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+		if (skb_copy_bits(skb, ip_hdr(skb)->ihl*4, &udph, sizeof(udph)) < 0)
+#else
+		if (skb_copy_bits(skb, skb->nh.iph->ihl*4, &udph, sizeof(udph)) < 0)
+#endif
+			/* No choice either */
+			return INVALID_PORT;
+
+	     	return ntohs(flags & IPSET_SRC ?
+			     udph.source : udph.dest);
+	    }
+	default:
+		return INVALID_PORT;
+	}
+}
+
+static inline __u32
+jhash_ip(const struct ip_set_ipporthash *map, uint16_t i, ip_set_ip_t ip)
+{
+	return jhash_1word(ip, *(((uint32_t *) map->initval) + i));
+}
+
+#define HASH_IP(map, ip, port) (port + ((ip - ((map)->first_ip)) << 16))
+
+static inline __u32
+hash_id(struct ip_set *set, ip_set_ip_t ip, ip_set_ip_t port,
+	ip_set_ip_t *hash_ip)
+{
+	struct ip_set_ipporthash *map =
+		(struct ip_set_ipporthash *) set->data;
+	__u32 id;
+	u_int16_t i;
+	ip_set_ip_t *elem;
+
+	*hash_ip = HASH_IP(map, ip, port);
+	DP("set: %s, ipport:%u.%u.%u.%u:%u, %u.%u.%u.%u",
+	   set->name, HIPQUAD(ip), port, HIPQUAD(*hash_ip));
+
+	for (i = 0; i < map->probes; i++) {
+		id = jhash_ip(map, i, *hash_ip) % map->hashsize;
+		DP("hash key: %u", id);
+		elem = HARRAY_ELEM(map->members, ip_set_ip_t *, id);
+		if (*elem == *hash_ip)
+			return id;
+		/* No shortcut at testing - there can be deleted
+		 * entries. */
+	}
+	return UINT_MAX;
+}
+
+static inline int
+__testip(struct ip_set *set, ip_set_ip_t ip, ip_set_ip_t port,
+	 ip_set_ip_t *hash_ip)
+{
+	struct ip_set_ipporthash *map = (struct ip_set_ipporthash *) set->data;
+
+	if (ip < map->first_ip || ip > map->last_ip)
+		return -ERANGE;
+
+	return (hash_id(set, ip, port, hash_ip) != UINT_MAX);
+}
+
+static int
+testip(struct ip_set *set, const void *data, size_t size,
+       ip_set_ip_t *hash_ip)
+{
+	struct ip_set_req_ipporthash *req =
+	    (struct ip_set_req_ipporthash *) data;
+
+	if (size != sizeof(struct ip_set_req_ipporthash)) {
+		ip_set_printk("data length wrong (want %zu, have %zu)",
+			      sizeof(struct ip_set_req_ipporthash),
+			      size);
+		return -EINVAL;
+	}
+	return __testip(set, req->ip, req->port, hash_ip);
+}
+
+static int
+testip_kernel(struct ip_set *set,
+	      const struct sk_buff *skb,
+	      ip_set_ip_t *hash_ip,
+	      const u_int32_t *flags,
+	      unsigned char index)
+{
+	ip_set_ip_t port;
+	int res;
+
+	if (flags[index+1] == 0)
+		return 0;
+
+	port = get_port(skb, flags[index+1]);
+
+	DP("flag: %s src: %u.%u.%u.%u dst: %u.%u.%u.%u",
+	   flags[index] & IPSET_SRC ? "SRC" : "DST",
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+	   NIPQUAD(ip_hdr(skb)->saddr),
+	   NIPQUAD(ip_hdr(skb)->daddr));
+#else
+	   NIPQUAD(skb->nh.iph->saddr),
+	   NIPQUAD(skb->nh.iph->daddr));
+#endif
+	DP("flag %s port %u",
+	   flags[index+1] & IPSET_SRC ? "SRC" : "DST",
+	   port);
+	if (port == INVALID_PORT)
+		return 0;
+
+	res =  __testip(set,
+			ntohl(flags[index] & IPSET_SRC
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+					? ip_hdr(skb)->saddr
+					: ip_hdr(skb)->daddr),
+#else
+					? skb->nh.iph->saddr
+					: skb->nh.iph->daddr),
+#endif
+			port,
+			hash_ip);
+	return (res < 0 ? 0 : res);
+
+}
+
+static inline int
+__add_haship(struct ip_set_ipporthash *map, ip_set_ip_t hash_ip)
+{
+	__u32 probe;
+	u_int16_t i;
+	ip_set_ip_t *elem;
+
+	for (i = 0; i < map->probes; i++) {
+		probe = jhash_ip(map, i, hash_ip) % map->hashsize;
+		elem = HARRAY_ELEM(map->members, ip_set_ip_t *, probe);
+		if (*elem == hash_ip)
+			return -EEXIST;
+		if (!*elem) {
+			*elem = hash_ip;
+			map->elements++;
+			return 0;
+		}
+	}
+	/* Trigger rehashing */
+	return -EAGAIN;
+}
+
+static inline int
+__addip(struct ip_set_ipporthash *map, ip_set_ip_t ip, ip_set_ip_t port,
+	ip_set_ip_t *hash_ip)
+{
+	if (map->elements > limit)
+		return -ERANGE;
+	if (ip < map->first_ip || ip > map->last_ip)
+		return -ERANGE;
+
+	*hash_ip = HASH_IP(map, ip, port);
+
+	return __add_haship(map, *hash_ip);
+}
+
+static int
+addip(struct ip_set *set, const void *data, size_t size,
+        ip_set_ip_t *hash_ip)
+{
+	struct ip_set_req_ipporthash *req =
+	    (struct ip_set_req_ipporthash *) data;
+
+	if (size != sizeof(struct ip_set_req_ipporthash)) {
+		ip_set_printk("data length wrong (want %zu, have %zu)",
+			      sizeof(struct ip_set_req_ipporthash),
+			      size);
+		return -EINVAL;
+	}
+	return __addip((struct ip_set_ipporthash *) set->data,
+			req->ip, req->port, hash_ip);
+}
+
+static int
+addip_kernel(struct ip_set *set,
+	     const struct sk_buff *skb,
+	     ip_set_ip_t *hash_ip,
+	     const u_int32_t *flags,
+	     unsigned char index)
+{
+	ip_set_ip_t port;
+
+	if (flags[index+1] == 0)
+		return -EINVAL;
+
+	port = get_port(skb, flags[index+1]);
+
+	DP("flag: %s src: %u.%u.%u.%u dst: %u.%u.%u.%u",
+	   flags[index] & IPSET_SRC ? "SRC" : "DST",
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+	   NIPQUAD(ip_hdr(skb)->saddr),
+	   NIPQUAD(ip_hdr(skb)->daddr));
+#else
+	   NIPQUAD(skb->nh.iph->saddr),
+	   NIPQUAD(skb->nh.iph->daddr));
+#endif
+	DP("flag %s port %u",
+	   flags[index+1] & IPSET_SRC ? "SRC" : "DST",
+	   port);
+	if (port == INVALID_PORT)
+		return -EINVAL;
+
+	return __addip((struct ip_set_ipporthash *) set->data,
+		       ntohl(flags[index] & IPSET_SRC
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+				? ip_hdr(skb)->saddr
+				: ip_hdr(skb)->daddr),
+#else
+		       		? skb->nh.iph->saddr
+				: skb->nh.iph->daddr),
+#endif
+		       port,
+		       hash_ip);
+}
+
+static int retry(struct ip_set *set)
+{
+	struct ip_set_ipporthash *map = (struct ip_set_ipporthash *) set->data;
+	ip_set_ip_t *elem;
+	void *members;
+	u_int32_t i, hashsize = map->hashsize;
+	int res;
+	struct ip_set_ipporthash *tmp;
+
+	if (map->resize == 0)
+		return -ERANGE;
+
+    again:
+    	res = 0;
+
+	/* Calculate new hash size */
+	hashsize += (hashsize * map->resize)/100;
+	if (hashsize == map->hashsize)
+		hashsize++;
+
+	ip_set_printk("rehashing of set %s triggered: "
+		      "hashsize grows from %u to %u",
+		      set->name, map->hashsize, hashsize);
+
+	tmp = kmalloc(sizeof(struct ip_set_ipporthash)
+		      + map->probes * sizeof(uint32_t), GFP_ATOMIC);
+	if (!tmp) {
+		DP("out of memory for %d bytes",
+		   sizeof(struct ip_set_ipporthash)
+		   + map->probes * sizeof(uint32_t));
+		return -ENOMEM;
+	}
+	tmp->members = harray_malloc(hashsize, sizeof(ip_set_ip_t), GFP_ATOMIC);
+	if (!tmp->members) {
+		DP("out of memory for %d bytes", hashsize * sizeof(ip_set_ip_t));
+		kfree(tmp);
+		return -ENOMEM;
+	}
+	tmp->hashsize = hashsize;
+	tmp->elements = 0;
+	tmp->probes = map->probes;
+	tmp->resize = map->resize;
+	tmp->first_ip = map->first_ip;
+	tmp->last_ip = map->last_ip;
+	memcpy(tmp->initval, map->initval, map->probes * sizeof(uint32_t));
+
+	write_lock_bh(&set->lock);
+	map = (struct ip_set_ipporthash *) set->data; /* Play safe */
+	for (i = 0; i < map->hashsize && res == 0; i++) {
+		elem = HARRAY_ELEM(map->members, ip_set_ip_t *, i);
+		if (*elem)
+			res = __add_haship(tmp, *elem);
+	}
+	if (res) {
+		/* Failure, try again */
+		write_unlock_bh(&set->lock);
+		harray_free(tmp->members);
+		kfree(tmp);
+		goto again;
+	}
+
+	/* Success at resizing! */
+	members = map->members;
+
+	map->hashsize = tmp->hashsize;
+	map->members = tmp->members;
+	write_unlock_bh(&set->lock);
+
+	harray_free(members);
+	kfree(tmp);
+
+	return 0;
+}
+
+static inline int
+__delip(struct ip_set *set, ip_set_ip_t ip, ip_set_ip_t port,
+	ip_set_ip_t *hash_ip)
+{
+	struct ip_set_ipporthash *map = (struct ip_set_ipporthash *) set->data;
+	ip_set_ip_t id;
+	ip_set_ip_t *elem;
+
+	if (ip < map->first_ip || ip > map->last_ip)
+		return -ERANGE;
+
+	id = hash_id(set, ip, port, hash_ip);
+
+	if (id == UINT_MAX)
+		return -EEXIST;
+
+	elem = HARRAY_ELEM(map->members, ip_set_ip_t *, id);
+	*elem = 0;
+	map->elements--;
+
+	return 0;
+}
+
+static int
+delip(struct ip_set *set, const void *data, size_t size,
+        ip_set_ip_t *hash_ip)
+{
+	struct ip_set_req_ipporthash *req =
+	    (struct ip_set_req_ipporthash *) data;
+
+	if (size != sizeof(struct ip_set_req_ipporthash)) {
+		ip_set_printk("data length wrong (want %zu, have %zu)",
+			      sizeof(struct ip_set_req_ipporthash),
+			      size);
+		return -EINVAL;
+	}
+	return __delip(set, req->ip, req->port, hash_ip);
+}
+
+static int
+delip_kernel(struct ip_set *set,
+	     const struct sk_buff *skb,
+	     ip_set_ip_t *hash_ip,
+	     const u_int32_t *flags,
+	     unsigned char index)
+{
+	ip_set_ip_t port;
+
+	if (flags[index+1] == 0)
+		return -EINVAL;
+
+	port = get_port(skb, flags[index+1]);
+
+	DP("flag: %s src: %u.%u.%u.%u dst: %u.%u.%u.%u",
+	   flags[index] & IPSET_SRC ? "SRC" : "DST",
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+	   NIPQUAD(ip_hdr(skb)->saddr),
+	   NIPQUAD(ip_hdr(skb)->daddr));
+#else
+	   NIPQUAD(skb->nh.iph->saddr),
+	   NIPQUAD(skb->nh.iph->daddr));
+#endif
+	DP("flag %s port %u",
+	   flags[index+1] & IPSET_SRC ? "SRC" : "DST",
+	   port);
+	if (port == INVALID_PORT)
+		return -EINVAL;
+
+	return __delip(set,
+		       ntohl(flags[index] & IPSET_SRC
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+				? ip_hdr(skb)->saddr
+				: ip_hdr(skb)->daddr),
+#else
+		       		? skb->nh.iph->saddr
+				: skb->nh.iph->daddr),
+#endif
+		       port,
+		       hash_ip);
+}
+
+static int create(struct ip_set *set, const void *data, size_t size)
+{
+	struct ip_set_req_ipporthash_create *req =
+	    (struct ip_set_req_ipporthash_create *) data;
+	struct ip_set_ipporthash *map;
+	uint16_t i;
+
+	if (size != sizeof(struct ip_set_req_ipporthash_create)) {
+		ip_set_printk("data length wrong (want %zu, have %zu)",
+			       sizeof(struct ip_set_req_ipporthash_create),
+			       size);
+		return -EINVAL;
+	}
+
+	if (req->hashsize < 1) {
+		ip_set_printk("hashsize too small");
+		return -ENOEXEC;
+	}
+
+	if (req->probes < 1) {
+		ip_set_printk("probes too small");
+		return -ENOEXEC;
+	}
+
+	map = kmalloc(sizeof(struct ip_set_ipporthash)
+		      + req->probes * sizeof(uint32_t), GFP_KERNEL);
+	if (!map) {
+		DP("out of memory for %d bytes",
+		   sizeof(struct ip_set_ipporthash)
+		   + req->probes * sizeof(uint32_t));
+		return -ENOMEM;
+	}
+	for (i = 0; i < req->probes; i++)
+		get_random_bytes(((uint32_t *) map->initval)+i, 4);
+	map->elements = 0;
+	map->hashsize = req->hashsize;
+	map->probes = req->probes;
+	map->resize = req->resize;
+	map->first_ip = req->from;
+	map->last_ip = req->to;
+	map->members = harray_malloc(map->hashsize, sizeof(ip_set_ip_t), GFP_KERNEL);
+	if (!map->members) {
+		DP("out of memory for %d bytes", map->hashsize * sizeof(ip_set_ip_t));
+		kfree(map);
+		return -ENOMEM;
+	}
+
+	set->data = map;
+	return 0;
+}
+
+static void destroy(struct ip_set *set)
+{
+	struct ip_set_ipporthash *map = (struct ip_set_ipporthash *) set->data;
+
+	harray_free(map->members);
+	kfree(map);
+
+	set->data = NULL;
+}
+
+static void flush(struct ip_set *set)
+{
+	struct ip_set_ipporthash *map = (struct ip_set_ipporthash *) set->data;
+	harray_flush(map->members, map->hashsize, sizeof(ip_set_ip_t));
+	map->elements = 0;
+}
+
+static void list_header(const struct ip_set *set, void *data)
+{
+	struct ip_set_ipporthash *map = (struct ip_set_ipporthash *) set->data;
+	struct ip_set_req_ipporthash_create *header =
+	    (struct ip_set_req_ipporthash_create *) data;
+
+	header->hashsize = map->hashsize;
+	header->probes = map->probes;
+	header->resize = map->resize;
+	header->from = map->first_ip;
+	header->to = map->last_ip;
+}
+
+static int list_members_size(const struct ip_set *set)
+{
+	struct ip_set_ipporthash *map = (struct ip_set_ipporthash *) set->data;
+
+	return (map->hashsize * sizeof(ip_set_ip_t));
+}
+
+static void list_members(const struct ip_set *set, void *data)
+{
+	struct ip_set_ipporthash *map = (struct ip_set_ipporthash *) set->data;
+	ip_set_ip_t i, *elem;
+
+	for (i = 0; i < map->hashsize; i++) {
+		elem = HARRAY_ELEM(map->members, ip_set_ip_t *, i);
+		((ip_set_ip_t *)data)[i] = *elem;
+	}
+}
+
+static struct ip_set_type ip_set_ipporthash = {
+	.typename		= SETTYPE_NAME,
+	.features		= IPSET_TYPE_IP | IPSET_TYPE_PORT | IPSET_DATA_DOUBLE,
+	.protocol_version	= IP_SET_PROTOCOL_VERSION,
+	.create			= &create,
+	.destroy		= &destroy,
+	.flush			= &flush,
+	.reqsize		= sizeof(struct ip_set_req_ipporthash),
+	.addip			= &addip,
+	.addip_kernel		= &addip_kernel,
+	.retry			= &retry,
+	.delip			= &delip,
+	.delip_kernel		= &delip_kernel,
+	.testip			= &testip,
+	.testip_kernel		= &testip_kernel,
+	.header_size		= sizeof(struct ip_set_req_ipporthash_create),
+	.list_header		= &list_header,
+	.list_members_size	= &list_members_size,
+	.list_members		= &list_members,
+	.me			= THIS_MODULE,
+};
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>");
+MODULE_DESCRIPTION("ipporthash type of IP sets");
+module_param(limit, int, 0600);
+MODULE_PARM_DESC(limit, "maximal number of elements stored in the sets");
+
+static int __init ip_set_ipporthash_init(void)
+{
+	return ip_set_register_set_type(&ip_set_ipporthash);
+}
+
+static void __exit ip_set_ipporthash_fini(void)
+{
+	/* FIXME: possible race with ip_set_create() */
+	ip_set_unregister_set_type(&ip_set_ipporthash);
+}
+
+module_init(ip_set_ipporthash_init);
+module_exit(ip_set_ipporthash_fini);
diff -Nru linux-2.6.30.5/net/ipv4/netfilter/ip_set_iptree.c linux-2.6.30.5-wrt/net/ipv4/netfilter/ip_set_iptree.c
--- linux-2.6.30.5/net/ipv4/netfilter/ip_set_iptree.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/net/ipv4/netfilter/ip_set_iptree.c	2009-09-06 18:43:48.374667723 +0200
@@ -0,0 +1,612 @@
+/* Copyright (C) 2005 Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/* Kernel module implementing an IP set type: the iptree type */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/ip.h>
+#include <linux/skbuff.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ip_set.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+#include <asm/bitops.h>
+#include <linux/spinlock.h>
+
+/* Backward compatibility */
+#ifndef __nocast
+#define __nocast
+#endif
+
+#include <linux/netfilter_ipv4/ip_set_iptree.h>
+
+static int limit = MAX_RANGE;
+
+/* Garbage collection interval in seconds: */
+#define IPTREE_GC_TIME		5*60
+/* Sleep so many milliseconds before trying again
+ * to delete the gc timer at destroying/flushing a set */
+#define IPTREE_DESTROY_SLEEP	100
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,21)
+static struct kmem_cache *branch_cachep;
+static struct kmem_cache *leaf_cachep;
+#else
+static kmem_cache_t *branch_cachep;
+static kmem_cache_t *leaf_cachep;
+#endif
+
+#if defined(__LITTLE_ENDIAN)
+#define ABCD(a,b,c,d,addrp) do {		\
+	a = ((unsigned char *)addrp)[3];	\
+	b = ((unsigned char *)addrp)[2];	\
+	c = ((unsigned char *)addrp)[1];	\
+	d = ((unsigned char *)addrp)[0];	\
+} while (0)
+#elif defined(__BIG_ENDIAN)
+#define ABCD(a,b,c,d,addrp) do {		\
+	a = ((unsigned char *)addrp)[0];	\
+	b = ((unsigned char *)addrp)[1];	\
+	c = ((unsigned char *)addrp)[2];	\
+	d = ((unsigned char *)addrp)[3];	\
+} while (0)
+#else
+#error "Please fix asm/byteorder.h"
+#endif /* __LITTLE_ENDIAN */
+
+#define TESTIP_WALK(map, elem, branch) do {	\
+	if ((map)->tree[elem]) {		\
+		branch = (map)->tree[elem];	\
+	} else 					\
+		return 0;			\
+} while (0)
+
+static inline int
+__testip(struct ip_set *set, ip_set_ip_t ip, ip_set_ip_t *hash_ip)
+{
+	struct ip_set_iptree *map = (struct ip_set_iptree *) set->data;
+	struct ip_set_iptreeb *btree;
+	struct ip_set_iptreec *ctree;
+	struct ip_set_iptreed *dtree;
+	unsigned char a,b,c,d;
+
+	if (!ip)
+		return -ERANGE;
+
+	*hash_ip = ip;
+	ABCD(a, b, c, d, hash_ip);
+	DP("%u %u %u %u timeout %u", a, b, c, d, map->timeout);
+	TESTIP_WALK(map, a, btree);
+	TESTIP_WALK(btree, b, ctree);
+	TESTIP_WALK(ctree, c, dtree);
+	DP("%lu %lu", dtree->expires[d], jiffies);
+	return dtree->expires[d]
+	       && (!map->timeout
+		   || time_after(dtree->expires[d], jiffies));
+}
+
+static int
+testip(struct ip_set *set, const void *data, size_t size,
+       ip_set_ip_t *hash_ip)
+{
+	struct ip_set_req_iptree *req =
+	    (struct ip_set_req_iptree *) data;
+
+	if (size != sizeof(struct ip_set_req_iptree)) {
+		ip_set_printk("data length wrong (want %zu, have %zu)",
+			      sizeof(struct ip_set_req_iptree),
+			      size);
+		return -EINVAL;
+	}
+	return __testip(set, req->ip, hash_ip);
+}
+
+static int
+testip_kernel(struct ip_set *set,
+	      const struct sk_buff *skb,
+	      ip_set_ip_t *hash_ip,
+	      const u_int32_t *flags,
+	      unsigned char index)
+{
+	int res;
+
+	DP("flag: %s src: %u.%u.%u.%u dst: %u.%u.%u.%u",
+	   flags[index] & IPSET_SRC ? "SRC" : "DST",
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+	   NIPQUAD(ip_hdr(skb)->saddr),
+	   NIPQUAD(ip_hdr(skb)->daddr));
+#else
+	   NIPQUAD(skb->nh.iph->saddr),
+	   NIPQUAD(skb->nh.iph->daddr));
+#endif
+
+	res =  __testip(set,
+			ntohl(flags[index] & IPSET_SRC
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+				? ip_hdr(skb)->saddr
+				: ip_hdr(skb)->daddr),
+#else
+				? skb->nh.iph->saddr
+				: skb->nh.iph->daddr),
+#endif
+			hash_ip);
+	return (res < 0 ? 0 : res);
+}
+
+#define ADDIP_WALK(map, elem, branch, type, cachep) do {	\
+	if ((map)->tree[elem]) {				\
+		DP("found %u", elem);				\
+		branch = (map)->tree[elem];			\
+	} else {						\
+		branch = (type *)				\
+			kmem_cache_alloc(cachep, GFP_ATOMIC);	\
+		if (branch == NULL)				\
+			return -ENOMEM;				\
+		memset(branch, 0, sizeof(*branch));		\
+		(map)->tree[elem] = branch;			\
+		DP("alloc %u", elem);				\
+	}							\
+} while (0)
+
+static inline int
+__addip(struct ip_set *set, ip_set_ip_t ip, unsigned int timeout,
+	ip_set_ip_t *hash_ip)
+{
+	struct ip_set_iptree *map = (struct ip_set_iptree *) set->data;
+	struct ip_set_iptreeb *btree;
+	struct ip_set_iptreec *ctree;
+	struct ip_set_iptreed *dtree;
+	unsigned char a,b,c,d;
+	int ret = 0;
+
+	if (!ip || map->elements >= limit)
+		/* We could call the garbage collector
+		 * but it's probably overkill */
+		return -ERANGE;
+
+	*hash_ip = ip;
+	ABCD(a, b, c, d, hash_ip);
+	DP("%u %u %u %u timeout %u", a, b, c, d, timeout);
+	ADDIP_WALK(map, a, btree, struct ip_set_iptreeb, branch_cachep);
+	ADDIP_WALK(btree, b, ctree, struct ip_set_iptreec, branch_cachep);
+	ADDIP_WALK(ctree, c, dtree, struct ip_set_iptreed, leaf_cachep);
+	if (dtree->expires[d]
+	    && (!map->timeout || time_after(dtree->expires[d], jiffies)))
+	    	ret = -EEXIST;
+	dtree->expires[d] = map->timeout ? (timeout * HZ + jiffies) : 1;
+	/* Lottery: I won! */
+	if (dtree->expires[d] == 0)
+		dtree->expires[d] = 1;
+	DP("%u %lu", d, dtree->expires[d]);
+	if (ret == 0)
+		map->elements++;
+	return ret;
+}
+
+static int
+addip(struct ip_set *set, const void *data, size_t size,
+      ip_set_ip_t *hash_ip)
+{
+	struct ip_set_iptree *map = (struct ip_set_iptree *) set->data;
+	struct ip_set_req_iptree *req =
+		(struct ip_set_req_iptree *) data;
+
+	if (size != sizeof(struct ip_set_req_iptree)) {
+		ip_set_printk("data length wrong (want %zu, have %zu)",
+			      sizeof(struct ip_set_req_iptree),
+			      size);
+		return -EINVAL;
+	}
+	DP("%u.%u.%u.%u %u", HIPQUAD(req->ip), req->timeout);
+	return __addip(set, req->ip,
+		       req->timeout ? req->timeout : map->timeout,
+		       hash_ip);
+}
+
+static int
+addip_kernel(struct ip_set *set,
+	     const struct sk_buff *skb,
+	     ip_set_ip_t *hash_ip,
+	     const u_int32_t *flags,
+	     unsigned char index)
+{
+	struct ip_set_iptree *map = (struct ip_set_iptree *) set->data;
+
+	return __addip(set,
+		       ntohl(flags[index] & IPSET_SRC
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+				? ip_hdr(skb)->saddr
+				: ip_hdr(skb)->daddr),
+#else
+		       		? skb->nh.iph->saddr
+				: skb->nh.iph->daddr),
+#endif
+		       map->timeout,
+		       hash_ip);
+}
+
+#define DELIP_WALK(map, elem, branch) do {	\
+	if ((map)->tree[elem]) {		\
+		branch = (map)->tree[elem];	\
+	} else 					\
+		return -EEXIST;			\
+} while (0)
+
+static inline int
+__delip(struct ip_set *set, ip_set_ip_t ip, ip_set_ip_t *hash_ip)
+{
+	struct ip_set_iptree *map = (struct ip_set_iptree *) set->data;
+	struct ip_set_iptreeb *btree;
+	struct ip_set_iptreec *ctree;
+	struct ip_set_iptreed *dtree;
+	unsigned char a,b,c,d;
+
+	if (!ip)
+		return -ERANGE;
+
+	*hash_ip = ip;
+	ABCD(a, b, c, d, hash_ip);
+	DELIP_WALK(map, a, btree);
+	DELIP_WALK(btree, b, ctree);
+	DELIP_WALK(ctree, c, dtree);
+
+	if (dtree->expires[d]) {
+		dtree->expires[d] = 0;
+		map->elements--;
+		return 0;
+	}
+	return -EEXIST;
+}
+
+static int
+delip(struct ip_set *set, const void *data, size_t size,
+      ip_set_ip_t *hash_ip)
+{
+	struct ip_set_req_iptree *req =
+	    (struct ip_set_req_iptree *) data;
+
+	if (size != sizeof(struct ip_set_req_iptree)) {
+		ip_set_printk("data length wrong (want %zu, have %zu)",
+			      sizeof(struct ip_set_req_iptree),
+			      size);
+		return -EINVAL;
+	}
+	return __delip(set, req->ip, hash_ip);
+}
+
+static int
+delip_kernel(struct ip_set *set,
+	     const struct sk_buff *skb,
+	     ip_set_ip_t *hash_ip,
+	     const u_int32_t *flags,
+	     unsigned char index)
+{
+	return __delip(set,
+		       ntohl(flags[index] & IPSET_SRC
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+				? ip_hdr(skb)->saddr
+				: ip_hdr(skb)->daddr),
+#else
+		       		? skb->nh.iph->saddr
+				: skb->nh.iph->daddr),
+#endif
+		       hash_ip);
+}
+
+#define LOOP_WALK_BEGIN(map, i, branch) \
+	for (i = 0; i < 256; i++) {	\
+		if (!(map)->tree[i])	\
+			continue;	\
+		branch = (map)->tree[i]
+
+#define LOOP_WALK_END }
+
+static void ip_tree_gc(unsigned long ul_set)
+{
+	struct ip_set *set = (void *) ul_set;
+	struct ip_set_iptree *map = (struct ip_set_iptree *) set->data;
+	struct ip_set_iptreeb *btree;
+	struct ip_set_iptreec *ctree;
+	struct ip_set_iptreed *dtree;
+	unsigned int a,b,c,d;
+	unsigned char i,j,k;
+
+	i = j = k = 0;
+	DP("gc: %s", set->name);
+	write_lock_bh(&set->lock);
+	LOOP_WALK_BEGIN(map, a, btree);
+	LOOP_WALK_BEGIN(btree, b, ctree);
+	LOOP_WALK_BEGIN(ctree, c, dtree);
+	for (d = 0; d < 256; d++) {
+		if (dtree->expires[d]) {
+			DP("gc: %u %u %u %u: expires %lu jiffies %lu",
+			    a, b, c, d,
+			    dtree->expires[d], jiffies);
+			if (map->timeout
+			    && time_before(dtree->expires[d], jiffies)) {
+			    	dtree->expires[d] = 0;
+			    	map->elements--;
+			} else
+				k = 1;
+		}
+	}
+	if (k == 0) {
+		DP("gc: %s: leaf %u %u %u empty",
+		    set->name, a, b, c);
+		kmem_cache_free(leaf_cachep, dtree);
+		ctree->tree[c] = NULL;
+	} else {
+		DP("gc: %s: leaf %u %u %u not empty",
+		    set->name, a, b, c);
+		j = 1;
+		k = 0;
+	}
+	LOOP_WALK_END;
+	if (j == 0) {
+		DP("gc: %s: branch %u %u empty",
+		    set->name, a, b);
+		kmem_cache_free(branch_cachep, ctree);
+		btree->tree[b] = NULL;
+	} else {
+		DP("gc: %s: branch %u %u not empty",
+		    set->name, a, b);
+		i = 1;
+		j = k = 0;
+	}
+	LOOP_WALK_END;
+	if (i == 0) {
+		DP("gc: %s: branch %u empty",
+		    set->name, a);
+		kmem_cache_free(branch_cachep, btree);
+		map->tree[a] = NULL;
+	} else {
+		DP("gc: %s: branch %u not empty",
+		    set->name, a);
+		i = j = k = 0;
+	}
+	LOOP_WALK_END;
+	write_unlock_bh(&set->lock);
+
+	map->gc.expires = jiffies + map->gc_interval * HZ;
+	add_timer(&map->gc);
+}
+
+static inline void init_gc_timer(struct ip_set *set)
+{
+	struct ip_set_iptree *map = (struct ip_set_iptree *) set->data;
+
+	/* Even if there is no timeout for the entries,
+	 * we still have to call gc because delete
+	 * do not clean up empty branches */
+	map->gc_interval = IPTREE_GC_TIME;
+	init_timer(&map->gc);
+	map->gc.data = (unsigned long) set;
+	map->gc.function = ip_tree_gc;
+	map->gc.expires = jiffies + map->gc_interval * HZ;
+	add_timer(&map->gc);
+}
+
+static int create(struct ip_set *set, const void *data, size_t size)
+{
+	struct ip_set_req_iptree_create *req =
+	    (struct ip_set_req_iptree_create *) data;
+	struct ip_set_iptree *map;
+
+	if (size != sizeof(struct ip_set_req_iptree_create)) {
+		ip_set_printk("data length wrong (want %zu, have %zu)",
+			      sizeof(struct ip_set_req_iptree_create),
+			      size);
+		return -EINVAL;
+	}
+
+	map = kmalloc(sizeof(struct ip_set_iptree), GFP_KERNEL);
+	if (!map) {
+		DP("out of memory for %d bytes",
+		   sizeof(struct ip_set_iptree));
+		return -ENOMEM;
+	}
+	memset(map, 0, sizeof(*map));
+	map->timeout = req->timeout;
+	map->elements = 0;
+	set->data = map;
+
+	init_gc_timer(set);
+
+	return 0;
+}
+
+static void __flush(struct ip_set_iptree *map)
+{
+	struct ip_set_iptreeb *btree;
+	struct ip_set_iptreec *ctree;
+	struct ip_set_iptreed *dtree;
+	unsigned int a,b,c;
+
+	LOOP_WALK_BEGIN(map, a, btree);
+	LOOP_WALK_BEGIN(btree, b, ctree);
+	LOOP_WALK_BEGIN(ctree, c, dtree);
+	kmem_cache_free(leaf_cachep, dtree);
+	LOOP_WALK_END;
+	kmem_cache_free(branch_cachep, ctree);
+	LOOP_WALK_END;
+	kmem_cache_free(branch_cachep, btree);
+	LOOP_WALK_END;
+	map->elements = 0;
+}
+
+static void destroy(struct ip_set *set)
+{
+	struct ip_set_iptree *map = (struct ip_set_iptree *) set->data;
+
+	/* gc might be running */
+	while (!del_timer(&map->gc))
+		msleep(IPTREE_DESTROY_SLEEP);
+	__flush(map);
+	kfree(map);
+	set->data = NULL;
+}
+
+static void flush(struct ip_set *set)
+{
+	struct ip_set_iptree *map = (struct ip_set_iptree *) set->data;
+	unsigned int timeout = map->timeout;
+
+	/* gc might be running */
+	while (!del_timer(&map->gc))
+		msleep(IPTREE_DESTROY_SLEEP);
+	__flush(map);
+	memset(map, 0, sizeof(*map));
+	map->timeout = timeout;
+
+	init_gc_timer(set);
+}
+
+static void list_header(const struct ip_set *set, void *data)
+{
+	struct ip_set_iptree *map = (struct ip_set_iptree *) set->data;
+	struct ip_set_req_iptree_create *header =
+	    (struct ip_set_req_iptree_create *) data;
+
+	header->timeout = map->timeout;
+}
+
+static int list_members_size(const struct ip_set *set)
+{
+	struct ip_set_iptree *map = (struct ip_set_iptree *) set->data;
+	struct ip_set_iptreeb *btree;
+	struct ip_set_iptreec *ctree;
+	struct ip_set_iptreed *dtree;
+	unsigned int a,b,c,d;
+	unsigned int count = 0;
+
+	LOOP_WALK_BEGIN(map, a, btree);
+	LOOP_WALK_BEGIN(btree, b, ctree);
+	LOOP_WALK_BEGIN(ctree, c, dtree);
+	for (d = 0; d < 256; d++) {
+		if (dtree->expires[d]
+		    && (!map->timeout || time_after(dtree->expires[d], jiffies)))
+		    	count++;
+	}
+	LOOP_WALK_END;
+	LOOP_WALK_END;
+	LOOP_WALK_END;
+
+	DP("members %u", count);
+	return (count * sizeof(struct ip_set_req_iptree));
+}
+
+static void list_members(const struct ip_set *set, void *data)
+{
+	struct ip_set_iptree *map = (struct ip_set_iptree *) set->data;
+	struct ip_set_iptreeb *btree;
+	struct ip_set_iptreec *ctree;
+	struct ip_set_iptreed *dtree;
+	unsigned int a,b,c,d;
+	size_t offset = 0;
+	struct ip_set_req_iptree *entry;
+
+	LOOP_WALK_BEGIN(map, a, btree);
+	LOOP_WALK_BEGIN(btree, b, ctree);
+	LOOP_WALK_BEGIN(ctree, c, dtree);
+	for (d = 0; d < 256; d++) {
+		if (dtree->expires[d]
+		    && (!map->timeout || time_after(dtree->expires[d], jiffies))) {
+		    	entry = (struct ip_set_req_iptree *)(data + offset);
+		    	entry->ip = ((a << 24) | (b << 16) | (c << 8) | d);
+		    	entry->timeout = !map->timeout ? 0
+				: (dtree->expires[d] - jiffies)/HZ;
+			offset += sizeof(struct ip_set_req_iptree);
+		}
+	}
+	LOOP_WALK_END;
+	LOOP_WALK_END;
+	LOOP_WALK_END;
+}
+
+static struct ip_set_type ip_set_iptree = {
+	.typename		= SETTYPE_NAME,
+	.features		= IPSET_TYPE_IP | IPSET_DATA_SINGLE,
+	.protocol_version	= IP_SET_PROTOCOL_VERSION,
+	.create			= &create,
+	.destroy		= &destroy,
+	.flush			= &flush,
+	.reqsize		= sizeof(struct ip_set_req_iptree),
+	.addip			= &addip,
+	.addip_kernel		= &addip_kernel,
+	.delip			= &delip,
+	.delip_kernel		= &delip_kernel,
+	.testip			= &testip,
+	.testip_kernel		= &testip_kernel,
+	.header_size		= sizeof(struct ip_set_req_iptree_create),
+	.list_header		= &list_header,
+	.list_members_size	= &list_members_size,
+	.list_members		= &list_members,
+	.me			= THIS_MODULE,
+};
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>");
+MODULE_DESCRIPTION("iptree type of IP sets");
+module_param(limit, int, 0600);
+MODULE_PARM_DESC(limit, "maximal number of elements stored in the sets");
+
+static int __init ip_set_iptree_init(void)
+{
+	int ret;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)
+	branch_cachep = kmem_cache_create("ip_set_iptreeb",
+				sizeof(struct ip_set_iptreeb),
+				0, 0, NULL);
+#else
+	branch_cachep = kmem_cache_create("ip_set_iptreeb",
+				sizeof(struct ip_set_iptreeb),
+				0, 0, NULL, NULL);
+#endif
+	if (!branch_cachep) {
+		printk(KERN_ERR "Unable to create ip_set_iptreeb slab cache\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)
+	leaf_cachep = kmem_cache_create("ip_set_iptreed",
+				sizeof(struct ip_set_iptreed),
+				0, 0, NULL);
+#else
+	leaf_cachep = kmem_cache_create("ip_set_iptreed",
+				sizeof(struct ip_set_iptreed),
+				0, 0, NULL, NULL);
+#endif
+	if (!leaf_cachep) {
+		printk(KERN_ERR "Unable to create ip_set_iptreed slab cache\n");
+		ret = -ENOMEM;
+		goto free_branch;
+	}
+	ret = ip_set_register_set_type(&ip_set_iptree);
+	if (ret == 0)
+		goto out;
+
+	kmem_cache_destroy(leaf_cachep);
+    free_branch:
+	kmem_cache_destroy(branch_cachep);
+    out:
+	return ret;
+}
+
+static void __exit ip_set_iptree_fini(void)
+{
+	/* FIXME: possible race with ip_set_create() */
+	ip_set_unregister_set_type(&ip_set_iptree);
+	kmem_cache_destroy(leaf_cachep);
+	kmem_cache_destroy(branch_cachep);
+}
+
+module_init(ip_set_iptree_init);
+module_exit(ip_set_iptree_fini);
diff -Nru linux-2.6.30.5/net/ipv4/netfilter/ip_set_iptreemap.c linux-2.6.30.5-wrt/net/ipv4/netfilter/ip_set_iptreemap.c
--- linux-2.6.30.5/net/ipv4/netfilter/ip_set_iptreemap.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/net/ipv4/netfilter/ip_set_iptreemap.c	2009-09-06 18:43:48.378666801 +0200
@@ -0,0 +1,829 @@
+/* Copyright (C) 2007 Sven Wegener <sven.wegener@stealer.net>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+/* This modules implements the iptreemap ipset type. It uses bitmaps to
+ * represent every single IPv4 address as a single bit. The bitmaps are managed
+ * in a tree structure, where the first three octets of an addresses are used
+ * as an index to find the bitmap and the last octet is used as the bit number.
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/ip.h>
+#include <linux/skbuff.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ip_set.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+#include <asm/bitops.h>
+#include <linux/spinlock.h>
+
+#include <linux/netfilter_ipv4/ip_set_iptreemap.h>
+
+#define IPTREEMAP_DEFAULT_GC_TIME (5 * 60)
+#define IPTREEMAP_DESTROY_SLEEP (100)
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,21)
+static struct kmem_cache *cachep_b;
+static struct kmem_cache *cachep_c;
+static struct kmem_cache *cachep_d;
+#else
+static kmem_cache_t *cachep_b;
+static kmem_cache_t *cachep_c;
+static kmem_cache_t *cachep_d;
+#endif
+
+static struct ip_set_iptreemap_d *fullbitmap_d;
+static struct ip_set_iptreemap_c *fullbitmap_c;
+static struct ip_set_iptreemap_b *fullbitmap_b;
+
+#if defined(__LITTLE_ENDIAN)
+#define ABCD(a, b, c, d, addr) \
+	do { \
+		a = ((unsigned char *)addr)[3]; \
+		b = ((unsigned char *)addr)[2]; \
+		c = ((unsigned char *)addr)[1]; \
+		d = ((unsigned char *)addr)[0]; \
+	} while (0)
+#elif defined(__BIG_ENDIAN)
+#define ABCD(a,b,c,d,addrp) do {		\
+	a = ((unsigned char *)addrp)[0];	\
+	b = ((unsigned char *)addrp)[1];	\
+	c = ((unsigned char *)addrp)[2];	\
+	d = ((unsigned char *)addrp)[3];	\
+} while (0)
+#else
+#error "Please fix asm/byteorder.h"
+#endif /* __LITTLE_ENDIAN */
+
+#define TESTIP_WALK(map, elem, branch, full) \
+	do { \
+		branch = (map)->tree[elem]; \
+		if (!branch) \
+			return 0; \
+		else if (branch == full) \
+			return 1; \
+	} while (0)
+
+#define ADDIP_WALK(map, elem, branch, type, cachep, full) \
+	do { \
+		branch = (map)->tree[elem]; \
+		if (!branch) { \
+			branch = (type *) kmem_cache_alloc(cachep, GFP_ATOMIC); \
+			if (!branch) \
+				return -ENOMEM; \
+			memset(branch, 0, sizeof(*branch)); \
+			(map)->tree[elem] = branch; \
+		} else if (branch == full) { \
+			return -EEXIST; \
+		} \
+	} while (0)
+
+#define ADDIP_RANGE_LOOP(map, a, a1, a2, hint, branch, full, cachep, free) \
+	for (a = a1; a <= a2; a++) { \
+		branch = (map)->tree[a]; \
+		if (branch != full) { \
+			if ((a > a1 && a < a2) || (hint)) { \
+				if (branch) \
+					free(branch); \
+				(map)->tree[a] = full; \
+				continue; \
+			} else if (!branch) { \
+				branch = kmem_cache_alloc(cachep, GFP_ATOMIC); \
+				if (!branch) \
+					return -ENOMEM; \
+				memset(branch, 0, sizeof(*branch)); \
+				(map)->tree[a] = branch; \
+			}
+
+#define ADDIP_RANGE_LOOP_END() \
+		} \
+	}
+
+#define DELIP_WALK(map, elem, branch, cachep, full, flags) \
+	do { \
+		branch = (map)->tree[elem]; \
+		if (!branch) { \
+			return -EEXIST; \
+		} else if (branch == full) { \
+			branch = kmem_cache_alloc(cachep, flags); \
+			if (!branch) \
+				return -ENOMEM; \
+			memcpy(branch, full, sizeof(*full)); \
+			(map)->tree[elem] = branch; \
+		} \
+	} while (0)
+
+#define DELIP_RANGE_LOOP(map, a, a1, a2, hint, branch, full, cachep, free, flags) \
+	for (a = a1; a <= a2; a++) { \
+		branch = (map)->tree[a]; \
+		if (branch) { \
+			if ((a > a1 && a < a2) || (hint)) { \
+				if (branch != full) \
+					free(branch); \
+				(map)->tree[a] = NULL; \
+				continue; \
+			} else if (branch == full) { \
+				branch = kmem_cache_alloc(cachep, flags); \
+				if (!branch) \
+					return -ENOMEM; \
+				memcpy(branch, full, sizeof(*branch)); \
+				(map)->tree[a] = branch; \
+			}
+
+#define DELIP_RANGE_LOOP_END() \
+		} \
+	}
+
+#define LOOP_WALK_BEGIN(map, i, branch) \
+	for (i = 0; i < 256; i++) { \
+		branch = (map)->tree[i]; \
+		if (likely(!branch)) \
+			continue;
+
+#define LOOP_WALK_END() \
+	}
+
+#define LOOP_WALK_BEGIN_GC(map, i, branch, full, cachep, count) \
+	count = -256; \
+	for (i = 0; i < 256; i++) { \
+		branch = (map)->tree[i]; \
+		if (likely(!branch)) \
+			continue; \
+		count++; \
+		if (branch == full) { \
+			count++; \
+			continue; \
+		}
+
+#define LOOP_WALK_END_GC(map, i, branch, full, cachep, count) \
+		if (-256 == count) { \
+			kmem_cache_free(cachep, branch); \
+			(map)->tree[i] = NULL; \
+		} else if (256 == count) { \
+			kmem_cache_free(cachep, branch); \
+			(map)->tree[i] = full; \
+		} \
+	}
+
+#define LOOP_WALK_BEGIN_COUNT(map, i, branch, inrange, count) \
+	for (i = 0; i < 256; i++) { \
+		if (!(map)->tree[i]) { \
+			if (inrange) { \
+				count++; \
+				inrange = 0; \
+			} \
+			continue; \
+		} \
+		branch = (map)->tree[i];
+
+#define LOOP_WALK_END_COUNT() \
+	}
+
+#define MIN(a, b) (a < b ? a : b)
+#define MAX(a, b) (a > b ? a : b)
+
+#define GETVALUE1(a, a1, b1, r) \
+	(a == a1 ? b1 : r)
+
+#define GETVALUE2(a, b, a1, b1, c1, r) \
+	(a == a1 && b == b1 ? c1 : r)
+
+#define GETVALUE3(a, b, c, a1, b1, c1, d1, r) \
+	(a == a1 && b == b1 && c == c1 ? d1 : r)
+
+#define CHECK1(a, a1, a2, b1, b2, c1, c2, d1, d2) \
+	( \
+		GETVALUE1(a, a1, b1, 0) == 0 \
+		&& GETVALUE1(a, a2, b2, 255) == 255 \
+		&& c1 == 0 \
+		&& c2 == 255 \
+		&& d1 == 0 \
+		&& d2 == 255 \
+	)
+
+#define CHECK2(a, b, a1, a2, b1, b2, c1, c2, d1, d2) \
+	( \
+		GETVALUE2(a, b, a1, b1, c1, 0) == 0 \
+		&& GETVALUE2(a, b, a2, b2, c2, 255) == 255 \
+		&& d1 == 0 \
+		&& d2 == 255 \
+	)
+
+#define CHECK3(a, b, c, a1, a2, b1, b2, c1, c2, d1, d2) \
+	( \
+		GETVALUE3(a, b, c, a1, b1, c1, d1, 0) == 0 \
+		&& GETVALUE3(a, b, c, a2, b2, c2, d2, 255) == 255 \
+	)
+
+
+static inline void
+free_d(struct ip_set_iptreemap_d *map)
+{
+	kmem_cache_free(cachep_d, map);
+}
+
+static inline void
+free_c(struct ip_set_iptreemap_c *map)
+{
+	struct ip_set_iptreemap_d *dtree;
+	unsigned int i;
+
+	LOOP_WALK_BEGIN(map, i, dtree) {
+		if (dtree != fullbitmap_d)
+			free_d(dtree);
+	} LOOP_WALK_END();
+
+	kmem_cache_free(cachep_c, map);
+}
+
+static inline void
+free_b(struct ip_set_iptreemap_b *map)
+{
+	struct ip_set_iptreemap_c *ctree;
+	unsigned int i;
+
+	LOOP_WALK_BEGIN(map, i, ctree) {
+		if (ctree != fullbitmap_c)
+			free_c(ctree);
+	} LOOP_WALK_END();
+
+	kmem_cache_free(cachep_b, map);
+}
+
+static inline int
+__testip(struct ip_set *set, ip_set_ip_t ip, ip_set_ip_t *hash_ip)
+{
+	struct ip_set_iptreemap *map = (struct ip_set_iptreemap *) set->data;
+	struct ip_set_iptreemap_b *btree;
+	struct ip_set_iptreemap_c *ctree;
+	struct ip_set_iptreemap_d *dtree;
+	unsigned char a, b, c, d;
+
+	*hash_ip = ip;
+
+	ABCD(a, b, c, d, hash_ip);
+
+	TESTIP_WALK(map, a, btree, fullbitmap_b);
+	TESTIP_WALK(btree, b, ctree, fullbitmap_c);
+	TESTIP_WALK(ctree, c, dtree, fullbitmap_d);
+
+	return !!test_bit(d, (void *) dtree->bitmap);
+}
+
+static int
+testip(struct ip_set *set, const void *data, size_t size, ip_set_ip_t *hash_ip)
+{
+	struct ip_set_req_iptreemap *req = (struct ip_set_req_iptreemap *) data;
+
+	if (size != sizeof(struct ip_set_req_iptreemap)) {
+		ip_set_printk("data length wrong (want %zu, have %zu)", sizeof(struct ip_set_req_iptreemap), size);
+		return -EINVAL;
+	}
+
+	return __testip(set, req->start, hash_ip);
+}
+
+static int
+testip_kernel(struct ip_set *set, const struct sk_buff *skb, ip_set_ip_t *hash_ip, const u_int32_t *flags, unsigned char index)
+{
+	int res;
+
+	res = __testip(set,
+		       ntohl(flags[index] & IPSET_SRC
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+				? ip_hdr(skb)->saddr
+				: ip_hdr(skb)->daddr),
+#else
+				? skb->nh.iph->saddr
+				: skb->nh.iph->daddr),
+#endif
+		       hash_ip);
+
+	return (res < 0 ? 0 : res);
+}
+
+static inline int
+__addip_single(struct ip_set *set, ip_set_ip_t ip, ip_set_ip_t *hash_ip)
+{
+	struct ip_set_iptreemap *map = (struct ip_set_iptreemap *) set->data;
+	struct ip_set_iptreemap_b *btree;
+	struct ip_set_iptreemap_c *ctree;
+	struct ip_set_iptreemap_d *dtree;
+	unsigned char a, b, c, d;
+
+	*hash_ip = ip;
+
+	ABCD(a, b, c, d, hash_ip);
+
+	ADDIP_WALK(map, a, btree, struct ip_set_iptreemap_b, cachep_b, fullbitmap_b);
+	ADDIP_WALK(btree, b, ctree, struct ip_set_iptreemap_c, cachep_c, fullbitmap_c);
+	ADDIP_WALK(ctree, c, dtree, struct ip_set_iptreemap_d, cachep_d, fullbitmap_d);
+
+	if (test_and_set_bit(d, (void *) dtree->bitmap))
+		return -EEXIST;
+
+	set_bit(b, (void *) btree->dirty);
+
+	return 0;
+}
+
+static inline int
+__addip_range(struct ip_set *set, ip_set_ip_t start, ip_set_ip_t end, ip_set_ip_t *hash_ip)
+{
+	struct ip_set_iptreemap *map = (struct ip_set_iptreemap *) set->data;
+	struct ip_set_iptreemap_b *btree;
+	struct ip_set_iptreemap_c *ctree;
+	struct ip_set_iptreemap_d *dtree;
+	unsigned int a, b, c, d;
+	unsigned char a1, b1, c1, d1;
+	unsigned char a2, b2, c2, d2;
+
+	if (start == end)
+		return __addip_single(set, start, hash_ip);
+
+	*hash_ip = start;
+
+	ABCD(a1, b1, c1, d1, &start);
+	ABCD(a2, b2, c2, d2, &end);
+
+	/* This is sooo ugly... */
+	ADDIP_RANGE_LOOP(map, a, a1, a2, CHECK1(a, a1, a2, b1, b2, c1, c2, d1, d2), btree, fullbitmap_b, cachep_b, free_b) {
+		ADDIP_RANGE_LOOP(btree, b, GETVALUE1(a, a1, b1, 0), GETVALUE1(a, a2, b2, 255), CHECK2(a, b, a1, a2, b1, b2, c1, c2, d1, d2), ctree, fullbitmap_c, cachep_c, free_c) {
+			ADDIP_RANGE_LOOP(ctree, c, GETVALUE2(a, b, a1, b1, c1, 0), GETVALUE2(a, b, a2, b2, c2, 255), CHECK3(a, b, c, a1, a2, b1, b2, c1, c2, d1, d2), dtree, fullbitmap_d, cachep_d, free_d) {
+				for (d = GETVALUE3(a, b, c, a1, b1, c1, d1, 0); d <= GETVALUE3(a, b, c, a2, b2, c2, d2, 255); d++)
+					set_bit(d, (void *) dtree->bitmap);
+				set_bit(b, (void *) btree->dirty);
+			} ADDIP_RANGE_LOOP_END();
+		} ADDIP_RANGE_LOOP_END();
+	} ADDIP_RANGE_LOOP_END();
+
+	return 0;
+}
+
+static int
+addip(struct ip_set *set, const void *data, size_t size, ip_set_ip_t *hash_ip)
+{
+	struct ip_set_req_iptreemap *req = (struct ip_set_req_iptreemap *) data;
+
+	if (size != sizeof(struct ip_set_req_iptreemap)) {
+		ip_set_printk("data length wrong (want %zu, have %zu)", sizeof(struct ip_set_req_iptreemap), size);
+		return -EINVAL;
+	}
+
+	return __addip_range(set, MIN(req->start, req->end), MAX(req->start, req->end), hash_ip);
+}
+
+static int
+addip_kernel(struct ip_set *set, const struct sk_buff *skb, ip_set_ip_t *hash_ip, const u_int32_t *flags, unsigned char index)
+{
+
+	return __addip_single(set,
+			ntohl(flags[index] & IPSET_SRC
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+				? ip_hdr(skb)->saddr
+				: ip_hdr(skb)->daddr),
+#else
+				? skb->nh.iph->saddr
+				: skb->nh.iph->daddr),
+#endif
+			hash_ip);
+}
+
+static inline int
+__delip_single(struct ip_set *set, ip_set_ip_t ip, ip_set_ip_t *hash_ip, unsigned int __nocast flags)
+{
+	struct ip_set_iptreemap *map = (struct ip_set_iptreemap *) set->data;
+	struct ip_set_iptreemap_b *btree;
+	struct ip_set_iptreemap_c *ctree;
+	struct ip_set_iptreemap_d *dtree;
+	unsigned char a,b,c,d;
+
+	*hash_ip = ip;
+
+	ABCD(a, b, c, d, hash_ip);
+
+	DELIP_WALK(map, a, btree, cachep_b, fullbitmap_b, flags);
+	DELIP_WALK(btree, b, ctree, cachep_c, fullbitmap_c, flags);
+	DELIP_WALK(ctree, c, dtree, cachep_d, fullbitmap_d, flags);
+
+	if (!test_and_clear_bit(d, (void *) dtree->bitmap))
+		return -EEXIST;
+
+	set_bit(b, (void *) btree->dirty);
+
+	return 0;
+}
+
+static inline int
+__delip_range(struct ip_set *set, ip_set_ip_t start, ip_set_ip_t end, ip_set_ip_t *hash_ip, unsigned int __nocast flags)
+{
+	struct ip_set_iptreemap *map = (struct ip_set_iptreemap *) set->data;
+	struct ip_set_iptreemap_b *btree;
+	struct ip_set_iptreemap_c *ctree;
+	struct ip_set_iptreemap_d *dtree;
+	unsigned int a, b, c, d;
+	unsigned char a1, b1, c1, d1;
+	unsigned char a2, b2, c2, d2;
+
+	if (start == end)
+		return __delip_single(set, start, hash_ip, flags);
+
+	*hash_ip = start;
+
+	ABCD(a1, b1, c1, d1, &start);
+	ABCD(a2, b2, c2, d2, &end);
+
+	/* This is sooo ugly... */
+	DELIP_RANGE_LOOP(map, a, a1, a2, CHECK1(a, a1, a2, b1, b2, c1, c2, d1, d2), btree, fullbitmap_b, cachep_b, free_b, flags) {
+		DELIP_RANGE_LOOP(btree, b, GETVALUE1(a, a1, b1, 0), GETVALUE1(a, a2, b2, 255), CHECK2(a, b, a1, a2, b1, b2, c1, c2, d1, d2), ctree, fullbitmap_c, cachep_c, free_c, flags) {
+			DELIP_RANGE_LOOP(ctree, c, GETVALUE2(a, b, a1, b1, c1, 0), GETVALUE2(a, b, a2, b2, c2, 255), CHECK3(a, b, c, a1, a2, b1, b2, c1, c2, d1, d2), dtree, fullbitmap_d, cachep_d, free_d, flags) {
+				for (d = GETVALUE3(a, b, c, a1, b1, c1, d1, 0); d <= GETVALUE3(a, b, c, a2, b2, c2, d2, 255); d++)
+					clear_bit(d, (void *) dtree->bitmap);
+				set_bit(b, (void *) btree->dirty);
+			} DELIP_RANGE_LOOP_END();
+		} DELIP_RANGE_LOOP_END();
+	} DELIP_RANGE_LOOP_END();
+
+	return 0;
+}
+
+static int
+delip(struct ip_set *set, const void *data, size_t size, ip_set_ip_t *hash_ip)
+{
+	struct ip_set_req_iptreemap *req = (struct ip_set_req_iptreemap *) data;
+
+	if (size != sizeof(struct ip_set_req_iptreemap)) {
+		ip_set_printk("data length wrong (want %zu, have %zu)", sizeof(struct ip_set_req_iptreemap), size);
+		return -EINVAL;
+	}
+
+	return __delip_range(set, MIN(req->start, req->end), MAX(req->start, req->end), hash_ip, GFP_KERNEL);
+}
+
+static int
+delip_kernel(struct ip_set *set, const struct sk_buff *skb, ip_set_ip_t *hash_ip, const u_int32_t *flags, unsigned char index)
+{
+	return __delip_single(set,
+			ntohl(flags[index] & IPSET_SRC
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+				? ip_hdr(skb)->saddr
+				: ip_hdr(skb)->daddr),
+#else
+				? skb->nh.iph->saddr
+				: skb->nh.iph->daddr),
+#endif
+			hash_ip,
+		        GFP_ATOMIC);
+}
+
+/* Check the status of the bitmap
+ * -1 == all bits cleared
+ *  1 == all bits set
+ *  0 == anything else
+ */
+static inline int
+bitmap_status(struct ip_set_iptreemap_d *dtree)
+{
+	unsigned char first = dtree->bitmap[0];
+	int a;
+
+	for (a = 1; a < 32; a++)
+		if (dtree->bitmap[a] != first)
+			return 0;
+
+	return (first == 0 ? -1 : (first == 255 ? 1 : 0));
+}
+
+static void
+gc(unsigned long addr)
+{
+	struct ip_set *set = (struct ip_set *) addr;
+	struct ip_set_iptreemap *map = (struct ip_set_iptreemap *) set->data;
+	struct ip_set_iptreemap_b *btree;
+	struct ip_set_iptreemap_c *ctree;
+	struct ip_set_iptreemap_d *dtree;
+	unsigned int a, b, c;
+	int i, j, k;
+
+	write_lock_bh(&set->lock);
+
+	LOOP_WALK_BEGIN_GC(map, a, btree, fullbitmap_b, cachep_b, i) {
+		LOOP_WALK_BEGIN_GC(btree, b, ctree, fullbitmap_c, cachep_c, j) {
+			if (!test_and_clear_bit(b, (void *) btree->dirty))
+				continue;
+			LOOP_WALK_BEGIN_GC(ctree, c, dtree, fullbitmap_d, cachep_d, k) {
+				switch (bitmap_status(dtree)) {
+					case -1:
+						kmem_cache_free(cachep_d, dtree);
+						ctree->tree[c] = NULL;
+						k--;
+					break;
+					case 1:
+						kmem_cache_free(cachep_d, dtree);
+						ctree->tree[c] = fullbitmap_d;
+						k++;
+					break;
+				}
+			} LOOP_WALK_END();
+		} LOOP_WALK_END_GC(btree, b, ctree, fullbitmap_c, cachep_c, k);
+	} LOOP_WALK_END_GC(map, a, btree, fullbitmap_b, cachep_b, j);
+
+	write_unlock_bh(&set->lock);
+
+	map->gc.expires = jiffies + map->gc_interval * HZ;
+	add_timer(&map->gc);
+}
+
+static inline void
+init_gc_timer(struct ip_set *set)
+{
+	struct ip_set_iptreemap *map = (struct ip_set_iptreemap *) set->data;
+
+	init_timer(&map->gc);
+	map->gc.data = (unsigned long) set;
+	map->gc.function = gc;
+	map->gc.expires = jiffies + map->gc_interval * HZ;
+	add_timer(&map->gc);
+}
+
+static int create(struct ip_set *set, const void *data, size_t size)
+{
+	struct ip_set_req_iptreemap_create *req = (struct ip_set_req_iptreemap_create *) data;
+	struct ip_set_iptreemap *map;
+
+	if (size != sizeof(struct ip_set_req_iptreemap_create)) {
+		ip_set_printk("data length wrong (want %zu, have %zu)", sizeof(struct ip_set_req_iptreemap_create), size);
+		return -EINVAL;
+	}
+
+	map = kzalloc(sizeof(*map), GFP_KERNEL);
+	if (!map)
+		return -ENOMEM;
+
+	map->gc_interval = req->gc_interval ? req->gc_interval : IPTREEMAP_DEFAULT_GC_TIME;
+	set->data = map;
+
+	init_gc_timer(set);
+
+	return 0;
+}
+
+static inline void __flush(struct ip_set_iptreemap *map)
+{
+	struct ip_set_iptreemap_b *btree;
+	unsigned int a;
+
+	LOOP_WALK_BEGIN(map, a, btree);
+		if (btree != fullbitmap_b)
+			free_b(btree);
+	LOOP_WALK_END();
+}
+
+static void destroy(struct ip_set *set)
+{
+	struct ip_set_iptreemap *map = (struct ip_set_iptreemap *) set->data;
+
+	while (!del_timer(&map->gc))
+		msleep(IPTREEMAP_DESTROY_SLEEP);
+
+	__flush(map);
+	kfree(map);
+
+	set->data = NULL;
+}
+
+static void flush(struct ip_set *set)
+{
+	struct ip_set_iptreemap *map = (struct ip_set_iptreemap *) set->data;
+
+	while (!del_timer(&map->gc))
+		msleep(IPTREEMAP_DESTROY_SLEEP);
+
+	__flush(map);
+
+	memset(map, 0, sizeof(*map));
+
+	init_gc_timer(set);
+}
+
+static void list_header(const struct ip_set *set, void *data)
+{
+	struct ip_set_iptreemap *map = (struct ip_set_iptreemap *) set->data;
+	struct ip_set_req_iptreemap_create *header = (struct ip_set_req_iptreemap_create *) data;
+
+	header->gc_interval = map->gc_interval;
+}
+
+static int list_members_size(const struct ip_set *set)
+{
+	struct ip_set_iptreemap *map = (struct ip_set_iptreemap *) set->data;
+	struct ip_set_iptreemap_b *btree;
+	struct ip_set_iptreemap_c *ctree;
+	struct ip_set_iptreemap_d *dtree;
+	unsigned int a, b, c, d, inrange = 0, count = 0;
+
+	LOOP_WALK_BEGIN_COUNT(map, a, btree, inrange, count) {
+		LOOP_WALK_BEGIN_COUNT(btree, b, ctree, inrange, count) {
+			LOOP_WALK_BEGIN_COUNT(ctree, c, dtree, inrange, count) {
+				for (d = 0; d < 256; d++) {
+					if (test_bit(d, (void *) dtree->bitmap)) {
+						inrange = 1;
+					} else if (inrange) {
+						count++;
+						inrange = 0;
+					}
+				}
+			} LOOP_WALK_END_COUNT();
+		} LOOP_WALK_END_COUNT();
+	} LOOP_WALK_END_COUNT();
+
+	if (inrange)
+		count++;
+
+	return (count * sizeof(struct ip_set_req_iptreemap));
+}
+
+static inline size_t add_member(void *data, size_t offset, ip_set_ip_t start, ip_set_ip_t end)
+{
+	struct ip_set_req_iptreemap *entry = (struct ip_set_req_iptreemap *) (data + offset);
+
+	entry->start = start;
+	entry->end = end;
+
+	return sizeof(*entry);
+}
+
+static void list_members(const struct ip_set *set, void *data)
+{
+	struct ip_set_iptreemap *map = (struct ip_set_iptreemap *) set->data;
+	struct ip_set_iptreemap_b *btree;
+	struct ip_set_iptreemap_c *ctree;
+	struct ip_set_iptreemap_d *dtree;
+	unsigned int a, b, c, d, inrange = 0;
+	size_t offset = 0;
+	ip_set_ip_t start = 0, end = 0, ip;
+
+	LOOP_WALK_BEGIN(map, a, btree) {
+		LOOP_WALK_BEGIN(btree, b, ctree) {
+			LOOP_WALK_BEGIN(ctree, c, dtree) {
+				for (d = 0; d < 256; d++) {
+					if (test_bit(d, (void *) dtree->bitmap)) {
+						ip = ((a << 24) | (b << 16) | (c << 8) | d);
+						if (!inrange) {
+							inrange = 1;
+							start = ip;
+						} else if (end < ip - 1) {
+							offset += add_member(data, offset, start, end);
+							start = ip;
+						}
+						end = ip;
+					} else if (inrange) {
+						offset += add_member(data, offset, start, end);
+						inrange = 0;
+					}
+				}
+			} LOOP_WALK_END();
+		} LOOP_WALK_END();
+	} LOOP_WALK_END();
+
+	if (inrange)
+		add_member(data, offset, start, end);
+}
+
+static struct ip_set_type ip_set_iptreemap = {
+	.typename		= SETTYPE_NAME,
+	.features		= IPSET_TYPE_IP | IPSET_DATA_SINGLE,
+	.protocol_version	= IP_SET_PROTOCOL_VERSION,
+	.create			= create,
+	.destroy		= destroy,
+	.flush			= flush,
+	.reqsize		= sizeof(struct ip_set_req_iptreemap),
+	.addip			= addip,
+	.addip_kernel		= addip_kernel,
+	.delip			= delip,
+	.delip_kernel		= delip_kernel,
+	.testip			= testip,
+	.testip_kernel		= testip_kernel,
+	.header_size		= sizeof(struct ip_set_req_iptreemap_create),
+	.list_header		= list_header,
+	.list_members_size	= list_members_size,
+	.list_members		= list_members,
+	.me			= THIS_MODULE,
+};
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Sven Wegener <sven.wegener@stealer.net>");
+MODULE_DESCRIPTION("iptreemap type of IP sets");
+
+static int __init ip_set_iptreemap_init(void)
+{
+	int ret = -ENOMEM;
+	int a;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)
+	cachep_b = kmem_cache_create("ip_set_iptreemap_b",
+				     sizeof(struct ip_set_iptreemap_b),
+				     0, 0, NULL);
+#else
+	cachep_b = kmem_cache_create("ip_set_iptreemap_b",
+				     sizeof(struct ip_set_iptreemap_b),
+				     0, 0, NULL, NULL);
+#endif
+	if (!cachep_b) {
+		ip_set_printk("Unable to create ip_set_iptreemap_b slab cache");
+		goto out;
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)
+	cachep_c = kmem_cache_create("ip_set_iptreemap_c",
+				     sizeof(struct ip_set_iptreemap_c),
+				     0, 0, NULL);
+#else
+	cachep_c = kmem_cache_create("ip_set_iptreemap_c",
+				     sizeof(struct ip_set_iptreemap_c),
+				     0, 0, NULL, NULL);
+#endif
+	if (!cachep_c) {
+		ip_set_printk("Unable to create ip_set_iptreemap_c slab cache");
+		goto outb;
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)
+	cachep_d = kmem_cache_create("ip_set_iptreemap_d",
+				     sizeof(struct ip_set_iptreemap_d),
+				     0, 0, NULL);
+#else
+	cachep_d = kmem_cache_create("ip_set_iptreemap_d",
+				     sizeof(struct ip_set_iptreemap_d),
+				     0, 0, NULL, NULL);
+#endif
+	if (!cachep_d) {
+		ip_set_printk("Unable to create ip_set_iptreemap_d slab cache");
+		goto outc;
+	}
+
+	fullbitmap_d = kmem_cache_alloc(cachep_d, GFP_KERNEL);
+	if (!fullbitmap_d)
+		goto outd;
+
+	fullbitmap_c = kmem_cache_alloc(cachep_c, GFP_KERNEL);
+	if (!fullbitmap_c)
+		goto outbitmapd;
+
+	fullbitmap_b = kmem_cache_alloc(cachep_b, GFP_KERNEL);
+	if (!fullbitmap_b)
+		goto outbitmapc;
+
+	ret = ip_set_register_set_type(&ip_set_iptreemap);
+	if (0 > ret)
+		goto outbitmapb;
+
+	/* Now init our global bitmaps */
+	memset(fullbitmap_d->bitmap, 0xff, sizeof(fullbitmap_d->bitmap));
+
+	for (a = 0; a < 256; a++)
+		fullbitmap_c->tree[a] = fullbitmap_d;
+
+	for (a = 0; a < 256; a++)
+		fullbitmap_b->tree[a] = fullbitmap_c;
+	memset(fullbitmap_b->dirty, 0, sizeof(fullbitmap_b->dirty));
+
+	return 0;
+
+outbitmapb:
+	kmem_cache_free(cachep_b, fullbitmap_b);
+outbitmapc:
+	kmem_cache_free(cachep_c, fullbitmap_c);
+outbitmapd:
+	kmem_cache_free(cachep_d, fullbitmap_d);
+outd:
+	kmem_cache_destroy(cachep_d);
+outc:
+	kmem_cache_destroy(cachep_c);
+outb:
+	kmem_cache_destroy(cachep_b);
+out:
+
+	return ret;
+}
+
+static void __exit ip_set_iptreemap_fini(void)
+{
+	ip_set_unregister_set_type(&ip_set_iptreemap);
+	kmem_cache_free(cachep_d, fullbitmap_d);
+	kmem_cache_free(cachep_c, fullbitmap_c);
+	kmem_cache_free(cachep_b, fullbitmap_b);
+	kmem_cache_destroy(cachep_d);
+	kmem_cache_destroy(cachep_c);
+	kmem_cache_destroy(cachep_b);
+}
+
+module_init(ip_set_iptreemap_init);
+module_exit(ip_set_iptreemap_fini);
diff -Nru linux-2.6.30.5/net/ipv4/netfilter/ip_set_macipmap.c linux-2.6.30.5-wrt/net/ipv4/netfilter/ip_set_macipmap.c
--- linux-2.6.30.5/net/ipv4/netfilter/ip_set_macipmap.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/net/ipv4/netfilter/ip_set_macipmap.c	2009-09-06 18:43:48.378666801 +0200
@@ -0,0 +1,375 @@
+/* Copyright (C) 2000-2002 Joakim Axelsson <gozem@linux.nu>
+ *                         Patrick Schaaf <bof@bof.de>
+ *                         Martin Josefsson <gandalf@wlug.westbo.se>
+ * Copyright (C) 2003-2004 Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/* Kernel module implementing an IP set type: the macipmap type */
+
+#include <linux/module.h>
+#include <linux/ip.h>
+#include <linux/skbuff.h>
+#include <linux/version.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ip_set.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+#include <asm/bitops.h>
+#include <linux/spinlock.h>
+#include <linux/if_ether.h>
+#include <linux/vmalloc.h>
+
+#include <linux/netfilter_ipv4/ip_set_malloc.h>
+#include <linux/netfilter_ipv4/ip_set_macipmap.h>
+
+static int
+testip(struct ip_set *set, const void *data, size_t size, ip_set_ip_t *hash_ip)
+{
+	struct ip_set_macipmap *map = (struct ip_set_macipmap *) set->data;
+	struct ip_set_macip *table = (struct ip_set_macip *) map->members;
+	struct ip_set_req_macipmap *req = (struct ip_set_req_macipmap *) data;
+
+	if (size != sizeof(struct ip_set_req_macipmap)) {
+		ip_set_printk("data length wrong (want %zu, have %zu)",
+			      sizeof(struct ip_set_req_macipmap),
+			      size);
+		return -EINVAL;
+	}
+
+	if (req->ip < map->first_ip || req->ip > map->last_ip)
+		return -ERANGE;
+
+	*hash_ip = req->ip;
+	DP("set: %s, ip:%u.%u.%u.%u, %u.%u.%u.%u",
+	   set->name, HIPQUAD(req->ip), HIPQUAD(*hash_ip));
+	if (test_bit(IPSET_MACIP_ISSET,
+		     (void *) &table[req->ip - map->first_ip].flags)) {
+		return (memcmp(req->ethernet,
+			       &table[req->ip - map->first_ip].ethernet,
+			       ETH_ALEN) == 0);
+	} else {
+		return (map->flags & IPSET_MACIP_MATCHUNSET ? 1 : 0);
+	}
+}
+
+static int
+testip_kernel(struct ip_set *set,
+	      const struct sk_buff *skb,
+	      ip_set_ip_t *hash_ip,
+	      const u_int32_t *flags,
+	      unsigned char index)
+{
+	struct ip_set_macipmap *map =
+	    (struct ip_set_macipmap *) set->data;
+	struct ip_set_macip *table =
+	    (struct ip_set_macip *) map->members;
+	ip_set_ip_t ip;
+
+	ip = ntohl(flags[index] & IPSET_SRC
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+			? ip_hdr(skb)->saddr
+			: ip_hdr(skb)->daddr);
+#else
+			? skb->nh.iph->saddr
+			: skb->nh.iph->daddr);
+#endif
+
+	if (ip < map->first_ip || ip > map->last_ip)
+		return 0;
+
+	*hash_ip = ip;
+	DP("set: %s, ip:%u.%u.%u.%u, %u.%u.%u.%u",
+	   set->name, HIPQUAD(ip), HIPQUAD(*hash_ip));
+	if (test_bit(IPSET_MACIP_ISSET,
+	    (void *) &table[ip - map->first_ip].flags)) {
+		/* Is mac pointer valid?
+		 * If so, compare... */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+		return (skb_mac_header(skb) >= skb->head
+			&& (skb_mac_header(skb) + ETH_HLEN) <= skb->data
+#else
+		return (skb->mac.raw >= skb->head
+			&& (skb->mac.raw + ETH_HLEN) <= skb->data
+#endif
+			&& (memcmp(eth_hdr(skb)->h_source,
+				   &table[ip - map->first_ip].ethernet,
+				   ETH_ALEN) == 0));
+	} else {
+		return (map->flags & IPSET_MACIP_MATCHUNSET ? 1 : 0);
+	}
+}
+
+/* returns 0 on success */
+static inline int
+__addip(struct ip_set *set,
+	ip_set_ip_t ip, unsigned char *ethernet, ip_set_ip_t *hash_ip)
+{
+	struct ip_set_macipmap *map =
+	    (struct ip_set_macipmap *) set->data;
+	struct ip_set_macip *table =
+	    (struct ip_set_macip *) map->members;
+
+	if (ip < map->first_ip || ip > map->last_ip)
+		return -ERANGE;
+	if (test_and_set_bit(IPSET_MACIP_ISSET,
+			     (void *) &table[ip - map->first_ip].flags))
+		return -EEXIST;
+
+	*hash_ip = ip;
+	DP("%u.%u.%u.%u, %u.%u.%u.%u", HIPQUAD(ip), HIPQUAD(*hash_ip));
+	memcpy(&table[ip - map->first_ip].ethernet, ethernet, ETH_ALEN);
+	return 0;
+}
+
+static int
+addip(struct ip_set *set, const void *data, size_t size,
+      ip_set_ip_t *hash_ip)
+{
+	struct ip_set_req_macipmap *req =
+	    (struct ip_set_req_macipmap *) data;
+
+	if (size != sizeof(struct ip_set_req_macipmap)) {
+		ip_set_printk("data length wrong (want %zu, have %zu)",
+			      sizeof(struct ip_set_req_macipmap),
+			      size);
+		return -EINVAL;
+	}
+	return __addip(set, req->ip, req->ethernet, hash_ip);
+}
+
+static int
+addip_kernel(struct ip_set *set,
+	     const struct sk_buff *skb,
+	     ip_set_ip_t *hash_ip,
+	     const u_int32_t *flags,
+	     unsigned char index)
+{
+	ip_set_ip_t ip;
+
+	ip = ntohl(flags[index] & IPSET_SRC
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+			? ip_hdr(skb)->saddr
+			: ip_hdr(skb)->daddr);
+#else
+			? skb->nh.iph->saddr
+			: skb->nh.iph->daddr);
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+	if (!(skb_mac_header(skb) >= skb->head
+	      && (skb_mac_header(skb) + ETH_HLEN) <= skb->data))
+#else
+	if (!(skb->mac.raw >= skb->head
+	      && (skb->mac.raw + ETH_HLEN) <= skb->data))
+#endif
+		return -EINVAL;
+
+	return __addip(set, ip, eth_hdr(skb)->h_source, hash_ip);
+}
+
+static inline int
+__delip(struct ip_set *set, ip_set_ip_t ip, ip_set_ip_t *hash_ip)
+{
+	struct ip_set_macipmap *map =
+	    (struct ip_set_macipmap *) set->data;
+	struct ip_set_macip *table =
+	    (struct ip_set_macip *) map->members;
+
+	if (ip < map->first_ip || ip > map->last_ip)
+		return -ERANGE;
+	if (!test_and_clear_bit(IPSET_MACIP_ISSET,
+				(void *)&table[ip - map->first_ip].flags))
+		return -EEXIST;
+
+	*hash_ip = ip;
+	DP("%u.%u.%u.%u, %u.%u.%u.%u", HIPQUAD(ip), HIPQUAD(*hash_ip));
+	return 0;
+}
+
+static int
+delip(struct ip_set *set, const void *data, size_t size,
+     ip_set_ip_t *hash_ip)
+{
+	struct ip_set_req_macipmap *req =
+	    (struct ip_set_req_macipmap *) data;
+
+	if (size != sizeof(struct ip_set_req_macipmap)) {
+		ip_set_printk("data length wrong (want %zu, have %zu)",
+			      sizeof(struct ip_set_req_macipmap),
+			      size);
+		return -EINVAL;
+	}
+	return __delip(set, req->ip, hash_ip);
+}
+
+static int
+delip_kernel(struct ip_set *set,
+	     const struct sk_buff *skb,
+	     ip_set_ip_t *hash_ip,
+	     const u_int32_t *flags,
+	     unsigned char index)
+{
+	return __delip(set,
+		       ntohl(flags[index] & IPSET_SRC
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+				? ip_hdr(skb)->saddr
+				: ip_hdr(skb)->daddr),
+#else
+		       		? skb->nh.iph->saddr
+				: skb->nh.iph->daddr),
+#endif
+		       hash_ip);
+}
+
+static inline size_t members_size(ip_set_id_t from, ip_set_id_t to)
+{
+	return (size_t)((to - from + 1) * sizeof(struct ip_set_macip));
+}
+
+static int create(struct ip_set *set, const void *data, size_t size)
+{
+	int newbytes;
+	struct ip_set_req_macipmap_create *req =
+	    (struct ip_set_req_macipmap_create *) data;
+	struct ip_set_macipmap *map;
+
+	if (size != sizeof(struct ip_set_req_macipmap_create)) {
+		ip_set_printk("data length wrong (want %zu, have %zu)",
+			      sizeof(struct ip_set_req_macipmap_create),
+			      size);
+		return -EINVAL;
+	}
+
+	DP("from %u.%u.%u.%u to %u.%u.%u.%u",
+	   HIPQUAD(req->from), HIPQUAD(req->to));
+
+	if (req->from > req->to) {
+		DP("bad ip range");
+		return -ENOEXEC;
+	}
+
+	if (req->to - req->from > MAX_RANGE) {
+		ip_set_printk("range too big (max %d addresses)",
+			       MAX_RANGE+1);
+		return -ENOEXEC;
+	}
+
+	map = kmalloc(sizeof(struct ip_set_macipmap), GFP_KERNEL);
+	if (!map) {
+		DP("out of memory for %d bytes",
+		   sizeof(struct ip_set_macipmap));
+		return -ENOMEM;
+	}
+	map->flags = req->flags;
+	map->first_ip = req->from;
+	map->last_ip = req->to;
+	newbytes = members_size(map->first_ip, map->last_ip);
+	map->members = ip_set_malloc(newbytes);
+	DP("members: %u %p", newbytes, map->members);
+	if (!map->members) {
+		DP("out of memory for %d bytes", newbytes);
+		kfree(map);
+		return -ENOMEM;
+	}
+	memset(map->members, 0, newbytes);
+
+	set->data = map;
+	return 0;
+}
+
+static void destroy(struct ip_set *set)
+{
+	struct ip_set_macipmap *map =
+	    (struct ip_set_macipmap *) set->data;
+
+	ip_set_free(map->members, members_size(map->first_ip, map->last_ip));
+	kfree(map);
+
+	set->data = NULL;
+}
+
+static void flush(struct ip_set *set)
+{
+	struct ip_set_macipmap *map =
+	    (struct ip_set_macipmap *) set->data;
+	memset(map->members, 0, members_size(map->first_ip, map->last_ip));
+}
+
+static void list_header(const struct ip_set *set, void *data)
+{
+	struct ip_set_macipmap *map =
+	    (struct ip_set_macipmap *) set->data;
+	struct ip_set_req_macipmap_create *header =
+	    (struct ip_set_req_macipmap_create *) data;
+
+	DP("list_header %x %x %u", map->first_ip, map->last_ip,
+	   map->flags);
+
+	header->from = map->first_ip;
+	header->to = map->last_ip;
+	header->flags = map->flags;
+}
+
+static int list_members_size(const struct ip_set *set)
+{
+	struct ip_set_macipmap *map =
+	    (struct ip_set_macipmap *) set->data;
+
+	DP("%u", members_size(map->first_ip, map->last_ip));
+	return members_size(map->first_ip, map->last_ip);
+}
+
+static void list_members(const struct ip_set *set, void *data)
+{
+	struct ip_set_macipmap *map =
+	    (struct ip_set_macipmap *) set->data;
+
+	int bytes = members_size(map->first_ip, map->last_ip);
+
+	DP("members: %u %p", bytes, map->members);
+	memcpy(data, map->members, bytes);
+}
+
+static struct ip_set_type ip_set_macipmap = {
+	.typename		= SETTYPE_NAME,
+	.features		= IPSET_TYPE_IP | IPSET_DATA_SINGLE,
+	.protocol_version	= IP_SET_PROTOCOL_VERSION,
+	.create			= &create,
+	.destroy		= &destroy,
+	.flush			= &flush,
+	.reqsize		= sizeof(struct ip_set_req_macipmap),
+	.addip			= &addip,
+	.addip_kernel		= &addip_kernel,
+	.delip			= &delip,
+	.delip_kernel		= &delip_kernel,
+	.testip			= &testip,
+	.testip_kernel		= &testip_kernel,
+	.header_size		= sizeof(struct ip_set_req_macipmap_create),
+	.list_header		= &list_header,
+	.list_members_size	= &list_members_size,
+	.list_members		= &list_members,
+	.me			= THIS_MODULE,
+};
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>");
+MODULE_DESCRIPTION("macipmap type of IP sets");
+
+static int __init ip_set_macipmap_init(void)
+{
+	init_max_malloc_size();
+	return ip_set_register_set_type(&ip_set_macipmap);
+}
+
+static void __exit ip_set_macipmap_fini(void)
+{
+	/* FIXME: possible race with ip_set_create() */
+	ip_set_unregister_set_type(&ip_set_macipmap);
+}
+
+module_init(ip_set_macipmap_init);
+module_exit(ip_set_macipmap_fini);
diff -Nru linux-2.6.30.5/net/ipv4/netfilter/ip_set_nethash.c linux-2.6.30.5-wrt/net/ipv4/netfilter/ip_set_nethash.c
--- linux-2.6.30.5/net/ipv4/netfilter/ip_set_nethash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/net/ipv4/netfilter/ip_set_nethash.c	2009-09-06 18:43:48.378666801 +0200
@@ -0,0 +1,497 @@
+/* Copyright (C) 2003-2004 Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/* Kernel module implementing a cidr nethash set */
+
+#include <linux/module.h>
+#include <linux/ip.h>
+#include <linux/skbuff.h>
+#include <linux/version.h>
+#include <linux/jhash.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ip_set.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+#include <asm/bitops.h>
+#include <linux/spinlock.h>
+#include <linux/vmalloc.h>
+#include <linux/random.h>
+
+#include <net/ip.h>
+
+#include <linux/netfilter_ipv4/ip_set_malloc.h>
+#include <linux/netfilter_ipv4/ip_set_nethash.h>
+
+static int limit = MAX_RANGE;
+
+static inline __u32
+jhash_ip(const struct ip_set_nethash *map, uint16_t i, ip_set_ip_t ip)
+{
+	return jhash_1word(ip, *(((uint32_t *) map->initval) + i));
+}
+
+static inline __u32
+hash_id_cidr(struct ip_set_nethash *map,
+	     ip_set_ip_t ip,
+	     unsigned char cidr,
+	     ip_set_ip_t *hash_ip)
+{
+	__u32 id;
+	u_int16_t i;
+	ip_set_ip_t *elem;
+
+	*hash_ip = pack(ip, cidr);
+
+	for (i = 0; i < map->probes; i++) {
+		id = jhash_ip(map, i, *hash_ip) % map->hashsize;
+	   	DP("hash key: %u", id);
+		elem = HARRAY_ELEM(map->members, ip_set_ip_t *, id);
+	   	if (*elem == *hash_ip)
+			return id;
+	}
+	return UINT_MAX;
+}
+
+static inline __u32
+hash_id(struct ip_set *set, ip_set_ip_t ip, ip_set_ip_t *hash_ip)
+{
+	struct ip_set_nethash *map = (struct ip_set_nethash *) set->data;
+	__u32 id = UINT_MAX;
+	int i;
+
+	for (i = 0; i < 30 && map->cidr[i]; i++) {
+		id = hash_id_cidr(map, ip, map->cidr[i], hash_ip);
+		if (id != UINT_MAX)
+			break;
+	}
+	return id;
+}
+
+static inline int
+__testip_cidr(struct ip_set *set, ip_set_ip_t ip, unsigned char cidr,
+	      ip_set_ip_t *hash_ip)
+{
+	struct ip_set_nethash *map = (struct ip_set_nethash *) set->data;
+
+	return (ip && hash_id_cidr(map, ip, cidr, hash_ip) != UINT_MAX);
+}
+
+static inline int
+__testip(struct ip_set *set, ip_set_ip_t ip, ip_set_ip_t *hash_ip)
+{
+	return (ip && hash_id(set, ip, hash_ip) != UINT_MAX);
+}
+
+static int
+testip(struct ip_set *set, const void *data, size_t size,
+       ip_set_ip_t *hash_ip)
+{
+	struct ip_set_req_nethash *req =
+	    (struct ip_set_req_nethash *) data;
+
+	if (size != sizeof(struct ip_set_req_nethash)) {
+		ip_set_printk("data length wrong (want %zu, have %zu)",
+			      sizeof(struct ip_set_req_nethash),
+			      size);
+		return -EINVAL;
+	}
+	return (req->cidr == 32 ? __testip(set, req->ip, hash_ip)
+		: __testip_cidr(set, req->ip, req->cidr, hash_ip));
+}
+
+static int
+testip_kernel(struct ip_set *set,
+	      const struct sk_buff *skb,
+	      ip_set_ip_t *hash_ip,
+	      const u_int32_t *flags,
+	      unsigned char index)
+{
+	return __testip(set,
+			ntohl(flags[index] & IPSET_SRC
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+				? ip_hdr(skb)->saddr
+				: ip_hdr(skb)->daddr),
+#else
+				? skb->nh.iph->saddr
+				: skb->nh.iph->daddr),
+#endif
+			hash_ip);
+}
+
+static inline int
+__addip_base(struct ip_set_nethash *map, ip_set_ip_t ip)
+{
+	__u32 probe;
+	u_int16_t i;
+	ip_set_ip_t *elem;
+
+	for (i = 0; i < map->probes; i++) {
+		probe = jhash_ip(map, i, ip) % map->hashsize;
+		elem = HARRAY_ELEM(map->members, ip_set_ip_t *, probe);
+		if (*elem == ip)
+			return -EEXIST;
+		if (!*elem) {
+			*elem = ip;
+			map->elements++;
+			return 0;
+		}
+	}
+	/* Trigger rehashing */
+	return -EAGAIN;
+}
+
+static inline int
+__addip(struct ip_set_nethash *map, ip_set_ip_t ip, unsigned char cidr,
+	ip_set_ip_t *hash_ip)
+{
+	if (!ip || map->elements >= limit)
+		return -ERANGE;
+
+	*hash_ip = pack(ip, cidr);
+	DP("%u.%u.%u.%u/%u, %u.%u.%u.%u", HIPQUAD(ip), cidr, HIPQUAD(*hash_ip));
+
+	return __addip_base(map, *hash_ip);
+}
+
+static void
+update_cidr_sizes(struct ip_set_nethash *map, unsigned char cidr)
+{
+	unsigned char next;
+	int i;
+
+	for (i = 0; i < 30 && map->cidr[i]; i++) {
+		if (map->cidr[i] == cidr) {
+			return;
+		} else if (map->cidr[i] < cidr) {
+			next = map->cidr[i];
+			map->cidr[i] = cidr;
+			cidr = next;
+		}
+	}
+	if (i < 30)
+		map->cidr[i] = cidr;
+}
+
+static int
+addip(struct ip_set *set, const void *data, size_t size,
+        ip_set_ip_t *hash_ip)
+{
+	struct ip_set_req_nethash *req =
+	    (struct ip_set_req_nethash *) data;
+	int ret;
+
+	if (size != sizeof(struct ip_set_req_nethash)) {
+		ip_set_printk("data length wrong (want %zu, have %zu)",
+			      sizeof(struct ip_set_req_nethash),
+			      size);
+		return -EINVAL;
+	}
+	ret = __addip((struct ip_set_nethash *) set->data,
+		      req->ip, req->cidr, hash_ip);
+
+	if (ret == 0)
+		update_cidr_sizes((struct ip_set_nethash *) set->data,
+				  req->cidr);
+
+	return ret;
+}
+
+static int
+addip_kernel(struct ip_set *set,
+	     const struct sk_buff *skb,
+	     ip_set_ip_t *hash_ip,
+	     const u_int32_t *flags,
+	     unsigned char index)
+{
+	struct ip_set_nethash *map = (struct ip_set_nethash *) set->data;
+	int ret = -ERANGE;
+	ip_set_ip_t ip = ntohl(flags[index] & IPSET_SRC
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+					? ip_hdr(skb)->saddr
+					: ip_hdr(skb)->daddr);
+#else
+					? skb->nh.iph->saddr
+					: skb->nh.iph->daddr);
+#endif
+
+	if (map->cidr[0])
+		ret = __addip(map, ip, map->cidr[0], hash_ip);
+
+	return ret;
+}
+
+static int retry(struct ip_set *set)
+{
+	struct ip_set_nethash *map = (struct ip_set_nethash *) set->data;
+	ip_set_ip_t *elem;
+	void *members;
+	u_int32_t i, hashsize = map->hashsize;
+	int res;
+	struct ip_set_nethash *tmp;
+
+	if (map->resize == 0)
+		return -ERANGE;
+
+    again:
+    	res = 0;
+
+	/* Calculate new parameters */
+	hashsize += (hashsize * map->resize)/100;
+	if (hashsize == map->hashsize)
+		hashsize++;
+
+	ip_set_printk("rehashing of set %s triggered: "
+		      "hashsize grows from %u to %u",
+		      set->name, map->hashsize, hashsize);
+
+	tmp = kmalloc(sizeof(struct ip_set_nethash)
+		      + map->probes * sizeof(uint32_t), GFP_ATOMIC);
+	if (!tmp) {
+		DP("out of memory for %d bytes",
+		   sizeof(struct ip_set_nethash)
+		   + map->probes * sizeof(uint32_t));
+		return -ENOMEM;
+	}
+	tmp->members = harray_malloc(hashsize, sizeof(ip_set_ip_t), GFP_ATOMIC);
+	if (!tmp->members) {
+		DP("out of memory for %d bytes", hashsize * sizeof(ip_set_ip_t));
+		kfree(tmp);
+		return -ENOMEM;
+	}
+	tmp->hashsize = hashsize;
+	tmp->elements = 0;
+	tmp->probes = map->probes;
+	tmp->resize = map->resize;
+	memcpy(tmp->initval, map->initval, map->probes * sizeof(uint32_t));
+	memcpy(tmp->cidr, map->cidr, 30 * sizeof(unsigned char));
+
+	write_lock_bh(&set->lock);
+	map = (struct ip_set_nethash *) set->data; /* Play safe */
+	for (i = 0; i < map->hashsize && res == 0; i++) {
+		elem = HARRAY_ELEM(map->members, ip_set_ip_t *, i);
+		if (*elem)
+			res = __addip_base(tmp, *elem);
+	}
+	if (res) {
+		/* Failure, try again */
+		write_unlock_bh(&set->lock);
+		harray_free(tmp->members);
+		kfree(tmp);
+		goto again;
+	}
+
+	/* Success at resizing! */
+	members = map->members;
+
+	map->hashsize = tmp->hashsize;
+	map->members = tmp->members;
+	write_unlock_bh(&set->lock);
+
+	harray_free(members);
+	kfree(tmp);
+
+	return 0;
+}
+
+static inline int
+__delip(struct ip_set_nethash *map, ip_set_ip_t ip, unsigned char cidr,
+	ip_set_ip_t *hash_ip)
+{
+	ip_set_ip_t id, *elem;
+
+	if (!ip)
+		return -ERANGE;
+
+	id = hash_id_cidr(map, ip, cidr, hash_ip);
+	if (id == UINT_MAX)
+		return -EEXIST;
+
+	elem = HARRAY_ELEM(map->members, ip_set_ip_t *, id);
+	*elem = 0;
+	map->elements--;
+	return 0;
+}
+
+static int
+delip(struct ip_set *set, const void *data, size_t size,
+        ip_set_ip_t *hash_ip)
+{
+	struct ip_set_req_nethash *req =
+	    (struct ip_set_req_nethash *) data;
+
+	if (size != sizeof(struct ip_set_req_nethash)) {
+		ip_set_printk("data length wrong (want %zu, have %zu)",
+			      sizeof(struct ip_set_req_nethash),
+			      size);
+		return -EINVAL;
+	}
+	/* TODO: no garbage collection in map->cidr */
+	return __delip((struct ip_set_nethash *) set->data,
+		       req->ip, req->cidr, hash_ip);
+}
+
+static int
+delip_kernel(struct ip_set *set,
+	     const struct sk_buff *skb,
+	     ip_set_ip_t *hash_ip,
+	     const u_int32_t *flags,
+	     unsigned char index)
+{
+	struct ip_set_nethash *map = (struct ip_set_nethash *) set->data;
+	int ret = -ERANGE;
+	ip_set_ip_t ip = ntohl(flags[index] & IPSET_SRC
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+					? ip_hdr(skb)->saddr
+					: ip_hdr(skb)->daddr);
+#else
+					? skb->nh.iph->saddr
+					: skb->nh.iph->daddr);
+#endif
+
+	if (map->cidr[0])
+		ret = __delip(map, ip, map->cidr[0], hash_ip);
+
+	return ret;
+}
+
+static int create(struct ip_set *set, const void *data, size_t size)
+{
+	struct ip_set_req_nethash_create *req =
+	    (struct ip_set_req_nethash_create *) data;
+	struct ip_set_nethash *map;
+	uint16_t i;
+
+	if (size != sizeof(struct ip_set_req_nethash_create)) {
+		ip_set_printk("data length wrong (want %zu, have %zu)",
+			       sizeof(struct ip_set_req_nethash_create),
+			       size);
+		return -EINVAL;
+	}
+
+	if (req->hashsize < 1) {
+		ip_set_printk("hashsize too small");
+		return -ENOEXEC;
+	}
+	if (req->probes < 1) {
+		ip_set_printk("probes too small");
+		return -ENOEXEC;
+	}
+
+	map = kmalloc(sizeof(struct ip_set_nethash)
+		      + req->probes * sizeof(uint32_t), GFP_KERNEL);
+	if (!map) {
+		DP("out of memory for %d bytes",
+		   sizeof(struct ip_set_nethash)
+		   + req->probes * sizeof(uint32_t));
+		return -ENOMEM;
+	}
+	for (i = 0; i < req->probes; i++)
+		get_random_bytes(((uint32_t *) map->initval)+i, 4);
+	map->elements = 0;
+	map->hashsize = req->hashsize;
+	map->probes = req->probes;
+	map->resize = req->resize;
+	memset(map->cidr, 0, 30 * sizeof(unsigned char));
+	map->members = harray_malloc(map->hashsize, sizeof(ip_set_ip_t), GFP_KERNEL);
+	if (!map->members) {
+		DP("out of memory for %d bytes", map->hashsize * sizeof(ip_set_ip_t));
+		kfree(map);
+		return -ENOMEM;
+	}
+
+	set->data = map;
+	return 0;
+}
+
+static void destroy(struct ip_set *set)
+{
+	struct ip_set_nethash *map = (struct ip_set_nethash *) set->data;
+
+	harray_free(map->members);
+	kfree(map);
+
+	set->data = NULL;
+}
+
+static void flush(struct ip_set *set)
+{
+	struct ip_set_nethash *map = (struct ip_set_nethash *) set->data;
+	harray_flush(map->members, map->hashsize, sizeof(ip_set_ip_t));
+	memset(map->cidr, 0, 30 * sizeof(unsigned char));
+	map->elements = 0;
+}
+
+static void list_header(const struct ip_set *set, void *data)
+{
+	struct ip_set_nethash *map = (struct ip_set_nethash *) set->data;
+	struct ip_set_req_nethash_create *header =
+	    (struct ip_set_req_nethash_create *) data;
+
+	header->hashsize = map->hashsize;
+	header->probes = map->probes;
+	header->resize = map->resize;
+}
+
+static int list_members_size(const struct ip_set *set)
+{
+	struct ip_set_nethash *map = (struct ip_set_nethash *) set->data;
+
+	return (map->hashsize * sizeof(ip_set_ip_t));
+}
+
+static void list_members(const struct ip_set *set, void *data)
+{
+	struct ip_set_nethash *map = (struct ip_set_nethash *) set->data;
+	ip_set_ip_t i, *elem;
+
+	for (i = 0; i < map->hashsize; i++) {
+		elem = HARRAY_ELEM(map->members, ip_set_ip_t *, i);
+		((ip_set_ip_t *)data)[i] = *elem;
+	}
+}
+
+static struct ip_set_type ip_set_nethash = {
+	.typename		= SETTYPE_NAME,
+	.features		= IPSET_TYPE_IP | IPSET_DATA_SINGLE,
+	.protocol_version	= IP_SET_PROTOCOL_VERSION,
+	.create			= &create,
+	.destroy		= &destroy,
+	.flush			= &flush,
+	.reqsize		= sizeof(struct ip_set_req_nethash),
+	.addip			= &addip,
+	.addip_kernel		= &addip_kernel,
+	.retry			= &retry,
+	.delip			= &delip,
+	.delip_kernel		= &delip_kernel,
+	.testip			= &testip,
+	.testip_kernel		= &testip_kernel,
+	.header_size		= sizeof(struct ip_set_req_nethash_create),
+	.list_header		= &list_header,
+	.list_members_size	= &list_members_size,
+	.list_members		= &list_members,
+	.me			= THIS_MODULE,
+};
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>");
+MODULE_DESCRIPTION("nethash type of IP sets");
+module_param(limit, int, 0600);
+MODULE_PARM_DESC(limit, "maximal number of elements stored in the sets");
+
+static int __init ip_set_nethash_init(void)
+{
+	return ip_set_register_set_type(&ip_set_nethash);
+}
+
+static void __exit ip_set_nethash_fini(void)
+{
+	/* FIXME: possible race with ip_set_create() */
+	ip_set_unregister_set_type(&ip_set_nethash);
+}
+
+module_init(ip_set_nethash_init);
+module_exit(ip_set_nethash_fini);
diff -Nru linux-2.6.30.5/net/ipv4/netfilter/ip_set_portmap.c linux-2.6.30.5-wrt/net/ipv4/netfilter/ip_set_portmap.c
--- linux-2.6.30.5/net/ipv4/netfilter/ip_set_portmap.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/net/ipv4/netfilter/ip_set_portmap.c	2009-09-06 18:43:48.378666801 +0200
@@ -0,0 +1,346 @@
+/* Copyright (C) 2003-2004 Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/* Kernel module implementing a port set type as a bitmap */
+
+#include <linux/module.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+#include <linux/skbuff.h>
+#include <linux/version.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ip_set.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+#include <asm/bitops.h>
+#include <linux/spinlock.h>
+
+#include <net/ip.h>
+
+#include <linux/netfilter_ipv4/ip_set_portmap.h>
+
+/* We must handle non-linear skbs */
+static inline ip_set_ip_t
+get_port(const struct sk_buff *skb, u_int32_t flags)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+	struct iphdr *iph = ip_hdr(skb);
+#else
+	struct iphdr *iph = skb->nh.iph;
+#endif
+	u_int16_t offset = ntohs(iph->frag_off) & IP_OFFSET;
+	switch (iph->protocol) {
+	case IPPROTO_TCP: {
+		struct tcphdr tcph;
+
+		/* See comments at tcp_match in ip_tables.c */
+		if (offset)
+			return INVALID_PORT;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+		if (skb_copy_bits(skb, ip_hdr(skb)->ihl*4, &tcph, sizeof(tcph)) < 0)
+#else
+		if (skb_copy_bits(skb, skb->nh.iph->ihl*4, &tcph, sizeof(tcph)) < 0)
+#endif
+			/* No choice either */
+			return INVALID_PORT;
+
+	     	return ntohs(flags & IPSET_SRC ?
+			     tcph.source : tcph.dest);
+	    }
+	case IPPROTO_UDP: {
+		struct udphdr udph;
+
+		if (offset)
+			return INVALID_PORT;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+		if (skb_copy_bits(skb, ip_hdr(skb)->ihl*4, &udph, sizeof(udph)) < 0)
+#else
+		if (skb_copy_bits(skb, skb->nh.iph->ihl*4, &udph, sizeof(udph)) < 0)
+#endif
+			/* No choice either */
+			return INVALID_PORT;
+
+	     	return ntohs(flags & IPSET_SRC ?
+			     udph.source : udph.dest);
+	    }
+	default:
+		return INVALID_PORT;
+	}
+}
+
+static inline int
+__testport(struct ip_set *set, ip_set_ip_t port, ip_set_ip_t *hash_port)
+{
+	struct ip_set_portmap *map = (struct ip_set_portmap *) set->data;
+
+	if (port < map->first_port || port > map->last_port)
+		return -ERANGE;
+
+	*hash_port = port;
+	DP("set: %s, port:%u, %u", set->name, port, *hash_port);
+	return !!test_bit(port - map->first_port, map->members);
+}
+
+static int
+testport(struct ip_set *set, const void *data, size_t size,
+         ip_set_ip_t *hash_port)
+{
+	struct ip_set_req_portmap *req =
+	    (struct ip_set_req_portmap *) data;
+
+	if (size != sizeof(struct ip_set_req_portmap)) {
+		ip_set_printk("data length wrong (want %zu, have %zu)",
+			      sizeof(struct ip_set_req_portmap),
+			      size);
+		return -EINVAL;
+	}
+	return __testport(set, req->port, hash_port);
+}
+
+static int
+testport_kernel(struct ip_set *set,
+	        const struct sk_buff *skb,
+	        ip_set_ip_t *hash_port,
+	        const u_int32_t *flags,
+	        unsigned char index)
+{
+	int res;
+	ip_set_ip_t port = get_port(skb, flags[index]);
+
+	DP("flag %s port %u", flags[index] & IPSET_SRC ? "SRC" : "DST", port);
+	if (port == INVALID_PORT)
+		return 0;
+
+	res =  __testport(set, port, hash_port);
+
+	return (res < 0 ? 0 : res);
+}
+
+static inline int
+__addport(struct ip_set *set, ip_set_ip_t port, ip_set_ip_t *hash_port)
+{
+	struct ip_set_portmap *map = (struct ip_set_portmap *) set->data;
+
+	if (port < map->first_port || port > map->last_port)
+		return -ERANGE;
+	if (test_and_set_bit(port - map->first_port, map->members))
+		return -EEXIST;
+
+	*hash_port = port;
+	DP("port %u", port);
+	return 0;
+}
+
+static int
+addport(struct ip_set *set, const void *data, size_t size,
+        ip_set_ip_t *hash_port)
+{
+	struct ip_set_req_portmap *req =
+	    (struct ip_set_req_portmap *) data;
+
+	if (size != sizeof(struct ip_set_req_portmap)) {
+		ip_set_printk("data length wrong (want %zu, have %zu)",
+			      sizeof(struct ip_set_req_portmap),
+			      size);
+		return -EINVAL;
+	}
+	return __addport(set, req->port, hash_port);
+}
+
+static int
+addport_kernel(struct ip_set *set,
+	       const struct sk_buff *skb,
+	       ip_set_ip_t *hash_port,
+	       const u_int32_t *flags,
+	       unsigned char index)
+{
+	ip_set_ip_t port = get_port(skb, flags[index]);
+
+	if (port == INVALID_PORT)
+		return -EINVAL;
+
+	return __addport(set, port, hash_port);
+}
+
+static inline int
+__delport(struct ip_set *set, ip_set_ip_t port, ip_set_ip_t *hash_port)
+{
+	struct ip_set_portmap *map = (struct ip_set_portmap *) set->data;
+
+	if (port < map->first_port || port > map->last_port)
+		return -ERANGE;
+	if (!test_and_clear_bit(port - map->first_port, map->members))
+		return -EEXIST;
+
+	*hash_port = port;
+	DP("port %u", port);
+	return 0;
+}
+
+static int
+delport(struct ip_set *set, const void *data, size_t size,
+        ip_set_ip_t *hash_port)
+{
+	struct ip_set_req_portmap *req =
+	    (struct ip_set_req_portmap *) data;
+
+	if (size != sizeof(struct ip_set_req_portmap)) {
+		ip_set_printk("data length wrong (want %zu, have %zu)",
+			      sizeof(struct ip_set_req_portmap),
+			      size);
+		return -EINVAL;
+	}
+	return __delport(set, req->port, hash_port);
+}
+
+static int
+delport_kernel(struct ip_set *set,
+	       const struct sk_buff *skb,
+	       ip_set_ip_t *hash_port,
+	       const u_int32_t *flags,
+	       unsigned char index)
+{
+	ip_set_ip_t port = get_port(skb, flags[index]);
+
+	if (port == INVALID_PORT)
+		return -EINVAL;
+
+	return __delport(set, port, hash_port);
+}
+
+static int create(struct ip_set *set, const void *data, size_t size)
+{
+	int newbytes;
+	struct ip_set_req_portmap_create *req =
+	    (struct ip_set_req_portmap_create *) data;
+	struct ip_set_portmap *map;
+
+	if (size != sizeof(struct ip_set_req_portmap_create)) {
+		ip_set_printk("data length wrong (want %zu, have %zu)",
+			       sizeof(struct ip_set_req_portmap_create),
+			       size);
+		return -EINVAL;
+	}
+
+	DP("from %u to %u", req->from, req->to);
+
+	if (req->from > req->to) {
+		DP("bad port range");
+		return -ENOEXEC;
+	}
+
+	if (req->to - req->from > MAX_RANGE) {
+		ip_set_printk("range too big (max %d ports)",
+			       MAX_RANGE+1);
+		return -ENOEXEC;
+	}
+
+	map = kmalloc(sizeof(struct ip_set_portmap), GFP_KERNEL);
+	if (!map) {
+		DP("out of memory for %d bytes",
+		   sizeof(struct ip_set_portmap));
+		return -ENOMEM;
+	}
+	map->first_port = req->from;
+	map->last_port = req->to;
+	newbytes = bitmap_bytes(req->from, req->to);
+	map->members = kmalloc(newbytes, GFP_KERNEL);
+	if (!map->members) {
+		DP("out of memory for %d bytes", newbytes);
+		kfree(map);
+		return -ENOMEM;
+	}
+	memset(map->members, 0, newbytes);
+
+	set->data = map;
+	return 0;
+}
+
+static void destroy(struct ip_set *set)
+{
+	struct ip_set_portmap *map = (struct ip_set_portmap *) set->data;
+
+	kfree(map->members);
+	kfree(map);
+
+	set->data = NULL;
+}
+
+static void flush(struct ip_set *set)
+{
+	struct ip_set_portmap *map = (struct ip_set_portmap *) set->data;
+	memset(map->members, 0, bitmap_bytes(map->first_port, map->last_port));
+}
+
+static void list_header(const struct ip_set *set, void *data)
+{
+	struct ip_set_portmap *map = (struct ip_set_portmap *) set->data;
+	struct ip_set_req_portmap_create *header =
+	    (struct ip_set_req_portmap_create *) data;
+
+	DP("list_header %u %u", map->first_port, map->last_port);
+
+	header->from = map->first_port;
+	header->to = map->last_port;
+}
+
+static int list_members_size(const struct ip_set *set)
+{
+	struct ip_set_portmap *map = (struct ip_set_portmap *) set->data;
+
+	return bitmap_bytes(map->first_port, map->last_port);
+}
+
+static void list_members(const struct ip_set *set, void *data)
+{
+	struct ip_set_portmap *map = (struct ip_set_portmap *) set->data;
+	int bytes = bitmap_bytes(map->first_port, map->last_port);
+
+	memcpy(data, map->members, bytes);
+}
+
+static struct ip_set_type ip_set_portmap = {
+	.typename		= SETTYPE_NAME,
+	.features		= IPSET_TYPE_PORT | IPSET_DATA_SINGLE,
+	.protocol_version	= IP_SET_PROTOCOL_VERSION,
+	.create			= &create,
+	.destroy		= &destroy,
+	.flush			= &flush,
+	.reqsize		= sizeof(struct ip_set_req_portmap),
+	.addip			= &addport,
+	.addip_kernel		= &addport_kernel,
+	.delip			= &delport,
+	.delip_kernel		= &delport_kernel,
+	.testip			= &testport,
+	.testip_kernel		= &testport_kernel,
+	.header_size		= sizeof(struct ip_set_req_portmap_create),
+	.list_header		= &list_header,
+	.list_members_size	= &list_members_size,
+	.list_members		= &list_members,
+	.me			= THIS_MODULE,
+};
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>");
+MODULE_DESCRIPTION("portmap type of IP sets");
+
+static int __init ip_set_portmap_init(void)
+{
+	return ip_set_register_set_type(&ip_set_portmap);
+}
+
+static void __exit ip_set_portmap_fini(void)
+{
+	/* FIXME: possible race with ip_set_create() */
+	ip_set_unregister_set_type(&ip_set_portmap);
+}
+
+module_init(ip_set_portmap_init);
+module_exit(ip_set_portmap_fini);
diff -Nru linux-2.6.30.5/net/ipv4/netfilter/ip_tables.c linux-2.6.30.5-wrt/net/ipv4/netfilter/ip_tables.c
--- linux-2.6.30.5/net/ipv4/netfilter/ip_tables.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/net/ipv4/netfilter/ip_tables.c	2009-09-06 18:43:48.370668913 +0200
@@ -87,6 +87,9 @@
 
 #define FWINV(bool, invflg) ((bool) ^ !!(ipinfo->invflags & (invflg)))
 
+	if (ipinfo->flags & IPT_F_NO_DEF_MATCH)
+		return true;
+
 	if (FWINV((ip->saddr&ipinfo->smsk.s_addr) != ipinfo->src.s_addr,
 		  IPT_INV_SRCIP)
 	    || FWINV((ip->daddr&ipinfo->dmsk.s_addr) != ipinfo->dst.s_addr,
@@ -137,13 +140,35 @@
 		return false;
 	}
 
+#undef FWINV
 	return true;
 }
 
 static bool
-ip_checkentry(const struct ipt_ip *ip)
+ip_checkentry(struct ipt_ip *ip)
 {
-	if (ip->flags & ~IPT_F_MASK) {
+#define FWINV(bool, invflg) ((bool) || (ip->invflags & (invflg)))
+
+	if (FWINV(ip->smsk.s_addr, IPT_INV_SRCIP) ||
+		FWINV(ip->dmsk.s_addr, IPT_INV_DSTIP))
+		goto has_match_rules;
+
+	if (FWINV(!!((const unsigned long *)ip->iniface_mask)[0],
+		IPT_INV_VIA_IN) ||
+	    FWINV(!!((const unsigned long *)ip->outiface_mask)[0],
+		IPT_INV_VIA_OUT))
+		goto has_match_rules;
+
+	if (FWINV(ip->proto, IPT_INV_PROTO))
+		goto has_match_rules;
+
+	if (FWINV(ip->flags&IPT_F_FRAG, IPT_INV_FRAG))
+		goto has_match_rules;
+
+	ip->flags |= IPT_F_NO_DEF_MATCH;
+
+has_match_rules:
+	if (ip->flags & ~(IPT_F_MASK|IPT_F_NO_DEF_MATCH)) {
 		duprintf("Unknown flag bits set: %08X\n",
 			 ip->flags & ~IPT_F_MASK);
 		return false;
@@ -153,6 +178,8 @@
 			 ip->invflags & ~IPT_INV_MASK);
 		return false;
 	}
+
+#undef FWINV
 	return true;
 }
 
@@ -200,7 +227,6 @@
 			return 0;
 
 	return 1;
-#undef FWINV
 }
 
 #if defined(CONFIG_NETFILTER_XT_TARGET_TRACE) || \
@@ -318,8 +344,28 @@
 	struct xt_match_param mtpar;
 	struct xt_target_param tgpar;
 
-	/* Initialization */
 	ip = ip_hdr(skb);
+
+	IP_NF_ASSERT(table->valid_hooks & (1 << hook));
+	xt_info_rdlock_bh();
+	private = table->private;
+	table_base = private->entries[smp_processor_id()];
+	e = get_entry(table_base, private->hook_entry[hook]);
+
+	if (e->target_offset <= sizeof(struct ipt_entry) &&
+		(e->ip.flags & IPT_F_NO_DEF_MATCH)) {
+			struct ipt_entry_target *t = ipt_get_target(e);
+			if (!t->u.kernel.target->target) {
+				int v = ((struct ipt_standard_target *)t)->verdict;
+				if ((v < 0) && (v != IPT_RETURN)) {
+					ADD_COUNTER(e->counters, ntohs(ip->tot_len), 1);
+					xt_info_rdunlock_bh();
+					return (unsigned)(-v) - 1;
+				}
+			}
+	}
+
+	/* Initialization */
 	datalen = skb->len - ip->ihl * 4;
 	indev = in ? in->name : nulldevname;
 	outdev = out ? out->name : nulldevname;
@@ -337,13 +383,6 @@
 	mtpar.family  = tgpar.family = NFPROTO_IPV4;
 	tgpar.hooknum = hook;
 
-	IP_NF_ASSERT(table->valid_hooks & (1 << hook));
-	xt_info_rdlock_bh();
-	private = table->private;
-	table_base = private->entries[smp_processor_id()];
-
-	e = get_entry(table_base, private->hook_entry[hook]);
-
 	/* For return from builtin chain */
 	back = get_entry(table_base, private->underflow[hook]);
 
diff -Nru linux-2.6.30.5/net/ipv4/netfilter/ipt_SET.c linux-2.6.30.5-wrt/net/ipv4/netfilter/ipt_SET.c
--- linux-2.6.30.5/net/ipv4/netfilter/ipt_SET.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/net/ipv4/netfilter/ipt_SET.c	2009-09-06 18:43:48.378666801 +0200
@@ -0,0 +1,179 @@
+/* Copyright (C) 2000-2002 Joakim Axelsson <gozem@linux.nu>
+ *                         Patrick Schaaf <bof@bof.de>
+ *                         Martin Josefsson <gandalf@wlug.westbo.se>
+ * Copyright (C) 2003-2004 Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/* ipt_SET.c - netfilter target to manipulate IP sets */
+
+#include <linux/types.h>
+#include <linux/ip.h>
+#include <linux/timer.h>
+#include <linux/module.h>
+#include <linux/netfilter.h>
+#include <linux/netdevice.h>
+#include <linux/if.h>
+#include <linux/inetdevice.h>
+#include <linux/version.h>
+#include <net/protocol.h>
+#include <net/checksum.h>
+#include <linux/netfilter_ipv4.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_set.h>
+
+static unsigned int
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+target(struct sk_buff *skb,
+#else
+target(struct sk_buff **pskb,
+#endif
+       const struct net_device *in,
+       const struct net_device *out,
+       unsigned int hooknum,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,17)
+       const struct xt_target *target,
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+       const void *targinfo,
+       void *userinfo)
+#else
+       const void *targinfo)
+#endif
+{
+	const struct ipt_set_info_target *info = targinfo;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+	struct sk_buff *skb = *pskb;
+#endif
+
+	if (info->add_set.index != IP_SET_INVALID_ID)
+		ip_set_addip_kernel(info->add_set.index,
+				    skb,
+				    info->add_set.flags);
+	if (info->del_set.index != IP_SET_INVALID_ID)
+		ip_set_delip_kernel(info->del_set.index,
+				    skb,
+				    info->del_set.flags);
+
+	return IPT_CONTINUE;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)
+static bool
+#else
+static int
+#endif
+checkentry(const char *tablename,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+	   const void *e,
+#else
+	   const struct ipt_entry *e,
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,17)
+	   const struct xt_target *target,
+#endif
+	   void *targinfo,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+	   unsigned int targinfosize,
+#endif
+	   unsigned int hook_mask)
+{
+	struct ipt_set_info_target *info =
+		(struct ipt_set_info_target *) targinfo;
+	ip_set_id_t index;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+	if (targinfosize != IPT_ALIGN(sizeof(*info))) {
+		DP("bad target info size %u", targinfosize);
+		return 0;
+	}
+#endif
+
+	if (info->add_set.index != IP_SET_INVALID_ID) {
+		index = ip_set_get_byindex(info->add_set.index);
+		if (index == IP_SET_INVALID_ID) {
+			ip_set_printk("cannot find add_set index %u as target",
+				      info->add_set.index);
+			return 0;	/* error */
+		}
+	}
+
+	if (info->del_set.index != IP_SET_INVALID_ID) {
+		index = ip_set_get_byindex(info->del_set.index);
+		if (index == IP_SET_INVALID_ID) {
+			ip_set_printk("cannot find del_set index %u as target",
+				      info->del_set.index);
+			return 0;	/* error */
+		}
+	}
+	if (info->add_set.flags[IP_SET_MAX_BINDINGS] != 0
+	    || info->del_set.flags[IP_SET_MAX_BINDINGS] != 0) {
+		ip_set_printk("That's nasty!");
+		return 0;	/* error */
+	}
+
+	return 1;
+}
+
+static void destroy(
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,17)
+		    const struct xt_target *target,
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+		    void *targetinfo, unsigned int targetsize)
+#else
+		    void *targetinfo)
+#endif
+{
+	struct ipt_set_info_target *info = targetinfo;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+	if (targetsize != IPT_ALIGN(sizeof(struct ipt_set_info_target))) {
+		ip_set_printk("invalid targetsize %d", targetsize);
+		return;
+	}
+#endif
+	if (info->add_set.index != IP_SET_INVALID_ID)
+		ip_set_put(info->add_set.index);
+	if (info->del_set.index != IP_SET_INVALID_ID)
+		ip_set_put(info->del_set.index);
+}
+
+static struct ipt_target SET_target = {
+	.name 		= "SET",
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,21)
+	.family		= AF_INET,
+#endif
+	.target 	= target,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,17)
+	.targetsize	= sizeof(struct ipt_set_info_target),
+#endif
+	.checkentry 	= checkentry,
+	.destroy 	= destroy,
+	.me 		= THIS_MODULE
+};
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>");
+MODULE_DESCRIPTION("iptables IP set target module");
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,21)
+#define ipt_register_target      xt_register_target
+#define ipt_unregister_target    xt_unregister_target
+#endif
+
+static int __init ipt_SET_init(void)
+{
+	return ipt_register_target(&SET_target);
+}
+
+static void __exit ipt_SET_fini(void)
+{
+	ipt_unregister_target(&SET_target);
+}
+
+module_init(ipt_SET_init);
+module_exit(ipt_SET_fini);
diff -Nru linux-2.6.30.5/net/ipv4/netfilter/ipt_set.c linux-2.6.30.5-wrt/net/ipv4/netfilter/ipt_set.c
--- linux-2.6.30.5/net/ipv4/netfilter/ipt_set.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/net/ipv4/netfilter/ipt_set.c	2009-09-06 18:43:48.378666801 +0200
@@ -0,0 +1,160 @@
+/* Copyright (C) 2000-2002 Joakim Axelsson <gozem@linux.nu>
+ *                         Patrick Schaaf <bof@bof.de>
+ *                         Martin Josefsson <gandalf@wlug.westbo.se>
+ * Copyright (C) 2003-2004 Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/* Kernel module to match an IP set. */
+
+#include <linux/module.h>
+#include <linux/ip.h>
+#include <linux/skbuff.h>
+#include <linux/version.h>
+
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ip_set.h>
+#include <linux/netfilter_ipv4/ipt_set.h>
+
+static inline int
+match_set(const struct ipt_set_info *info,
+	  const struct sk_buff *skb,
+	  int inv)
+{
+	if (ip_set_testip_kernel(info->index, skb, info->flags))
+		inv = !inv;
+	return inv;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)
+static bool
+#else
+static int
+#endif
+match(const struct sk_buff *skb,
+      const struct net_device *in,
+      const struct net_device *out,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,17)
+      const struct xt_match *match,
+#endif
+      const void *matchinfo,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)
+      int offset, unsigned int protoff, bool *hotdrop)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+      int offset, unsigned int protoff, int *hotdrop)
+#else
+      int offset, int *hotdrop)
+#endif
+{
+	const struct ipt_set_info_match *info = matchinfo;
+
+	return match_set(&info->match_set,
+			 skb,
+			 info->match_set.flags[0] & IPSET_MATCH_INV);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)
+bool
+#else
+static int
+#endif
+checkentry(const char *tablename,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+	   const void *inf,
+#else
+	   const struct ipt_ip *ip,
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,17)
+	   const struct xt_match *match,
+#endif
+	   void *matchinfo,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+	   unsigned int matchsize,
+#endif
+	   unsigned int hook_mask)
+{
+	struct ipt_set_info_match *info =
+		(struct ipt_set_info_match *) matchinfo;
+	ip_set_id_t index;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+	if (matchsize != IPT_ALIGN(sizeof(struct ipt_set_info_match))) {
+		ip_set_printk("invalid matchsize %d", matchsize);
+		return 0;
+	}
+#endif
+
+	index = ip_set_get_byindex(info->match_set.index);
+
+	if (index == IP_SET_INVALID_ID) {
+		ip_set_printk("Cannot find set indentified by id %u to match",
+			      info->match_set.index);
+		return 0;	/* error */
+	}
+	if (info->match_set.flags[IP_SET_MAX_BINDINGS] != 0) {
+		ip_set_printk("That's nasty!");
+		return 0;	/* error */
+	}
+
+	return 1;
+}
+
+static void destroy(
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,17)
+		    const struct xt_match *match,
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+		    void *matchinfo, unsigned int matchsize)
+#else
+		    void *matchinfo)
+#endif
+{
+	struct ipt_set_info_match *info = matchinfo;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+	if (matchsize != IPT_ALIGN(sizeof(struct ipt_set_info_match))) {
+		ip_set_printk("invalid matchsize %d", matchsize);
+		return;
+	}
+#endif
+	ip_set_put(info->match_set.index);
+}
+
+static struct ipt_match set_match = {
+	.name		= "set",
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,21)
+	.family		= AF_INET,
+#endif
+	.match		= &match,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,17)
+	.matchsize	= sizeof(struct ipt_set_info_match),
+#endif
+	.checkentry	= &checkentry,
+	.destroy	= &destroy,
+	.me		= THIS_MODULE
+};
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>");
+MODULE_DESCRIPTION("iptables IP set match module");
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,21)
+#define ipt_register_match	xt_register_match
+#define ipt_unregister_match	xt_unregister_match
+#endif
+
+static int __init ipt_ipset_init(void)
+{
+	return ipt_register_match(&set_match);
+}
+
+static void __exit ipt_ipset_fini(void)
+{
+	ipt_unregister_match(&set_match);
+}
+
+module_init(ipt_ipset_init);
+module_exit(ipt_ipset_fini);
diff -Nru linux-2.6.30.5/net/ipv4/netfilter/nf_nat_rtsp.c linux-2.6.30.5-wrt/net/ipv4/netfilter/nf_nat_rtsp.c
--- linux-2.6.30.5/net/ipv4/netfilter/nf_nat_rtsp.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/net/ipv4/netfilter/nf_nat_rtsp.c	2009-09-06 18:43:48.398678472 +0200
@@ -0,0 +1,496 @@
+/*
+ * RTSP extension for TCP NAT alteration
+ * (C) 2003 by Tom Marshall <tmarshall at real.com>
+ * based on ip_nat_irc.c
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ * Module load syntax:
+ *      insmod nf_nat_rtsp.o ports=port1,port2,...port<MAX_PORTS>
+ *                           stunaddr=<address>
+ *                           destaction=[auto|strip|none]
+ *
+ * If no ports are specified, the default will be port 554 only.
+ *
+ * stunaddr specifies the address used to detect that a client is using STUN.
+ * If this address is seen in the destination parameter, it is assumed that
+ * the client has already punched a UDP hole in the firewall, so we don't
+ * mangle the client_port.  If none is specified, it is autodetected.  It
+ * only needs to be set if you have multiple levels of NAT.  It should be
+ * set to the external address that the STUN clients detect.  Note that in
+ * this case, it will not be possible for clients to use UDP with servers
+ * between the NATs.
+ *
+ * If no destaction is specified, auto is used.
+ *   destaction=auto:  strip destination parameter if it is not stunaddr.
+ *   destaction=strip: always strip destination parameter (not recommended).
+ *   destaction=none:  do not touch destination parameter (not recommended).
+ */
+
+#include <linux/module.h>
+#include <net/tcp.h>
+#include <net/netfilter/nf_nat_helper.h>
+#include <net/netfilter/nf_nat_rule.h>
+#include <linux/netfilter/nf_conntrack_rtsp.h>
+#include <net/netfilter/nf_conntrack_expect.h>
+
+#include <linux/inet.h>
+#include <linux/ctype.h>
+#define NF_NEED_STRNCASECMP
+#define NF_NEED_STRTOU16
+#include <linux/netfilter_helpers.h>
+#define NF_NEED_MIME_NEXTLINE
+#include <linux/netfilter_mime.h>
+
+#define INFOP(fmt, args...) printk(KERN_INFO "%s: %s: " fmt, __FILE__, __FUNCTION__ , ## args)
+#if 0
+#define DEBUGP(fmt, args...) printk(KERN_DEBUG "%s: %s: " fmt, __FILE__, __FUNCTION__ , ## args)
+#else
+#define DEBUGP(fmt, args...)
+#endif
+
+#define MAX_PORTS       8
+#define DSTACT_AUTO     0
+#define DSTACT_STRIP    1
+#define DSTACT_NONE     2
+
+static char*    stunaddr = NULL;
+static char*    destaction = NULL;
+
+static u_int32_t extip = 0;
+static int       dstact = 0;
+
+MODULE_AUTHOR("Tom Marshall <tmarshall at real.com>");
+MODULE_DESCRIPTION("RTSP network address translation module");
+MODULE_LICENSE("GPL");
+module_param(stunaddr, charp, 0644);
+MODULE_PARM_DESC(stunaddr, "Address for detecting STUN");
+module_param(destaction, charp, 0644);
+MODULE_PARM_DESC(destaction, "Action for destination parameter (auto/strip/none)");
+
+#define SKIP_WSPACE(ptr,len,off) while(off < len && isspace(*(ptr+off))) { off++; }
+
+/*** helper functions ***/
+
+static void
+get_skb_tcpdata(struct sk_buff* skb, char** pptcpdata, uint* ptcpdatalen)
+{
+    struct iphdr*   iph  = ip_hdr(skb);
+    struct tcphdr*  tcph = (void *)iph + ip_hdrlen(skb);
+
+    *pptcpdata = (char*)tcph +  tcph->doff*4;
+    *ptcpdatalen = ((char*)skb_transport_header(skb) + skb->len) - *pptcpdata;
+}
+
+/*** nat functions ***/
+
+/*
+ * Mangle the "Transport:" header:
+ *   - Replace all occurences of "client_port=<spec>"
+ *   - Handle destination parameter
+ *
+ * In:
+ *   ct, ctinfo = conntrack context
+ *   skb        = packet
+ *   tranoff    = Transport header offset from TCP data
+ *   tranlen    = Transport header length (incl. CRLF)
+ *   rport_lo   = replacement low  port (host endian)
+ *   rport_hi   = replacement high port (host endian)
+ *
+ * Returns packet size difference.
+ *
+ * Assumes that a complete transport header is present, ending with CR or LF
+ */
+static int
+rtsp_mangle_tran(enum ip_conntrack_info ctinfo,
+                 struct nf_conntrack_expect* exp,
+								 struct ip_ct_rtsp_expect* prtspexp,
+                 struct sk_buff* skb, uint tranoff, uint tranlen)
+{
+    char*       ptcp;
+    uint        tcplen;
+    char*       ptran;
+    char        rbuf1[16];      /* Replacement buffer (one port) */
+    uint        rbuf1len;       /* Replacement len (one port) */
+    char        rbufa[16];      /* Replacement buffer (all ports) */
+    uint        rbufalen;       /* Replacement len (all ports) */
+    u_int32_t   newip;
+    u_int16_t   loport, hiport;
+    uint        off = 0;
+    uint        diff;           /* Number of bytes we removed */
+
+    struct nf_conn *ct = exp->master;
+    struct nf_conntrack_tuple *t;
+
+    char    szextaddr[15+1];
+    uint    extaddrlen;
+    int     is_stun;
+
+    get_skb_tcpdata(skb, &ptcp, &tcplen);
+    ptran = ptcp+tranoff;
+
+    if (tranoff+tranlen > tcplen || tcplen-tranoff < tranlen ||
+        tranlen < 10 || !iseol(ptran[tranlen-1]) ||
+        nf_strncasecmp(ptran, "Transport:", 10) != 0)
+    {
+        INFOP("sanity check failed\n");
+        return 0;
+    }
+    off += 10;
+    SKIP_WSPACE(ptcp+tranoff, tranlen, off);
+
+    newip = ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip;
+    t = &exp->tuple;
+    t->dst.u3.ip = newip;
+
+    extaddrlen = extip ? sprintf(szextaddr, "%u.%u.%u.%u", NIPQUAD(extip))
+                       : sprintf(szextaddr, "%u.%u.%u.%u", NIPQUAD(newip));
+    DEBUGP("stunaddr=%s (%s)\n", szextaddr, (extip?"forced":"auto"));
+
+    rbuf1len = rbufalen = 0;
+    switch (prtspexp->pbtype)
+    {
+    case pb_single:
+        for (loport = prtspexp->loport; loport != 0; loport++) /* XXX: improper wrap? */
+        {
+            t->dst.u.udp.port = htons(loport);
+            if (nf_ct_expect_related(exp) == 0)
+            {
+                DEBUGP("using port %hu\n", loport);
+                break;
+            }
+        }
+        if (loport != 0)
+        {
+            rbuf1len = sprintf(rbuf1, "%hu", loport);
+            rbufalen = sprintf(rbufa, "%hu", loport);
+        }
+        break;
+    case pb_range:
+        for (loport = prtspexp->loport; loport != 0; loport += 2) /* XXX: improper wrap? */
+        {
+            t->dst.u.udp.port = htons(loport);
+            if (nf_ct_expect_related(exp) == 0)
+            {
+                hiport = loport + ~exp->mask.src.u.udp.port;
+                DEBUGP("using ports %hu-%hu\n", loport, hiport);
+                break;
+            }
+        }
+        if (loport != 0)
+        {
+            rbuf1len = sprintf(rbuf1, "%hu", loport);
+            rbufalen = sprintf(rbufa, "%hu-%hu", loport, loport+1);
+        }
+        break;
+    case pb_discon:
+        for (loport = prtspexp->loport; loport != 0; loport++) /* XXX: improper wrap? */
+        {
+            t->dst.u.udp.port = htons(loport);
+            if (nf_ct_expect_related(exp) == 0)
+            {
+                DEBUGP("using port %hu (1 of 2)\n", loport);
+                break;
+            }
+        }
+        for (hiport = prtspexp->hiport; hiport != 0; hiport++) /* XXX: improper wrap? */
+        {
+            t->dst.u.udp.port = htons(hiport);
+            if (nf_ct_expect_related(exp) == 0)
+            {
+                DEBUGP("using port %hu (2 of 2)\n", hiport);
+                break;
+            }
+        }
+        if (loport != 0 && hiport != 0)
+        {
+            rbuf1len = sprintf(rbuf1, "%hu", loport);
+            if (hiport == loport+1)
+            {
+                rbufalen = sprintf(rbufa, "%hu-%hu", loport, hiport);
+            }
+            else
+            {
+                rbufalen = sprintf(rbufa, "%hu/%hu", loport, hiport);
+            }
+        }
+        break;
+    }
+
+    if (rbuf1len == 0)
+    {
+        return 0;   /* cannot get replacement port(s) */
+    }
+
+    /* Transport: tran;field;field=val,tran;field;field=val,... */
+    while (off < tranlen)
+    {
+        uint        saveoff;
+        const char* pparamend;
+        uint        nextparamoff;
+
+        pparamend = memchr(ptran+off, ',', tranlen-off);
+        pparamend = (pparamend == NULL) ? ptran+tranlen : pparamend+1;
+        nextparamoff = pparamend-ptcp;
+
+        /*
+         * We pass over each param twice.  On the first pass, we look for a
+         * destination= field.  It is handled by the security policy.  If it
+         * is present, allowed, and equal to our external address, we assume
+         * that STUN is being used and we leave the client_port= field alone.
+         */
+        is_stun = 0;
+        saveoff = off;
+        while (off < nextparamoff)
+        {
+            const char* pfieldend;
+            uint        nextfieldoff;
+
+            pfieldend = memchr(ptran+off, ';', nextparamoff-off);
+            nextfieldoff = (pfieldend == NULL) ? nextparamoff : pfieldend-ptran+1;
+
+            if (dstact != DSTACT_NONE && strncmp(ptran+off, "destination=", 12) == 0)
+            {
+                if (strncmp(ptran+off+12, szextaddr, extaddrlen) == 0)
+                {
+                    is_stun = 1;
+                }
+                if (dstact == DSTACT_STRIP || (dstact == DSTACT_AUTO && !is_stun))
+                {
+                    diff = nextfieldoff-off;
+                    if (!nf_nat_mangle_tcp_packet(skb, ct, ctinfo,
+                                                         off, diff, NULL, 0))
+                    {
+                        /* mangle failed, all we can do is bail */
+			nf_ct_unexpect_related(exp);
+                        return 0;
+                    }
+                    get_skb_tcpdata(skb, &ptcp, &tcplen);
+                    ptran = ptcp+tranoff;
+                    tranlen -= diff;
+                    nextparamoff -= diff;
+                    nextfieldoff -= diff;
+                }
+            }
+
+            off = nextfieldoff;
+        }
+        if (is_stun)
+        {
+            continue;
+        }
+        off = saveoff;
+        while (off < nextparamoff)
+        {
+            const char* pfieldend;
+            uint        nextfieldoff;
+
+            pfieldend = memchr(ptran+off, ';', nextparamoff-off);
+            nextfieldoff = (pfieldend == NULL) ? nextparamoff : pfieldend-ptran+1;
+
+            if (strncmp(ptran+off, "client_port=", 12) == 0)
+            {
+                u_int16_t   port;
+                uint        numlen;
+                uint        origoff;
+                uint        origlen;
+                char*       rbuf    = rbuf1;
+                uint        rbuflen = rbuf1len;
+
+                off += 12;
+                origoff = (ptran-ptcp)+off;
+                origlen = 0;
+                numlen = nf_strtou16(ptran+off, &port);
+                off += numlen;
+                origlen += numlen;
+                if (port != prtspexp->loport)
+                {
+                    DEBUGP("multiple ports found, port %hu ignored\n", port);
+                }
+                else
+                {
+                    if (ptran[off] == '-' || ptran[off] == '/')
+                    {
+                        off++;
+                        origlen++;
+                        numlen = nf_strtou16(ptran+off, &port);
+                        off += numlen;
+                        origlen += numlen;
+                        rbuf = rbufa;
+                        rbuflen = rbufalen;
+                    }
+
+                    /*
+                     * note we cannot just memcpy() if the sizes are the same.
+                     * the mangle function does skb resizing, checks for a
+                     * cloned skb, and updates the checksums.
+                     *
+                     * parameter 4 below is offset from start of tcp data.
+                     */
+                    diff = origlen-rbuflen;
+                    if (!nf_nat_mangle_tcp_packet(skb, ct, ctinfo,
+                                              origoff, origlen, rbuf, rbuflen))
+                    {
+                        /* mangle failed, all we can do is bail */
+			nf_ct_unexpect_related(exp);
+                        return 0;
+                    }
+                    get_skb_tcpdata(skb, &ptcp, &tcplen);
+                    ptran = ptcp+tranoff;
+                    tranlen -= diff;
+                    nextparamoff -= diff;
+                    nextfieldoff -= diff;
+                }
+            }
+
+            off = nextfieldoff;
+        }
+
+        off = nextparamoff;
+    }
+
+    return 1;
+}
+
+static uint
+help_out(struct sk_buff *skb, enum ip_conntrack_info ctinfo,
+	 unsigned int matchoff, unsigned int matchlen, struct ip_ct_rtsp_expect* prtspexp,
+	 struct nf_conntrack_expect* exp)
+{
+    char*   ptcp;
+    uint    tcplen;
+    uint    hdrsoff;
+    uint    hdrslen;
+    uint    lineoff;
+    uint    linelen;
+    uint    off;
+
+    //struct iphdr* iph = (struct iphdr*)skb->nh.iph;
+    //struct tcphdr* tcph = (struct tcphdr*)((void*)iph + iph->ihl*4);
+
+    get_skb_tcpdata(skb, &ptcp, &tcplen);
+    hdrsoff = matchoff;//exp->seq - ntohl(tcph->seq);
+    hdrslen = matchlen;
+    off = hdrsoff;
+    DEBUGP("NAT rtsp help_out\n");
+
+    while (nf_mime_nextline(ptcp, hdrsoff+hdrslen, &off, &lineoff, &linelen))
+    {
+        if (linelen == 0)
+        {
+            break;
+        }
+        if (off > hdrsoff+hdrslen)
+        {
+            INFOP("!! overrun !!");
+            break;
+        }
+        DEBUGP("hdr: len=%u, %.*s", linelen, (int)linelen, ptcp+lineoff);
+
+        if (nf_strncasecmp(ptcp+lineoff, "Transport:", 10) == 0)
+        {
+            uint oldtcplen = tcplen;
+	    DEBUGP("hdr: Transport\n");
+            if (!rtsp_mangle_tran(ctinfo, exp, prtspexp, skb, lineoff, linelen))
+            {
+		DEBUGP("hdr: Transport mangle failed");
+                break;
+            }
+            get_skb_tcpdata(skb, &ptcp, &tcplen);
+            hdrslen -= (oldtcplen-tcplen);
+            off -= (oldtcplen-tcplen);
+            lineoff -= (oldtcplen-tcplen);
+            linelen -= (oldtcplen-tcplen);
+            DEBUGP("rep: len=%u, %.*s", linelen, (int)linelen, ptcp+lineoff);
+        }
+    }
+
+    return NF_ACCEPT;
+}
+
+static unsigned int
+help(struct sk_buff *skb, enum ip_conntrack_info ctinfo,
+     unsigned int matchoff, unsigned int matchlen, struct ip_ct_rtsp_expect* prtspexp,
+     struct nf_conntrack_expect* exp)
+{
+    int dir = CTINFO2DIR(ctinfo);
+    int rc = NF_ACCEPT;
+
+    switch (dir)
+    {
+    case IP_CT_DIR_ORIGINAL:
+        rc = help_out(skb, ctinfo, matchoff, matchlen, prtspexp, exp);
+        break;
+    case IP_CT_DIR_REPLY:
+	DEBUGP("unmangle ! %u\n", ctinfo);
+    	/* XXX: unmangle */
+	rc = NF_ACCEPT;
+        break;
+    }
+    //UNLOCK_BH(&ip_rtsp_lock);
+
+    return rc;
+}
+
+static void expected(struct nf_conn* ct, struct nf_conntrack_expect *exp)
+{
+    struct nf_nat_multi_range_compat mr;
+    u_int32_t newdstip, newsrcip, newip;
+
+    struct nf_conn *master = ct->master;
+
+    newdstip = master->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;
+    newsrcip = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;
+    //FIXME (how to port that ?)
+    //code from 2.4 : newip = (HOOK2MANIP(hooknum) == IP_NAT_MANIP_SRC) ? newsrcip : newdstip;
+    newip = newdstip;
+
+    DEBUGP("newsrcip=%u.%u.%u.%u, newdstip=%u.%u.%u.%u, newip=%u.%u.%u.%u\n",
+           NIPQUAD(newsrcip), NIPQUAD(newdstip), NIPQUAD(newip));
+
+    mr.rangesize = 1;
+    // We don't want to manip the per-protocol, just the IPs.
+    mr.range[0].flags = IP_NAT_RANGE_MAP_IPS;
+    mr.range[0].min_ip = mr.range[0].max_ip = newip;
+
+    nf_nat_setup_info(ct, &mr.range[0], IP_NAT_MANIP_DST);
+}
+
+
+static void __exit fini(void)
+{
+	nf_nat_rtsp_hook = NULL;
+        nf_nat_rtsp_hook_expectfn = NULL;
+	synchronize_net();
+}
+
+static int __init init(void)
+{
+	printk("nf_nat_rtsp v" IP_NF_RTSP_VERSION " loading\n");
+
+	BUG_ON(nf_nat_rtsp_hook);
+	nf_nat_rtsp_hook = help;
+        nf_nat_rtsp_hook_expectfn = &expected;
+
+	if (stunaddr != NULL)
+		extip = in_aton(stunaddr);
+
+	if (destaction != NULL) {
+	        if (strcmp(destaction, "auto") == 0)
+			dstact = DSTACT_AUTO;
+
+		if (strcmp(destaction, "strip") == 0)
+			dstact = DSTACT_STRIP;
+
+		if (strcmp(destaction, "none") == 0)
+			dstact = DSTACT_NONE;
+	}
+
+	return 0;
+}
+
+module_init(init);
+module_exit(fini);
diff -Nru linux-2.6.30.5/net/netfilter/Kconfig linux-2.6.30.5-wrt/net/netfilter/Kconfig
--- linux-2.6.30.5/net/netfilter/Kconfig	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/net/netfilter/Kconfig	2009-09-06 18:43:48.394667414 +0200
@@ -160,7 +160,6 @@
 
 config NF_CONNTRACK_H323
 	tristate "H.323 protocol support"
-	depends on (IPV6 || IPV6=n)
 	depends on NETFILTER_ADVANCED
 	help
 	  H.323 is a VoIP signalling protocol from ITU-T. As one of the most
@@ -268,6 +267,16 @@
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config NF_CONNTRACK_RTSP
+	tristate "RTSP protocol support"
+	depends on NF_CONNTRACK
+	help
+		Support the RTSP protocol.  This allows UDP transports to be setup
+		properly, including RTP and RDT.
+
+		If you want to compile it as a module, say 'M' here and read
+		Documentation/modules.txt.  If unsure, say 'Y'.
+
 config NF_CT_NETLINK
 	tristate 'Connection tracking netlink interface'
 	select NETFILTER_NETLINK
@@ -396,6 +405,18 @@
 	  For more information on the LEDs available on your system, see
 	  Documentation/leds-class.txt
 
+config NETFILTER_XT_TARGET_IMQ
+        tristate '"IMQ" target support'
+	depends on NETFILTER_XTABLES
+	depends on IP_NF_MANGLE || IP6_NF_MANGLE
+	select IMQ
+	default m if NETFILTER_ADVANCED=n
+        help
+          This option adds a `IMQ' target which is used to specify if and
+          to which imq device packets should get enqueued/dequeued.
+
+          To compile it as a module, choose M here.  If unsure, say N.
+
 config NETFILTER_XT_TARGET_MARK
 	tristate '"MARK" target support'
 	default m if NETFILTER_ADVANCED=n
@@ -493,7 +514,6 @@
 
 config NETFILTER_XT_TARGET_TCPMSS
 	tristate '"TCPMSS" target support'
-	depends on (IPV6 || IPV6=n)
 	default m if NETFILTER_ADVANCED=n
 	---help---
 	  This option adds a `TCPMSS' target, which allows you to alter the
@@ -858,6 +878,27 @@
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config NETFILTER_XT_MATCH_LAYER7
+	tristate '"layer7" match support'
+	depends on NETFILTER_XTABLES
+	depends on EXPERIMENTAL && (IP_NF_CONNTRACK || NF_CONNTRACK)
+       depends on NF_CT_ACCT
+	help
+	  Say Y if you want to be able to classify connections (and their
+	  packets) based on regular expression matching of their application
+	  layer data.   This is one way to classify applications such as
+	  peer-to-peer filesharing systems that do not always use the same
+	  port.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
+config NETFILTER_XT_MATCH_LAYER7_DEBUG
+        bool 'Layer 7 debugging output'
+        depends on NETFILTER_XT_MATCH_LAYER7
+        help
+          Say Y to get lots of debugging output.
+
+
 config NETFILTER_XT_MATCH_STATISTIC
 	tristate '"statistic" match support'
 	depends on NETFILTER_ADVANCED
diff -Nru linux-2.6.30.5/net/netfilter/Makefile linux-2.6.30.5-wrt/net/netfilter/Makefile
--- linux-2.6.30.5/net/netfilter/Makefile	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/net/netfilter/Makefile	2009-09-06 18:43:48.398678472 +0200
@@ -33,6 +33,7 @@
 obj-$(CONFIG_NF_CONNTRACK_SANE) += nf_conntrack_sane.o
 obj-$(CONFIG_NF_CONNTRACK_SIP) += nf_conntrack_sip.o
 obj-$(CONFIG_NF_CONNTRACK_TFTP) += nf_conntrack_tftp.o
+obj-$(CONFIG_NF_CONNTRACK_RTSP) += nf_conntrack_rtsp.o
 
 # transparent proxy support
 obj-$(CONFIG_NETFILTER_TPROXY) += nf_tproxy_core.o
@@ -46,6 +47,7 @@
 obj-$(CONFIG_NETFILTER_XT_TARGET_CONNSECMARK) += xt_CONNSECMARK.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_DSCP) += xt_DSCP.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_HL) += xt_HL.o
+obj-$(CONFIG_NETFILTER_XT_TARGET_IMQ) += xt_IMQ.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_LED) += xt_LED.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_MARK) += xt_MARK.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_NFLOG) += xt_NFLOG.o
@@ -88,6 +90,7 @@
 obj-$(CONFIG_NETFILTER_XT_MATCH_SCTP) += xt_sctp.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_SOCKET) += xt_socket.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_STATE) += xt_state.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_LAYER7) += xt_layer7.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_STATISTIC) += xt_statistic.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_STRING) += xt_string.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_TCPMSS) += xt_tcpmss.o
diff -Nru linux-2.6.30.5/net/netfilter/nf_conntrack_core.c linux-2.6.30.5-wrt/net/netfilter/nf_conntrack_core.c
--- linux-2.6.30.5/net/netfilter/nf_conntrack_core.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/net/netfilter/nf_conntrack_core.c	2009-09-06 18:43:48.362668493 +0200
@@ -203,6 +203,14 @@
 	 * too. */
 	nf_ct_remove_expectations(ct);
 
+	#if defined(CONFIG_NETFILTER_XT_MATCH_LAYER7) || defined(CONFIG_NETFILTER_XT_MATCH_LAYER7_MODULE)
+	if(ct->layer7.app_proto)
+		kfree(ct->layer7.app_proto);
+	if(ct->layer7.app_data)
+	kfree(ct->layer7.app_data);
+	#endif
+
+
 	/* We overload first tuple to link into unconfirmed list. */
 	if (!nf_ct_is_confirmed(ct)) {
 		BUG_ON(hlist_nulls_unhashed(&ct->tuplehash[IP_CT_DIR_ORIGINAL].hnnode));
diff -Nru linux-2.6.30.5/net/netfilter/nf_conntrack_rtsp.c linux-2.6.30.5-wrt/net/netfilter/nf_conntrack_rtsp.c
--- linux-2.6.30.5/net/netfilter/nf_conntrack_rtsp.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/net/netfilter/nf_conntrack_rtsp.c	2009-09-06 18:43:48.398678472 +0200
@@ -0,0 +1,517 @@
+/*
+ * RTSP extension for IP connection tracking
+ * (C) 2003 by Tom Marshall <tmarshall at real.com>
+ * based on ip_conntrack_irc.c
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ * Module load syntax:
+ *   insmod nf_conntrack_rtsp.o ports=port1,port2,...port<MAX_PORTS>
+ *                              max_outstanding=n setup_timeout=secs
+ *
+ * If no ports are specified, the default will be port 554.
+ *
+ * With max_outstanding you can define the maximum number of not yet
+ * answered SETUP requests per RTSP session (default 8).
+ * With setup_timeout you can specify how long the system waits for
+ * an expected data channel (default 300 seconds).
+ *
+ * 2005-02-13: Harald Welte <laforge at netfilter.org>
+ * 	- port to 2.6
+ * 	- update to recent post-2.6.11 api changes
+ * 2006-09-14: Steven Van Acker <deepstar at singularity.be>
+ *      - removed calls to NAT code from conntrack helper: NAT no longer needed to use rtsp-conntrack
+ * 2007-04-18: Michael Guntsche <mike at it-loops.com>
+ * 			- Port to new NF API
+ */
+
+#include <linux/module.h>
+#include <linux/netfilter.h>
+#include <linux/ip.h>
+#include <linux/inet.h>
+#include <net/tcp.h>
+
+#include <net/netfilter/nf_conntrack.h>
+#include <net/netfilter/nf_conntrack_expect.h>
+#include <net/netfilter/nf_conntrack_helper.h>
+#include <linux/netfilter/nf_conntrack_rtsp.h>
+
+#define NF_NEED_STRNCASECMP
+#define NF_NEED_STRTOU16
+#define NF_NEED_STRTOU32
+#define NF_NEED_NEXTLINE
+#include <linux/netfilter_helpers.h>
+#define NF_NEED_MIME_NEXTLINE
+#include <linux/netfilter_mime.h>
+
+#include <linux/ctype.h>
+#define MAX_SIMUL_SETUP 8 /* XXX: use max_outstanding */
+#define INFOP(fmt, args...) printk(KERN_INFO "%s: %s: " fmt, __FILE__, __FUNCTION__ , ## args)
+#if 0
+#define DEBUGP(fmt, args...) printk(KERN_DEBUG "%s: %s: " fmt, __FILE__, __FUNCTION__ , ## args)
+#else
+#define DEBUGP(fmt, args...)
+#endif
+
+#define MAX_PORTS 8
+static int ports[MAX_PORTS];
+static int num_ports = 0;
+static int max_outstanding = 8;
+static unsigned int setup_timeout = 300;
+
+MODULE_AUTHOR("Tom Marshall <tmarshall at real.com>");
+MODULE_DESCRIPTION("RTSP connection tracking module");
+MODULE_LICENSE("GPL");
+module_param_array(ports, int, &num_ports, 0400);
+MODULE_PARM_DESC(ports, "port numbers of RTSP servers");
+module_param(max_outstanding, int, 0400);
+MODULE_PARM_DESC(max_outstanding, "max number of outstanding SETUP requests per RTSP session");
+module_param(setup_timeout, int, 0400);
+MODULE_PARM_DESC(setup_timeout, "timeout on for unestablished data channels");
+
+static char *rtsp_buffer;
+static DEFINE_SPINLOCK(rtsp_buffer_lock);
+
+unsigned int (*nf_nat_rtsp_hook)(struct sk_buff *skb,
+				 enum ip_conntrack_info ctinfo,
+				 unsigned int matchoff, unsigned int matchlen,struct ip_ct_rtsp_expect* prtspexp,
+				 struct nf_conntrack_expect *exp);
+void (*nf_nat_rtsp_hook_expectfn)(struct nf_conn *ct, struct nf_conntrack_expect *exp);
+
+EXPORT_SYMBOL_GPL(nf_nat_rtsp_hook);
+
+/*
+ * Max mappings we will allow for one RTSP connection (for RTP, the number
+ * of allocated ports is twice this value).  Note that SMIL burns a lot of
+ * ports so keep this reasonably high.  If this is too low, you will see a
+ * lot of "no free client map entries" messages.
+ */
+#define MAX_PORT_MAPS 16
+
+/*** default port list was here in the masq code: 554, 3030, 4040 ***/
+
+#define SKIP_WSPACE(ptr,len,off) while(off < len && isspace(*(ptr+off))) { off++; }
+
+/*
+ * Parse an RTSP packet.
+ *
+ * Returns zero if parsing failed.
+ *
+ * Parameters:
+ *  IN      ptcp        tcp data pointer
+ *  IN      tcplen      tcp data len
+ *  IN/OUT  ptcpoff     points to current tcp offset
+ *  OUT     phdrsoff    set to offset of rtsp headers
+ *  OUT     phdrslen    set to length of rtsp headers
+ *  OUT     pcseqoff    set to offset of CSeq header
+ *  OUT     pcseqlen    set to length of CSeq header
+ */
+static int
+rtsp_parse_message(char* ptcp, uint tcplen, uint* ptcpoff,
+                   uint* phdrsoff, uint* phdrslen,
+                   uint* pcseqoff, uint* pcseqlen,
+                   uint* transoff, uint* translen)
+{
+	uint    entitylen = 0;
+	uint    lineoff;
+	uint    linelen;
+
+	if (!nf_nextline(ptcp, tcplen, ptcpoff, &lineoff, &linelen))
+		return 0;
+
+	*phdrsoff = *ptcpoff;
+	while (nf_mime_nextline(ptcp, tcplen, ptcpoff, &lineoff, &linelen)) {
+		if (linelen == 0) {
+			if (entitylen > 0)
+				*ptcpoff += min(entitylen, tcplen - *ptcpoff);
+			break;
+		}
+		if (lineoff+linelen > tcplen) {
+			INFOP("!! overrun !!\n");
+			break;
+		}
+
+		if (nf_strncasecmp(ptcp+lineoff, "CSeq:", 5) == 0) {
+			*pcseqoff = lineoff;
+			*pcseqlen = linelen;
+		}
+
+		if (nf_strncasecmp(ptcp+lineoff, "Transport:", 10) == 0) {
+			*transoff = lineoff;
+			*translen = linelen;
+		}
+
+		if (nf_strncasecmp(ptcp+lineoff, "Content-Length:", 15) == 0) {
+			uint off = lineoff+15;
+			SKIP_WSPACE(ptcp+lineoff, linelen, off);
+			nf_strtou32(ptcp+off, &entitylen);
+		}
+	}
+	*phdrslen = (*ptcpoff) - (*phdrsoff);
+
+	return 1;
+}
+
+/*
+ * Find lo/hi client ports (if any) in transport header
+ * In:
+ *   ptcp, tcplen = packet
+ *   tranoff, tranlen = buffer to search
+ *
+ * Out:
+ *   pport_lo, pport_hi = lo/hi ports (host endian)
+ *
+ * Returns nonzero if any client ports found
+ *
+ * Note: it is valid (and expected) for the client to request multiple
+ * transports, so we need to parse the entire line.
+ */
+static int
+rtsp_parse_transport(char* ptran, uint tranlen,
+                     struct ip_ct_rtsp_expect* prtspexp)
+{
+	int     rc = 0;
+	uint    off = 0;
+
+	if (tranlen < 10 || !iseol(ptran[tranlen-1]) ||
+	    nf_strncasecmp(ptran, "Transport:", 10) != 0) {
+		INFOP("sanity check failed\n");
+		return 0;
+	}
+
+	DEBUGP("tran='%.*s'\n", (int)tranlen, ptran);
+	off += 10;
+	SKIP_WSPACE(ptran, tranlen, off);
+
+	/* Transport: tran;field;field=val,tran;field;field=val,... */
+	while (off < tranlen) {
+		const char* pparamend;
+		uint        nextparamoff;
+
+		pparamend = memchr(ptran+off, ',', tranlen-off);
+		pparamend = (pparamend == NULL) ? ptran+tranlen : pparamend+1;
+		nextparamoff = pparamend-ptran;
+
+		while (off < nextparamoff) {
+			const char* pfieldend;
+			uint        nextfieldoff;
+
+			pfieldend = memchr(ptran+off, ';', nextparamoff-off);
+			nextfieldoff = (pfieldend == NULL) ? nextparamoff : pfieldend-ptran+1;
+
+			if (strncmp(ptran+off, "client_port=", 12) == 0) {
+				u_int16_t   port;
+				uint        numlen;
+
+				off += 12;
+				numlen = nf_strtou16(ptran+off, &port);
+				off += numlen;
+				if (prtspexp->loport != 0 && prtspexp->loport != port)
+					DEBUGP("multiple ports found, port %hu ignored\n", port);
+				else {
+					DEBUGP("lo port found : %hu\n", port);
+					prtspexp->loport = prtspexp->hiport = port;
+					if (ptran[off] == '-') {
+						off++;
+						numlen = nf_strtou16(ptran+off, &port);
+						off += numlen;
+						prtspexp->pbtype = pb_range;
+						prtspexp->hiport = port;
+
+						// If we have a range, assume rtp:
+						// loport must be even, hiport must be loport+1
+						if ((prtspexp->loport & 0x0001) != 0 ||
+						    prtspexp->hiport != prtspexp->loport+1) {
+							DEBUGP("incorrect range: %hu-%hu, correcting\n",
+							       prtspexp->loport, prtspexp->hiport);
+							prtspexp->loport &= 0xfffe;
+							prtspexp->hiport = prtspexp->loport+1;
+						}
+					} else if (ptran[off] == '/') {
+						off++;
+						numlen = nf_strtou16(ptran+off, &port);
+						off += numlen;
+						prtspexp->pbtype = pb_discon;
+						prtspexp->hiport = port;
+					}
+					rc = 1;
+				}
+			}
+
+			/*
+			 * Note we don't look for the destination parameter here.
+			 * If we are using NAT, the NAT module will handle it.  If not,
+			 * and the client is sending packets elsewhere, the expectation
+			 * will quietly time out.
+			 */
+
+			off = nextfieldoff;
+		}
+
+		off = nextparamoff;
+	}
+
+	return rc;
+}
+
+void expected(struct nf_conn *ct, struct nf_conntrack_expect *exp)
+{
+    if(nf_nat_rtsp_hook_expectfn) {
+        nf_nat_rtsp_hook_expectfn(ct,exp);
+    }
+}
+
+/*** conntrack functions ***/
+
+/* outbound packet: client->server */
+
+static inline int
+help_out(struct sk_buff *skb, unsigned char *rb_ptr, unsigned int datalen,
+                struct nf_conn *ct, enum ip_conntrack_info ctinfo)
+{
+	struct ip_ct_rtsp_expect expinfo;
+
+	int dir = CTINFO2DIR(ctinfo);   /* = IP_CT_DIR_ORIGINAL */
+	//struct  tcphdr* tcph = (void*)iph + iph->ihl * 4;
+	//uint    tcplen = pktlen - iph->ihl * 4;
+	char*   pdata = rb_ptr;
+	//uint    datalen = tcplen - tcph->doff * 4;
+	uint    dataoff = 0;
+	int ret = NF_ACCEPT;
+
+	struct nf_conntrack_expect *exp;
+
+	__be16 be_loport;
+
+	memset(&expinfo, 0, sizeof(expinfo));
+
+	while (dataoff < datalen) {
+		uint    cmdoff = dataoff;
+		uint    hdrsoff = 0;
+		uint    hdrslen = 0;
+		uint    cseqoff = 0;
+		uint    cseqlen = 0;
+		uint    transoff = 0;
+		uint    translen = 0;
+		uint    off;
+
+		if (!rtsp_parse_message(pdata, datalen, &dataoff,
+					&hdrsoff, &hdrslen,
+					&cseqoff, &cseqlen,
+					&transoff, &translen))
+			break;      /* not a valid message */
+
+		if (strncmp(pdata+cmdoff, "SETUP ", 6) != 0)
+			continue;   /* not a SETUP message */
+		DEBUGP("found a setup message\n");
+
+		off = 0;
+		if(translen) {
+			rtsp_parse_transport(pdata+transoff, translen, &expinfo);
+		}
+
+		if (expinfo.loport == 0) {
+			DEBUGP("no udp transports found\n");
+			continue;   /* no udp transports found */
+		}
+
+		DEBUGP("udp transport found, ports=(%d,%hu,%hu)\n",
+		       (int)expinfo.pbtype, expinfo.loport, expinfo.hiport);
+
+		exp = nf_ct_expect_alloc(ct);
+		if (!exp) {
+			ret = NF_DROP;
+			goto out;
+		}
+
+		be_loport = htons(expinfo.loport);
+
+		nf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT,
+			ct->tuplehash[!dir].tuple.src.l3num,
+			&ct->tuplehash[!dir].tuple.src.u3, &ct->tuplehash[!dir].tuple.dst.u3,
+			IPPROTO_UDP, NULL, &be_loport);
+
+		exp->master = ct;
+
+		exp->expectfn = expected;
+		exp->flags = 0;
+
+		if (expinfo.pbtype == pb_range) {
+			DEBUGP("Changing expectation mask to handle multiple ports\n");
+			exp->mask.src.u.udp.port  = 0xfffe;
+		}
+
+		DEBUGP("expect_related %u.%u.%u.%u:%u-%u.%u.%u.%u:%u\n",
+		       NIPQUAD(exp->tuple.src.u3.ip),
+		       ntohs(exp->tuple.src.u.udp.port),
+		       NIPQUAD(exp->tuple.dst.u3.ip),
+		       ntohs(exp->tuple.dst.u.udp.port));
+
+		if (nf_nat_rtsp_hook)
+			/* pass the request off to the nat helper */
+			ret = nf_nat_rtsp_hook(skb, ctinfo, hdrsoff, hdrslen, &expinfo, exp);
+		else if (nf_ct_expect_related(exp) != 0) {
+			INFOP("nf_ct_expect_related failed\n");
+			ret  = NF_DROP;
+		}
+		nf_ct_expect_put(exp);
+		goto out;
+	}
+out:
+
+	return ret;
+}
+
+
+static inline int
+help_in(struct sk_buff *skb, size_t pktlen,
+ struct nf_conn* ct, enum ip_conntrack_info ctinfo)
+{
+ return NF_ACCEPT;
+}
+
+static int help(struct sk_buff *skb, unsigned int protoff,
+		struct nf_conn *ct, enum ip_conntrack_info ctinfo)
+{
+	struct tcphdr _tcph, *th;
+	unsigned int dataoff, datalen;
+	char *rb_ptr;
+	int ret = NF_DROP;
+
+	/* Until there's been traffic both ways, don't look in packets. */
+	if (ctinfo != IP_CT_ESTABLISHED &&
+	    ctinfo != IP_CT_ESTABLISHED + IP_CT_IS_REPLY) {
+		DEBUGP("conntrackinfo = %u\n", ctinfo);
+		return NF_ACCEPT;
+	}
+
+	/* Not whole TCP header? */
+	th = skb_header_pointer(skb, protoff, sizeof(_tcph), &_tcph);
+
+	if (!th)
+		return NF_ACCEPT;
+
+	/* No data ? */
+	dataoff = protoff + th->doff*4;
+	datalen = skb->len - dataoff;
+	if (dataoff >= skb->len)
+		return NF_ACCEPT;
+
+	spin_lock_bh(&rtsp_buffer_lock);
+	rb_ptr = skb_header_pointer(skb, dataoff,
+				    skb->len - dataoff, rtsp_buffer);
+	BUG_ON(rb_ptr == NULL);
+
+#if 0
+	/* Checksum invalid?  Ignore. */
+	/* FIXME: Source route IP option packets --RR */
+	if (tcp_v4_check(tcph, tcplen, iph->saddr, iph->daddr,
+			 csum_partial((char*)tcph, tcplen, 0)))
+	{
+		DEBUGP("bad csum: %p %u %u.%u.%u.%u %u.%u.%u.%u\n",
+		       tcph, tcplen, NIPQUAD(iph->saddr), NIPQUAD(iph->daddr));
+		return NF_ACCEPT;
+	}
+#endif
+
+	switch (CTINFO2DIR(ctinfo)) {
+	case IP_CT_DIR_ORIGINAL:
+		ret = help_out(skb, rb_ptr, datalen, ct, ctinfo);
+		break;
+	case IP_CT_DIR_REPLY:
+		DEBUGP("IP_CT_DIR_REPLY\n");
+		/* inbound packet: server->client */
+		ret = NF_ACCEPT;
+		break;
+	}
+
+	spin_unlock_bh(&rtsp_buffer_lock);
+
+	return ret;
+}
+
+static struct nf_conntrack_helper rtsp_helpers[MAX_PORTS];
+static char rtsp_names[MAX_PORTS][10];
+static struct nf_conntrack_expect_policy rtsp_expect_policy;
+
+/* This function is intentionally _NOT_ defined as __exit */
+static void
+fini(void)
+{
+	int i;
+	for (i = 0; i < num_ports; i++) {
+		DEBUGP("unregistering port %d\n", ports[i]);
+		nf_conntrack_helper_unregister(&rtsp_helpers[i]);
+	}
+	kfree(rtsp_buffer);
+}
+
+static int __init
+init(void)
+{
+	int i, ret;
+	struct nf_conntrack_helper *hlpr;
+	char *tmpname;
+
+	printk("nf_conntrack_rtsp v" IP_NF_RTSP_VERSION " loading\n");
+
+	if (max_outstanding < 1) {
+		printk("nf_conntrack_rtsp: max_outstanding must be a positive integer\n");
+		return -EBUSY;
+	}
+	if (setup_timeout < 0) {
+		printk("nf_conntrack_rtsp: setup_timeout must be a positive integer\n");
+		return -EBUSY;
+	}
+
+	rtsp_expect_policy.max_expected = max_outstanding;
+	rtsp_expect_policy.timeout = setup_timeout;
+
+	rtsp_buffer = kmalloc(65536, GFP_KERNEL);
+	if (!rtsp_buffer)
+		return -ENOMEM;
+
+	/* If no port given, default to standard rtsp port */
+	if (ports[0] == 0) {
+		ports[0] = RTSP_PORT;
+	}
+
+	for (i = 0; (i < MAX_PORTS) && ports[i]; i++) {
+		hlpr = &rtsp_helpers[i];
+		memset(hlpr, 0, sizeof(struct nf_conntrack_helper));
+		hlpr->tuple.src.u.tcp.port = htons(ports[i]);
+		hlpr->tuple.dst.protonum = IPPROTO_TCP;
+		hlpr->expect_policy = &rtsp_expect_policy;
+		hlpr->me = THIS_MODULE;
+		hlpr->help = help;
+
+		tmpname = &rtsp_names[i][0];
+		if (ports[i] == RTSP_PORT) {
+			sprintf(tmpname, "rtsp");
+		} else {
+			sprintf(tmpname, "rtsp-%d", i);
+		}
+		hlpr->name = tmpname;
+
+		DEBUGP("port #%d: %d\n", i, ports[i]);
+
+		ret = nf_conntrack_helper_register(hlpr);
+
+		if (ret) {
+			printk("nf_conntrack_rtsp: ERROR registering port %d\n", ports[i]);
+			fini();
+			return -EBUSY;
+		}
+		num_ports++;
+	}
+	return 0;
+}
+
+module_init(init);
+module_exit(fini);
+
+EXPORT_SYMBOL(nf_nat_rtsp_hook_expectfn);
+
diff -Nru linux-2.6.30.5/net/netfilter/nf_conntrack_standalone.c linux-2.6.30.5-wrt/net/netfilter/nf_conntrack_standalone.c
--- linux-2.6.30.5/net/netfilter/nf_conntrack_standalone.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/net/netfilter/nf_conntrack_standalone.c	2009-09-06 18:43:48.362668493 +0200
@@ -171,6 +171,12 @@
 		goto release;
 #endif
 
+#if defined(CONFIG_NETFILTER_XT_MATCH_LAYER7) || defined(CONFIG_NETFILTER_XT_MATCH_LAYER7_MODULE)
+	if(ct->layer7.app_proto &&
+           seq_printf(s, "l7proto=%s ", ct->layer7.app_proto))
+		return -ENOSPC;
+#endif
+
 	if (seq_printf(s, "use=%u\n", atomic_read(&ct->ct_general.use)))
 		goto release;
 
diff -Nru linux-2.6.30.5/net/netfilter/nf_queue.c linux-2.6.30.5-wrt/net/netfilter/nf_queue.c
--- linux-2.6.30.5/net/netfilter/nf_queue.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/net/netfilter/nf_queue.c	2009-09-06 18:43:48.390666560 +0200
@@ -20,6 +20,26 @@
 
 static DEFINE_MUTEX(queue_handler_mutex);
 
+#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
+static const struct nf_queue_handler *queue_imq_handler;
+
+void nf_register_queue_imq_handler(const struct nf_queue_handler *qh)
+{
+	mutex_lock(&queue_handler_mutex);
+	rcu_assign_pointer(queue_imq_handler, qh);
+	mutex_unlock(&queue_handler_mutex);
+}
+EXPORT_SYMBOL(nf_register_queue_imq_handler);
+
+void nf_unregister_queue_imq_handler(void)
+{
+	mutex_lock(&queue_handler_mutex);
+	rcu_assign_pointer(queue_imq_handler, NULL);
+	mutex_unlock(&queue_handler_mutex);
+}
+EXPORT_SYMBOL(nf_unregister_queue_imq_handler);
+#endif
+
 /* return EBUSY when somebody else is registered, return EEXIST if the
  * same handler is registered, return 0 in case of success. */
 int nf_register_queue_handler(u_int8_t pf, const struct nf_queue_handler *qh)
@@ -80,7 +100,7 @@
 }
 EXPORT_SYMBOL_GPL(nf_unregister_queue_handlers);
 
-static void nf_queue_entry_release_refs(struct nf_queue_entry *entry)
+void nf_queue_entry_release_refs(struct nf_queue_entry *entry)
 {
 	/* Release those devices we held, or Alexey will kill me. */
 	if (entry->indev)
@@ -100,6 +120,7 @@
 	/* Drop reference to owner of hook which queued us. */
 	module_put(entry->elem->owner);
 }
+EXPORT_SYMBOL_GPL(nf_queue_entry_release_refs);
 
 /*
  * Any packet that leaves via this function must come back
@@ -121,12 +142,26 @@
 #endif
 	const struct nf_afinfo *afinfo;
 	const struct nf_queue_handler *qh;
+#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
+	const struct nf_queue_handler *qih = NULL;
+#endif
 
 	/* QUEUE == DROP if noone is waiting, to be safe. */
 	rcu_read_lock();
 
 	qh = rcu_dereference(queue_handler[pf]);
+#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+	if (pf == PF_INET || pf == PF_INET6)
+#else
+	if (pf == PF_INET)
+#endif
+		qih = rcu_dereference(queue_imq_handler);
+
+	if (!qh && !qih)
+#else /* !IMQ */
 	if (!qh)
+#endif
 		goto err_unlock;
 
 	afinfo = nf_get_afinfo(pf);
@@ -145,6 +180,10 @@
 		.indev	= indev,
 		.outdev	= outdev,
 		.okfn	= okfn,
+#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
+		.next_outfn = qh ? qh->outfn : NULL,
+		.next_queuenum = queuenum,
+#endif
 	};
 
 	/* If it's going away, ignore hook. */
@@ -170,8 +209,19 @@
 	}
 #endif
 	afinfo->saveroute(skb, entry);
+
+#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
+	if (qih) {
+		status = qih->outfn(entry, queuenum);
+		goto imq_skip_queue;
+	}
+#endif
+
 	status = qh->outfn(entry, queuenum);
 
+#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
+imq_skip_queue:
+#endif
 	rcu_read_unlock();
 
 	if (status < 0) {
diff -Nru linux-2.6.30.5/net/netfilter/regexp/regexp.c linux-2.6.30.5-wrt/net/netfilter/regexp/regexp.c
--- linux-2.6.30.5/net/netfilter/regexp/regexp.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/net/netfilter/regexp/regexp.c	2009-09-06 18:43:48.366668750 +0200
@@ -0,0 +1,1197 @@
+/*
+ * regcomp and regexec -- regsub and regerror are elsewhere
+ * @(#)regexp.c	1.3 of 18 April 87
+ *
+ *	Copyright (c) 1986 by University of Toronto.
+ *	Written by Henry Spencer.  Not derived from licensed software.
+ *
+ *	Permission is granted to anyone to use this software for any
+ *	purpose on any computer system, and to redistribute it freely,
+ *	subject to the following restrictions:
+ *
+ *	1. The author is not responsible for the consequences of use of
+ *		this software, no matter how awful, even if they arise
+ *		from defects in it.
+ *
+ *	2. The origin of this software must not be misrepresented, either
+ *		by explicit claim or by omission.
+ *
+ *	3. Altered versions must be plainly marked as such, and must not
+ *		be misrepresented as being the original software.
+ *
+ * Beware that some of this code is subtly aware of the way operator
+ * precedence is structured in regular expressions.  Serious changes in
+ * regular-expression syntax might require a total rethink.
+ *
+ * This code was modified by Ethan Sommer to work within the kernel
+ * (it now uses kmalloc etc..)
+ *
+ * Modified slightly by Matthew Strait to use more modern C.
+ */
+
+#include "regexp.h"
+#include "regmagic.h"
+
+/* added by ethan and matt.  Lets it work in both kernel and user space.
+(So iptables can use it, for instance.)  Yea, it goes both ways... */
+#if __KERNEL__
+  #define malloc(foo) kmalloc(foo,GFP_ATOMIC)
+#else
+  #define printk(format,args...) printf(format,##args)
+#endif
+
+void regerror(char * s)
+{
+        printk("<3>Regexp: %s\n", s);
+        /* NOTREACHED */
+}
+
+/*
+ * The "internal use only" fields in regexp.h are present to pass info from
+ * compile to execute that permits the execute phase to run lots faster on
+ * simple cases.  They are:
+ *
+ * regstart	char that must begin a match; '\0' if none obvious
+ * reganch	is the match anchored (at beginning-of-line only)?
+ * regmust	string (pointer into program) that match must include, or NULL
+ * regmlen	length of regmust string
+ *
+ * Regstart and reganch permit very fast decisions on suitable starting points
+ * for a match, cutting down the work a lot.  Regmust permits fast rejection
+ * of lines that cannot possibly match.  The regmust tests are costly enough
+ * that regcomp() supplies a regmust only if the r.e. contains something
+ * potentially expensive (at present, the only such thing detected is * or +
+ * at the start of the r.e., which can involve a lot of backup).  Regmlen is
+ * supplied because the test in regexec() needs it and regcomp() is computing
+ * it anyway.
+ */
+
+/*
+ * Structure for regexp "program".  This is essentially a linear encoding
+ * of a nondeterministic finite-state machine (aka syntax charts or
+ * "railroad normal form" in parsing technology).  Each node is an opcode
+ * plus a "next" pointer, possibly plus an operand.  "Next" pointers of
+ * all nodes except BRANCH implement concatenation; a "next" pointer with
+ * a BRANCH on both ends of it is connecting two alternatives.  (Here we
+ * have one of the subtle syntax dependencies:  an individual BRANCH (as
+ * opposed to a collection of them) is never concatenated with anything
+ * because of operator precedence.)  The operand of some types of node is
+ * a literal string; for others, it is a node leading into a sub-FSM.  In
+ * particular, the operand of a BRANCH node is the first node of the branch.
+ * (NB this is *not* a tree structure:  the tail of the branch connects
+ * to the thing following the set of BRANCHes.)  The opcodes are:
+ */
+
+/* definition	number	opnd?	meaning */
+#define	END	0	/* no	End of program. */
+#define	BOL	1	/* no	Match "" at beginning of line. */
+#define	EOL	2	/* no	Match "" at end of line. */
+#define	ANY	3	/* no	Match any one character. */
+#define	ANYOF	4	/* str	Match any character in this string. */
+#define	ANYBUT	5	/* str	Match any character not in this string. */
+#define	BRANCH	6	/* node	Match this alternative, or the next... */
+#define	BACK	7	/* no	Match "", "next" ptr points backward. */
+#define	EXACTLY	8	/* str	Match this string. */
+#define	NOTHING	9	/* no	Match empty string. */
+#define	STAR	10	/* node	Match this (simple) thing 0 or more times. */
+#define	PLUS	11	/* node	Match this (simple) thing 1 or more times. */
+#define	OPEN	20	/* no	Mark this point in input as start of #n. */
+			/*	OPEN+1 is number 1, etc. */
+#define	CLOSE	30	/* no	Analogous to OPEN. */
+
+/*
+ * Opcode notes:
+ *
+ * BRANCH	The set of branches constituting a single choice are hooked
+ *		together with their "next" pointers, since precedence prevents
+ *		anything being concatenated to any individual branch.  The
+ *		"next" pointer of the last BRANCH in a choice points to the
+ *		thing following the whole choice.  This is also where the
+ *		final "next" pointer of each individual branch points; each
+ *		branch starts with the operand node of a BRANCH node.
+ *
+ * BACK		Normal "next" pointers all implicitly point forward; BACK
+ *		exists to make loop structures possible.
+ *
+ * STAR,PLUS	'?', and complex '*' and '+', are implemented as circular
+ *		BRANCH structures using BACK.  Simple cases (one character
+ *		per match) are implemented with STAR and PLUS for speed
+ *		and to minimize recursive plunges.
+ *
+ * OPEN,CLOSE	...are numbered at compile time.
+ */
+
+/*
+ * A node is one char of opcode followed by two chars of "next" pointer.
+ * "Next" pointers are stored as two 8-bit pieces, high order first.  The
+ * value is a positive offset from the opcode of the node containing it.
+ * An operand, if any, simply follows the node.  (Note that much of the
+ * code generation knows about this implicit relationship.)
+ *
+ * Using two bytes for the "next" pointer is vast overkill for most things,
+ * but allows patterns to get big without disasters.
+ */
+#define	OP(p)	(*(p))
+#define	NEXT(p)	(((*((p)+1)&0377)<<8) + (*((p)+2)&0377))
+#define	OPERAND(p)	((p) + 3)
+
+/*
+ * See regmagic.h for one further detail of program structure.
+ */
+
+
+/*
+ * Utility definitions.
+ */
+#ifndef CHARBITS
+#define	UCHARAT(p)	((int)*(unsigned char *)(p))
+#else
+#define	UCHARAT(p)	((int)*(p)&CHARBITS)
+#endif
+
+#define	FAIL(m)	{ regerror(m); return(NULL); }
+#define	ISMULT(c)	((c) == '*' || (c) == '+' || (c) == '?')
+#define	META	"^$.[()|?+*\\"
+
+/*
+ * Flags to be passed up and down.
+ */
+#define	HASWIDTH	01	/* Known never to match null string. */
+#define	SIMPLE		02	/* Simple enough to be STAR/PLUS operand. */
+#define	SPSTART		04	/* Starts with * or +. */
+#define	WORST		0	/* Worst case. */
+
+/*
+ * Global work variables for regcomp().
+ */
+struct match_globals {
+char *reginput;		/* String-input pointer. */
+char *regbol;		/* Beginning of input, for ^ check. */
+char **regstartp;	/* Pointer to startp array. */
+char **regendp;		/* Ditto for endp. */
+char *regparse;		/* Input-scan pointer. */
+int regnpar;		/* () count. */
+char regdummy;
+char *regcode;		/* Code-emit pointer; &regdummy = don't. */
+long regsize;		/* Code size. */
+};
+
+/*
+ * Forward declarations for regcomp()'s friends.
+ */
+#ifndef STATIC
+#define	STATIC	static
+#endif
+STATIC char *reg(struct match_globals *g, int paren,int *flagp);
+STATIC char *regbranch(struct match_globals *g, int *flagp);
+STATIC char *regpiece(struct match_globals *g, int *flagp);
+STATIC char *regatom(struct match_globals *g, int *flagp);
+STATIC char *regnode(struct match_globals *g, char op);
+STATIC char *regnext(struct match_globals *g, char *p);
+STATIC void regc(struct match_globals *g, char b);
+STATIC void reginsert(struct match_globals *g, char op, char *opnd);
+STATIC void regtail(struct match_globals *g, char *p, char *val);
+STATIC void regoptail(struct match_globals *g, char *p, char *val);
+
+
+__kernel_size_t my_strcspn(const char *s1,const char *s2)
+{
+        char *scan1;
+        char *scan2;
+        int count;
+
+        count = 0;
+        for (scan1 = (char *)s1; *scan1 != '\0'; scan1++) {
+                for (scan2 = (char *)s2; *scan2 != '\0';)       /* ++ moved down. */
+                        if (*scan1 == *scan2++)
+                                return(count);
+                count++;
+        }
+        return(count);
+}
+
+/*
+ - regcomp - compile a regular expression into internal code
+ *
+ * We can't allocate space until we know how big the compiled form will be,
+ * but we can't compile it (and thus know how big it is) until we've got a
+ * place to put the code.  So we cheat:  we compile it twice, once with code
+ * generation turned off and size counting turned on, and once "for real".
+ * This also means that we don't allocate space until we are sure that the
+ * thing really will compile successfully, and we never have to move the
+ * code and thus invalidate pointers into it.  (Note that it has to be in
+ * one piece because free() must be able to free it all.)
+ *
+ * Beware that the optimization-preparation code in here knows about some
+ * of the structure of the compiled regexp.
+ */
+regexp *
+regcomp(char *exp,int *patternsize)
+{
+	register regexp *r;
+	register char *scan;
+	register char *longest;
+	register int len;
+	int flags;
+	struct match_globals g;
+	
+	/* commented out by ethan
+	   extern char *malloc();
+	*/
+
+	if (exp == NULL)
+		FAIL("NULL argument");
+
+	/* First pass: determine size, legality. */
+	g.regparse = exp;
+	g.regnpar = 1;
+	g.regsize = 0L;
+	g.regcode = &g.regdummy;
+	regc(&g, MAGIC);
+	if (reg(&g, 0, &flags) == NULL)
+		return(NULL);
+
+	/* Small enough for pointer-storage convention? */
+	if (g.regsize >= 32767L)		/* Probably could be 65535L. */
+		FAIL("regexp too big");
+
+	/* Allocate space. */
+	*patternsize=sizeof(regexp) + (unsigned)g.regsize;
+	r = (regexp *)malloc(sizeof(regexp) + (unsigned)g.regsize);
+	if (r == NULL)
+		FAIL("out of space");
+
+	/* Second pass: emit code. */
+	g.regparse = exp;
+	g.regnpar = 1;
+	g.regcode = r->program;
+	regc(&g, MAGIC);
+	if (reg(&g, 0, &flags) == NULL)
+		return(NULL);
+
+	/* Dig out information for optimizations. */
+	r->regstart = '\0';	/* Worst-case defaults. */
+	r->reganch = 0;
+	r->regmust = NULL;
+	r->regmlen = 0;
+	scan = r->program+1;			/* First BRANCH. */
+	if (OP(regnext(&g, scan)) == END) {		/* Only one top-level choice. */
+		scan = OPERAND(scan);
+
+		/* Starting-point info. */
+		if (OP(scan) == EXACTLY)
+			r->regstart = *OPERAND(scan);
+		else if (OP(scan) == BOL)
+			r->reganch++;
+
+		/*
+		 * If there's something expensive in the r.e., find the
+		 * longest literal string that must appear and make it the
+		 * regmust.  Resolve ties in favor of later strings, since
+		 * the regstart check works with the beginning of the r.e.
+		 * and avoiding duplication strengthens checking.  Not a
+		 * strong reason, but sufficient in the absence of others.
+		 */
+		if (flags&SPSTART) {
+			longest = NULL;
+			len = 0;
+			for (; scan != NULL; scan = regnext(&g, scan))
+				if (OP(scan) == EXACTLY && strlen(OPERAND(scan)) >= len) {
+					longest = OPERAND(scan);
+					len = strlen(OPERAND(scan));
+				}
+			r->regmust = longest;
+			r->regmlen = len;
+		}
+	}
+
+	return(r);
+}
+
+/*
+ - reg - regular expression, i.e. main body or parenthesized thing
+ *
+ * Caller must absorb opening parenthesis.
+ *
+ * Combining parenthesis handling with the base level of regular expression
+ * is a trifle forced, but the need to tie the tails of the branches to what
+ * follows makes it hard to avoid.
+ */
+static char *
+reg(struct match_globals *g, int paren, int *flagp /* Parenthesized? */ )
+{
+	register char *ret;
+	register char *br;
+	register char *ender;
+	register int parno = 0; /* 0 makes gcc happy */
+	int flags;
+
+	*flagp = HASWIDTH;	/* Tentatively. */
+
+	/* Make an OPEN node, if parenthesized. */
+	if (paren) {
+		if (g->regnpar >= NSUBEXP)
+			FAIL("too many ()");
+		parno = g->regnpar;
+		g->regnpar++;
+		ret = regnode(g, OPEN+parno);
+	} else
+		ret = NULL;
+
+	/* Pick up the branches, linking them together. */
+	br = regbranch(g, &flags);
+	if (br == NULL)
+		return(NULL);
+	if (ret != NULL)
+		regtail(g, ret, br);	/* OPEN -> first. */
+	else
+		ret = br;
+	if (!(flags&HASWIDTH))
+		*flagp &= ~HASWIDTH;
+	*flagp |= flags&SPSTART;
+	while (*g->regparse == '|') {
+		g->regparse++;
+		br = regbranch(g, &flags);
+		if (br == NULL)
+			return(NULL);
+		regtail(g, ret, br);	/* BRANCH -> BRANCH. */
+		if (!(flags&HASWIDTH))
+			*flagp &= ~HASWIDTH;
+		*flagp |= flags&SPSTART;
+	}
+
+	/* Make a closing node, and hook it on the end. */
+	ender = regnode(g, (paren) ? CLOSE+parno : END);	
+	regtail(g, ret, ender);
+
+	/* Hook the tails of the branches to the closing node. */
+	for (br = ret; br != NULL; br = regnext(g, br))
+		regoptail(g, br, ender);
+
+	/* Check for proper termination. */
+	if (paren && *g->regparse++ != ')') {
+		FAIL("unmatched ()");
+	} else if (!paren && *g->regparse != '\0') {
+		if (*g->regparse == ')') {
+			FAIL("unmatched ()");
+		} else
+			FAIL("junk on end");	/* "Can't happen". */
+		/* NOTREACHED */
+	}
+
+	return(ret);
+}
+
+/*
+ - regbranch - one alternative of an | operator
+ *
+ * Implements the concatenation operator.
+ */
+static char *
+regbranch(struct match_globals *g, int *flagp)
+{
+	register char *ret;
+	register char *chain;
+	register char *latest;
+	int flags;
+
+	*flagp = WORST;		/* Tentatively. */
+
+	ret = regnode(g, BRANCH);
+	chain = NULL;
+	while (*g->regparse != '\0' && *g->regparse != '|' && *g->regparse != ')') {
+		latest = regpiece(g, &flags);
+		if (latest == NULL)
+			return(NULL);
+		*flagp |= flags&HASWIDTH;
+		if (chain == NULL)	/* First piece. */
+			*flagp |= flags&SPSTART;
+		else
+			regtail(g, chain, latest);
+		chain = latest;
+	}
+	if (chain == NULL)	/* Loop ran zero times. */
+		(void) regnode(g, NOTHING);
+
+	return(ret);
+}
+
+/*
+ - regpiece - something followed by possible [*+?]
+ *
+ * Note that the branching code sequences used for ? and the general cases
+ * of * and + are somewhat optimized:  they use the same NOTHING node as
+ * both the endmarker for their branch list and the body of the last branch.
+ * It might seem that this node could be dispensed with entirely, but the
+ * endmarker role is not redundant.
+ */
+static char *
+regpiece(struct match_globals *g, int *flagp)
+{
+	register char *ret;
+	register char op;
+	register char *next;
+	int flags;
+
+	ret = regatom(g, &flags);
+	if (ret == NULL)
+		return(NULL);
+
+	op = *g->regparse;
+	if (!ISMULT(op)) {
+		*flagp = flags;
+		return(ret);
+	}
+
+	if (!(flags&HASWIDTH) && op != '?')
+		FAIL("*+ operand could be empty");
+	*flagp = (op != '+') ? (WORST|SPSTART) : (WORST|HASWIDTH);
+
+	if (op == '*' && (flags&SIMPLE))
+		reginsert(g, STAR, ret);
+	else if (op == '*') {
+		/* Emit x* as (x&|), where & means "self". */
+		reginsert(g, BRANCH, ret);			/* Either x */
+		regoptail(g, ret, regnode(g, BACK));		/* and loop */
+		regoptail(g, ret, ret);			/* back */
+		regtail(g, ret, regnode(g, BRANCH));		/* or */
+		regtail(g, ret, regnode(g, NOTHING));		/* null. */
+	} else if (op == '+' && (flags&SIMPLE))
+		reginsert(g, PLUS, ret);
+	else if (op == '+') {
+		/* Emit x+ as x(&|), where & means "self". */
+		next = regnode(g, BRANCH);			/* Either */
+		regtail(g, ret, next);
+		regtail(g, regnode(g, BACK), ret);		/* loop back */
+		regtail(g, next, regnode(g, BRANCH));		/* or */
+		regtail(g, ret, regnode(g, NOTHING));		/* null. */
+	} else if (op == '?') {
+		/* Emit x? as (x|) */
+		reginsert(g, BRANCH, ret);			/* Either x */
+		regtail(g, ret, regnode(g, BRANCH));		/* or */
+		next = regnode(g, NOTHING);		/* null. */
+		regtail(g, ret, next);
+		regoptail(g, ret, next);
+	}
+	g->regparse++;
+	if (ISMULT(*g->regparse))
+		FAIL("nested *?+");
+
+	return(ret);
+}
+
+/*
+ - regatom - the lowest level
+ *
+ * Optimization:  gobbles an entire sequence of ordinary characters so that
+ * it can turn them into a single node, which is smaller to store and
+ * faster to run.  Backslashed characters are exceptions, each becoming a
+ * separate node; the code is simpler that way and it's not worth fixing.
+ */
+static char *
+regatom(struct match_globals *g, int *flagp)
+{
+	register char *ret;
+	int flags;
+
+	*flagp = WORST;		/* Tentatively. */
+
+	switch (*g->regparse++) {
+	case '^':
+		ret = regnode(g, BOL);
+		break;
+	case '$':
+		ret = regnode(g, EOL);
+		break;
+	case '.':
+		ret = regnode(g, ANY);
+		*flagp |= HASWIDTH|SIMPLE;
+		break;
+	case '[': {
+			register int class;
+			register int classend;
+
+			if (*g->regparse == '^') {	/* Complement of range. */
+				ret = regnode(g, ANYBUT);
+				g->regparse++;
+			} else
+				ret = regnode(g, ANYOF);
+			if (*g->regparse == ']' || *g->regparse == '-')
+				regc(g, *g->regparse++);
+			while (*g->regparse != '\0' && *g->regparse != ']') {
+				if (*g->regparse == '-') {
+					g->regparse++;
+					if (*g->regparse == ']' || *g->regparse == '\0')
+						regc(g, '-');
+					else {
+						class = UCHARAT(g->regparse-2)+1;
+						classend = UCHARAT(g->regparse);
+						if (class > classend+1)
+							FAIL("invalid [] range");
+						for (; class <= classend; class++)
+							regc(g, class);
+						g->regparse++;
+					}
+				} else
+					regc(g, *g->regparse++);
+			}
+			regc(g, '\0');
+			if (*g->regparse != ']')
+				FAIL("unmatched []");
+			g->regparse++;
+			*flagp |= HASWIDTH|SIMPLE;
+		}
+		break;
+	case '(':
+		ret = reg(g, 1, &flags);
+		if (ret == NULL)
+			return(NULL);
+		*flagp |= flags&(HASWIDTH|SPSTART);
+		break;
+	case '\0':
+	case '|':
+	case ')':
+		FAIL("internal urp");	/* Supposed to be caught earlier. */
+		break;
+	case '?':
+	case '+':
+	case '*':
+		FAIL("?+* follows nothing");
+		break;
+	case '\\':
+		if (*g->regparse == '\0')
+			FAIL("trailing \\");
+		ret = regnode(g, EXACTLY);
+		regc(g, *g->regparse++);
+		regc(g, '\0');
+		*flagp |= HASWIDTH|SIMPLE;
+		break;
+	default: {
+			register int len;
+			register char ender;
+
+			g->regparse--;
+			len = my_strcspn((const char *)g->regparse, (const char *)META);
+			if (len <= 0)
+				FAIL("internal disaster");
+			ender = *(g->regparse+len);
+			if (len > 1 && ISMULT(ender))
+				len--;		/* Back off clear of ?+* operand. */
+			*flagp |= HASWIDTH;
+			if (len == 1)
+				*flagp |= SIMPLE;
+			ret = regnode(g, EXACTLY);
+			while (len > 0) {
+				regc(g, *g->regparse++);
+				len--;
+			}
+			regc(g, '\0');
+		}
+		break;
+	}
+
+	return(ret);
+}
+
+/*
+ - regnode - emit a node
+ */
+static char *			/* Location. */
+regnode(struct match_globals *g, char op)
+{
+	register char *ret;
+	register char *ptr;
+
+	ret = g->regcode;
+	if (ret == &g->regdummy) {
+		g->regsize += 3;
+		return(ret);
+	}
+
+	ptr = ret;
+	*ptr++ = op;
+	*ptr++ = '\0';		/* Null "next" pointer. */
+	*ptr++ = '\0';
+	g->regcode = ptr;
+
+	return(ret);
+}
+
+/*
+ - regc - emit (if appropriate) a byte of code
+ */
+static void
+regc(struct match_globals *g, char b)
+{
+	if (g->regcode != &g->regdummy)
+		*g->regcode++ = b;
+	else
+		g->regsize++;
+}
+
+/*
+ - reginsert - insert an operator in front of already-emitted operand
+ *
+ * Means relocating the operand.
+ */
+static void
+reginsert(struct match_globals *g, char op, char* opnd)
+{
+	register char *src;
+	register char *dst;
+	register char *place;
+
+	if (g->regcode == &g->regdummy) {
+		g->regsize += 3;
+		return;
+	}
+
+	src = g->regcode;
+	g->regcode += 3;
+	dst = g->regcode;
+	while (src > opnd)
+		*--dst = *--src;
+
+	place = opnd;		/* Op node, where operand used to be. */
+	*place++ = op;
+	*place++ = '\0';
+	*place++ = '\0';
+}
+
+/*
+ - regtail - set the next-pointer at the end of a node chain
+ */
+static void
+regtail(struct match_globals *g, char *p, char *val)
+{
+	register char *scan;
+	register char *temp;
+	register int offset;
+
+	if (p == &g->regdummy)
+		return;
+
+	/* Find last node. */
+	scan = p;
+	for (;;) {
+		temp = regnext(g, scan);
+		if (temp == NULL)
+			break;
+		scan = temp;
+	}
+
+	if (OP(scan) == BACK)
+		offset = scan - val;
+	else
+		offset = val - scan;
+	*(scan+1) = (offset>>8)&0377;
+	*(scan+2) = offset&0377;
+}
+
+/*
+ - regoptail - regtail on operand of first argument; nop if operandless
+ */
+static void
+regoptail(struct match_globals *g, char *p, char *val)
+{
+	/* "Operandless" and "op != BRANCH" are synonymous in practice. */
+	if (p == NULL || p == &g->regdummy || OP(p) != BRANCH)
+		return;
+	regtail(g, OPERAND(p), val);
+}
+
+/*
+ * regexec and friends
+ */
+
+
+/*
+ * Forwards.
+ */
+STATIC int regtry(struct match_globals *g, regexp *prog, char *string);
+STATIC int regmatch(struct match_globals *g, char *prog);
+STATIC int regrepeat(struct match_globals *g, char *p);
+
+#ifdef DEBUG
+int regnarrate = 0;
+void regdump();
+STATIC char *regprop(char *op);
+#endif
+
+/*
+ - regexec - match a regexp against a string
+ */
+int
+regexec(regexp *prog, char *string)
+{
+	register char *s;
+	struct match_globals g;
+
+	/* Be paranoid... */
+	if (prog == NULL || string == NULL) {
+		printk("<3>Regexp: NULL parameter\n");
+		return(0);
+	}
+
+	/* Check validity of program. */
+	if (UCHARAT(prog->program) != MAGIC) {
+		printk("<3>Regexp: corrupted program\n");
+		return(0);
+	}
+
+	/* If there is a "must appear" string, look for it. */
+	if (prog->regmust != NULL) {
+		s = string;
+		while ((s = strchr(s, prog->regmust[0])) != NULL) {
+			if (strncmp(s, prog->regmust, prog->regmlen) == 0)
+				break;	/* Found it. */
+			s++;
+		}
+		if (s == NULL)	/* Not present. */
+			return(0);
+	}
+
+	/* Mark beginning of line for ^ . */
+	g.regbol = string;
+
+	/* Simplest case:  anchored match need be tried only once. */
+	if (prog->reganch)
+		return(regtry(&g, prog, string));
+
+	/* Messy cases:  unanchored match. */
+	s = string;
+	if (prog->regstart != '\0')
+		/* We know what char it must start with. */
+		while ((s = strchr(s, prog->regstart)) != NULL) {
+			if (regtry(&g, prog, s))
+				return(1);
+			s++;
+		}
+	else
+		/* We don't -- general case. */
+		do {
+			if (regtry(&g, prog, s))
+				return(1);
+		} while (*s++ != '\0');
+
+	/* Failure. */
+	return(0);
+}
+
+/*
+ - regtry - try match at specific point
+ */
+static int			/* 0 failure, 1 success */
+regtry(struct match_globals *g, regexp *prog, char *string)
+{
+	register int i;
+	register char **sp;
+	register char **ep;
+
+	g->reginput = string;
+	g->regstartp = prog->startp;
+	g->regendp = prog->endp;
+
+	sp = prog->startp;
+	ep = prog->endp;
+	for (i = NSUBEXP; i > 0; i--) {
+		*sp++ = NULL;
+		*ep++ = NULL;
+	}
+	if (regmatch(g, prog->program + 1)) {
+		prog->startp[0] = string;
+		prog->endp[0] = g->reginput;
+		return(1);
+	} else
+		return(0);
+}
+
+/*
+ - regmatch - main matching routine
+ *
+ * Conceptually the strategy is simple:  check to see whether the current
+ * node matches, call self recursively to see whether the rest matches,
+ * and then act accordingly.  In practice we make some effort to avoid
+ * recursion, in particular by going through "ordinary" nodes (that don't
+ * need to know whether the rest of the match failed) by a loop instead of
+ * by recursion.
+ */
+static int			/* 0 failure, 1 success */
+regmatch(struct match_globals *g, char *prog)
+{
+	register char *scan = prog; /* Current node. */
+	char *next;		    /* Next node. */
+
+#ifdef DEBUG
+	if (scan != NULL && regnarrate)
+		fprintf(stderr, "%s(\n", regprop(scan));
+#endif
+	while (scan != NULL) {
+#ifdef DEBUG
+		if (regnarrate)
+			fprintf(stderr, "%s...\n", regprop(scan));
+#endif
+		next = regnext(g, scan);
+
+		switch (OP(scan)) {
+		case BOL:
+			if (g->reginput != g->regbol)
+				return(0);
+			break;
+		case EOL:
+			if (*g->reginput != '\0')
+				return(0);
+			break;
+		case ANY:
+			if (*g->reginput == '\0')
+				return(0);
+			g->reginput++;
+			break;
+		case EXACTLY: {
+				register int len;
+				register char *opnd;
+
+				opnd = OPERAND(scan);
+				/* Inline the first character, for speed. */
+				if (*opnd != *g->reginput)
+					return(0);
+				len = strlen(opnd);
+				if (len > 1 && strncmp(opnd, g->reginput, len) != 0)
+					return(0);
+				g->reginput += len;
+			}
+			break;
+		case ANYOF:
+			if (*g->reginput == '\0' || strchr(OPERAND(scan), *g->reginput) == NULL)
+				return(0);
+			g->reginput++;
+			break;
+		case ANYBUT:
+			if (*g->reginput == '\0' || strchr(OPERAND(scan), *g->reginput) != NULL)
+				return(0);
+			g->reginput++;
+			break;
+		case NOTHING:
+		case BACK:
+			break;
+		case OPEN+1:
+		case OPEN+2:
+		case OPEN+3:
+		case OPEN+4:
+		case OPEN+5:
+		case OPEN+6:
+		case OPEN+7:
+		case OPEN+8:
+		case OPEN+9: {
+				register int no;
+				register char *save;
+
+				no = OP(scan) - OPEN;
+				save = g->reginput;
+
+				if (regmatch(g, next)) {
+					/*
+					 * Don't set startp if some later
+					 * invocation of the same parentheses
+					 * already has.
+					 */
+					if (g->regstartp[no] == NULL)
+						g->regstartp[no] = save;
+					return(1);
+				} else
+					return(0);
+			}
+			break;
+		case CLOSE+1:
+		case CLOSE+2:
+		case CLOSE+3:
+		case CLOSE+4:
+		case CLOSE+5:
+		case CLOSE+6:
+		case CLOSE+7:
+		case CLOSE+8:
+		case CLOSE+9:
+			{
+				register int no;
+				register char *save;
+
+				no = OP(scan) - CLOSE;
+				save = g->reginput;
+
+				if (regmatch(g, next)) {
+					/*
+					 * Don't set endp if some later
+					 * invocation of the same parentheses
+					 * already has.
+					 */
+					if (g->regendp[no] == NULL)
+						g->regendp[no] = save;
+					return(1);
+				} else
+					return(0);
+			}
+			break;
+		case BRANCH: {
+				register char *save;
+
+				if (OP(next) != BRANCH)		/* No choice. */
+					next = OPERAND(scan);	/* Avoid recursion. */
+				else {
+					do {
+						save = g->reginput;
+						if (regmatch(g, OPERAND(scan)))
+							return(1);
+						g->reginput = save;
+						scan = regnext(g, scan);
+					} while (scan != NULL && OP(scan) == BRANCH);
+					return(0);
+					/* NOTREACHED */
+				}
+			}
+			break;
+		case STAR:
+		case PLUS: {
+				register char nextch;
+				register int no;
+				register char *save;
+				register int min;
+
+				/*
+				 * Lookahead to avoid useless match attempts
+				 * when we know what character comes next.
+				 */
+				nextch = '\0';
+				if (OP(next) == EXACTLY)
+					nextch = *OPERAND(next);
+				min = (OP(scan) == STAR) ? 0 : 1;
+				save = g->reginput;
+				no = regrepeat(g, OPERAND(scan));
+				while (no >= min) {
+					/* If it could work, try it. */
+					if (nextch == '\0' || *g->reginput == nextch)
+						if (regmatch(g, next))
+							return(1);
+					/* Couldn't or didn't -- back up. */
+					no--;
+					g->reginput = save + no;
+				}
+				return(0);
+			}
+			break;
+		case END:
+			return(1);	/* Success! */
+			break;
+		default:
+			printk("<3>Regexp: memory corruption\n");
+			return(0);
+			break;
+		}
+
+		scan = next;
+	}
+
+	/*
+	 * We get here only if there's trouble -- normally "case END" is
+	 * the terminating point.
+	 */
+	printk("<3>Regexp: corrupted pointers\n");
+	return(0);
+}
+
+/*
+ - regrepeat - repeatedly match something simple, report how many
+ */
+static int
+regrepeat(struct match_globals *g, char *p)
+{
+	register int count = 0;
+	register char *scan;
+	register char *opnd;
+
+	scan = g->reginput;
+	opnd = OPERAND(p);
+	switch (OP(p)) {
+	case ANY:
+		count = strlen(scan);
+		scan += count;
+		break;
+	case EXACTLY:
+		while (*opnd == *scan) {
+			count++;
+			scan++;
+		}
+		break;
+	case ANYOF:
+		while (*scan != '\0' && strchr(opnd, *scan) != NULL) {
+			count++;
+			scan++;
+		}
+		break;
+	case ANYBUT:
+		while (*scan != '\0' && strchr(opnd, *scan) == NULL) {
+			count++;
+			scan++;
+		}
+		break;
+	default:		/* Oh dear.  Called inappropriately. */
+		printk("<3>Regexp: internal foulup\n");
+		count = 0;	/* Best compromise. */
+		break;
+	}
+	g->reginput = scan;
+
+	return(count);
+}
+
+/*
+ - regnext - dig the "next" pointer out of a node
+ */
+static char*
+regnext(struct match_globals *g, char *p)
+{
+	register int offset;
+
+	if (p == &g->regdummy)
+		return(NULL);
+
+	offset = NEXT(p);
+	if (offset == 0)
+		return(NULL);
+
+	if (OP(p) == BACK)
+		return(p-offset);
+	else
+		return(p+offset);
+}
+
+#ifdef DEBUG
+
+STATIC char *regprop();
+
+/*
+ - regdump - dump a regexp onto stdout in vaguely comprehensible form
+ */
+void
+regdump(regexp *r)
+{
+	register char *s;
+	register char op = EXACTLY;	/* Arbitrary non-END op. */
+	register char *next;
+	/* extern char *strchr(); */
+
+
+	s = r->program + 1;
+	while (op != END) {	/* While that wasn't END last time... */
+		op = OP(s);
+		printf("%2d%s", s-r->program, regprop(s));	/* Where, what. */
+		next = regnext(s);
+		if (next == NULL)		/* Next ptr. */
+			printf("(0)");
+		else
+			printf("(%d)", (s-r->program)+(next-s));
+		s += 3;
+		if (op == ANYOF || op == ANYBUT || op == EXACTLY) {
+			/* Literal string, where present. */
+			while (*s != '\0') {
+				putchar(*s);
+				s++;
+			}
+			s++;
+		}
+		putchar('\n');
+	}
+
+	/* Header fields of interest. */
+	if (r->regstart != '\0')
+		printf("start `%c' ", r->regstart);
+	if (r->reganch)
+		printf("anchored ");
+	if (r->regmust != NULL)
+		printf("must have \"%s\"", r->regmust);
+	printf("\n");
+}
+
+/*
+ - regprop - printable representation of opcode
+ */
+static char *
+regprop(char *op)
+{
+#define BUFLEN 50
+	register char *p;
+	static char buf[BUFLEN];
+
+	strcpy(buf, ":");
+
+	switch (OP(op)) {
+	case BOL:
+		p = "BOL";
+		break;
+	case EOL:
+		p = "EOL";
+		break;
+	case ANY:
+		p = "ANY";
+		break;
+	case ANYOF:
+		p = "ANYOF";
+		break;
+	case ANYBUT:
+		p = "ANYBUT";
+		break;
+	case BRANCH:
+		p = "BRANCH";
+		break;
+	case EXACTLY:
+		p = "EXACTLY";
+		break;
+	case NOTHING:
+		p = "NOTHING";
+		break;
+	case BACK:
+		p = "BACK";
+		break;
+	case END:
+		p = "END";
+		break;
+	case OPEN+1:
+	case OPEN+2:
+	case OPEN+3:
+	case OPEN+4:
+	case OPEN+5:
+	case OPEN+6:
+	case OPEN+7:
+	case OPEN+8:
+	case OPEN+9:
+		snprintf(buf+strlen(buf),BUFLEN-strlen(buf), "OPEN%d", OP(op)-OPEN);
+		p = NULL;
+		break;
+	case CLOSE+1:
+	case CLOSE+2:
+	case CLOSE+3:
+	case CLOSE+4:
+	case CLOSE+5:
+	case CLOSE+6:
+	case CLOSE+7:
+	case CLOSE+8:
+	case CLOSE+9:
+		snprintf(buf+strlen(buf),BUFLEN-strlen(buf), "CLOSE%d", OP(op)-CLOSE);
+		p = NULL;
+		break;
+	case STAR:
+		p = "STAR";
+		break;
+	case PLUS:
+		p = "PLUS";
+		break;
+	default:
+		printk("<3>Regexp: corrupted opcode\n");
+		break;
+	}
+	if (p != NULL)
+		strncat(buf, p, BUFLEN-strlen(buf));
+	return(buf);
+}
+#endif
+
+
diff -Nru linux-2.6.30.5/net/netfilter/regexp/regexp.h linux-2.6.30.5-wrt/net/netfilter/regexp/regexp.h
--- linux-2.6.30.5/net/netfilter/regexp/regexp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/net/netfilter/regexp/regexp.h	2009-09-06 18:43:48.366668750 +0200
@@ -0,0 +1,41 @@
+/*
+ * Definitions etc. for regexp(3) routines.
+ *
+ * Caveat:  this is V8 regexp(3) [actually, a reimplementation thereof],
+ * not the System V one.
+ */
+
+#ifndef REGEXP_H
+#define REGEXP_H
+
+
+/*
+http://www.opensource.apple.com/darwinsource/10.3/expect-1/expect/expect.h ,
+which contains a version of this library, says:
+
+ *
+ * NSUBEXP must be at least 10, and no greater than 117 or the parser
+ * will not work properly.
+ *
+
+However, it looks rather like this library is limited to 10.  If you think
+otherwise, let us know.
+*/
+
+#define NSUBEXP  10
+typedef struct regexp {
+	char *startp[NSUBEXP];
+	char *endp[NSUBEXP];
+	char regstart;		/* Internal use only. */
+	char reganch;		/* Internal use only. */
+	char *regmust;		/* Internal use only. */
+	int regmlen;		/* Internal use only. */
+	char program[1];	/* Unwarranted chumminess with compiler. */
+} regexp;
+
+regexp * regcomp(char *exp, int *patternsize);
+int regexec(regexp *prog, char *string);
+void regsub(regexp *prog, char *source, char *dest);
+void regerror(char *s);
+
+#endif
diff -Nru linux-2.6.30.5/net/netfilter/regexp/regmagic.h linux-2.6.30.5-wrt/net/netfilter/regexp/regmagic.h
--- linux-2.6.30.5/net/netfilter/regexp/regmagic.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/net/netfilter/regexp/regmagic.h	2009-09-06 18:43:48.366668750 +0200
@@ -0,0 +1,5 @@
+/*
+ * The first byte of the regexp internal "program" is actually this magic
+ * number; the start node begins in the second byte.
+ */
+#define	MAGIC	0234
diff -Nru linux-2.6.30.5/net/netfilter/regexp/regsub.c linux-2.6.30.5-wrt/net/netfilter/regexp/regsub.c
--- linux-2.6.30.5/net/netfilter/regexp/regsub.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/net/netfilter/regexp/regsub.c	2009-09-06 18:43:48.366668750 +0200
@@ -0,0 +1,95 @@
+/*
+ * regsub
+ * @(#)regsub.c	1.3 of 2 April 86
+ *
+ *	Copyright (c) 1986 by University of Toronto.
+ *	Written by Henry Spencer.  Not derived from licensed software.
+ *
+ *	Permission is granted to anyone to use this software for any
+ *	purpose on any computer system, and to redistribute it freely,
+ *	subject to the following restrictions:
+ *
+ *	1. The author is not responsible for the consequences of use of
+ *		this software, no matter how awful, even if they arise
+ *		from defects in it.
+ *
+ *	2. The origin of this software must not be misrepresented, either
+ *		by explicit claim or by omission.
+ *
+ *	3. Altered versions must be plainly marked as such, and must not
+ *		be misrepresented as being the original software.
+ *
+ *
+ * This code was modified by Ethan Sommer to work within the kernel
+ * (it now uses kmalloc etc..)
+ *
+ */
+#include "regexp.h"
+#include "regmagic.h"
+#include <linux/string.h>
+
+
+#ifndef CHARBITS
+#define	UCHARAT(p)	((int)*(unsigned char *)(p))
+#else
+#define	UCHARAT(p)	((int)*(p)&CHARBITS)
+#endif
+
+#if 0
+//void regerror(char * s)
+//{
+//        printk("regexp(3): %s", s);
+//        /* NOTREACHED */
+//}
+#endif
+
+/*
+ - regsub - perform substitutions after a regexp match
+ */
+void
+regsub(regexp * prog, char * source, char * dest)
+{
+	register char *src;
+	register char *dst;
+	register char c;
+	register int no;
+	register int len;
+	
+	/* Not necessary and gcc doesn't like it -MLS */
+	/*extern char *strncpy();*/
+
+	if (prog == NULL || source == NULL || dest == NULL) {
+		regerror("NULL parm to regsub");
+		return;
+	}
+	if (UCHARAT(prog->program) != MAGIC) {
+		regerror("damaged regexp fed to regsub");
+		return;
+	}
+
+	src = source;
+	dst = dest;
+	while ((c = *src++) != '\0') {
+		if (c == '&')
+			no = 0;
+		else if (c == '\\' && '0' <= *src && *src <= '9')
+			no = *src++ - '0';
+		else
+			no = -1;
+
+		if (no < 0) {	/* Ordinary character. */
+			if (c == '\\' && (*src == '\\' || *src == '&'))
+				c = *src++;
+			*dst++ = c;
+		} else if (prog->startp[no] != NULL && prog->endp[no] != NULL) {
+			len = prog->endp[no] - prog->startp[no];
+			(void) strncpy(dst, prog->startp[no], len);
+			dst += len;
+			if (len != 0 && *(dst-1) == '\0') {	/* strncpy hit NUL. */
+				regerror("damaged match string");
+				return;
+			}
+		}
+	}
+	*dst++ = '\0';
+}
diff -Nru linux-2.6.30.5/net/netfilter/xt_IMQ.c linux-2.6.30.5-wrt/net/netfilter/xt_IMQ.c
--- linux-2.6.30.5/net/netfilter/xt_IMQ.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/net/netfilter/xt_IMQ.c	2009-09-06 18:43:48.394667414 +0200
@@ -0,0 +1,73 @@
+/*
+ * This target marks packets to be enqueued to an imq device
+ */
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter/xt_IMQ.h>
+#include <linux/imq.h>
+
+static unsigned int imq_target(struct sk_buff *pskb,
+				const struct xt_target_param *par)
+{
+	const struct xt_imq_info *mr = par->targinfo;
+
+	pskb->imq_flags = (mr->todev & IMQ_F_IFMASK) | IMQ_F_ENQUEUE;
+
+	return XT_CONTINUE;
+}
+
+static bool imq_checkentry(const struct xt_tgchk_param *par)
+{
+	struct xt_imq_info *mr = par->targinfo;
+
+	if (mr->todev > IMQ_MAX_DEVS - 1) {
+		printk(KERN_WARNING
+		       "IMQ: invalid device specified, highest is %u\n",
+		       IMQ_MAX_DEVS - 1);
+		return 0;
+	}
+
+	return 1;
+}
+
+static struct xt_target xt_imq_reg[] __read_mostly = {
+	{
+		.name           = "IMQ",
+		.family		= AF_INET,
+		.checkentry     = imq_checkentry,
+		.target         = imq_target,
+		.targetsize	= sizeof(struct xt_imq_info),
+		.table		= "mangle",
+		.me             = THIS_MODULE
+	},
+	{
+		.name           = "IMQ",
+		.family		= AF_INET6,
+		.checkentry     = imq_checkentry,
+		.target         = imq_target,
+		.targetsize	= sizeof(struct xt_imq_info),
+		.table		= "mangle",
+		.me             = THIS_MODULE
+	},
+};
+
+static int __init imq_init(void)
+{
+	return xt_register_targets(xt_imq_reg, ARRAY_SIZE(xt_imq_reg));
+}
+
+static void __exit imq_fini(void)
+{
+	xt_unregister_targets(xt_imq_reg, ARRAY_SIZE(xt_imq_reg));
+}
+
+module_init(imq_init);
+module_exit(imq_fini);
+
+MODULE_AUTHOR("http://www.linuximq.net");
+MODULE_DESCRIPTION("Pseudo-driver for the intermediate queue device. See http://www.linuximq.net/ for more information.");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_IMQ");
+MODULE_ALIAS("ip6t_IMQ");
+
diff -Nru linux-2.6.30.5/net/netfilter/xt_layer7.c linux-2.6.30.5-wrt/net/netfilter/xt_layer7.c
--- linux-2.6.30.5/net/netfilter/xt_layer7.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/net/netfilter/xt_layer7.c	2009-09-06 18:43:48.370668913 +0200
@@ -0,0 +1,687 @@
+/*
+  Kernel module to match application layer (OSI layer 7) data in connections.
+
+  http://l7-filter.sf.net
+
+  (C) 2003-2009 Matthew Strait and Ethan Sommer.
+
+  This program is free software; you can redistribute it and/or
+  modify it under the terms of the GNU General Public License
+  as published by the Free Software Foundation; either version
+  2 of the License, or (at your option) any later version.
+  http://www.gnu.org/licenses/gpl.txt
+
+  Based on ipt_string.c (C) 2000 Emmanuel Roger <winfield@freegates.be>,
+  xt_helper.c (C) 2002 Harald Welte and cls_layer7.c (C) 2003 Matthew Strait,
+  Ethan Sommer, Justin Levandoski.
+*/
+
+#include <linux/spinlock.h>
+#include <linux/version.h>
+#include <net/ip.h>
+#include <net/tcp.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/netfilter.h>
+#include <net/netfilter/nf_conntrack.h>
+#include <net/netfilter/nf_conntrack_core.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+#include <net/netfilter/nf_conntrack_extend.h>
+#include <net/netfilter/nf_conntrack_acct.h>
+#endif
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter/xt_layer7.h>
+#include <linux/ctype.h>
+#include <linux/proc_fs.h>
+
+#include "regexp/regexp.c"
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Matthew Strait <quadong@users.sf.net>, Ethan Sommer <sommere@users.sf.net>");
+MODULE_DESCRIPTION("iptables application layer match module");
+MODULE_ALIAS("ipt_layer7");
+MODULE_VERSION("2.21");
+
+static int maxdatalen = 2048; // this is the default
+module_param(maxdatalen, int, 0444);
+MODULE_PARM_DESC(maxdatalen, "maximum bytes of data looked at by l7-filter");
+#ifdef CONFIG_NETFILTER_XT_MATCH_LAYER7_DEBUG
+	#define DPRINTK(format,args...) printk(format,##args)
+#else
+	#define DPRINTK(format,args...)
+#endif
+
+/* Number of packets whose data we look at.
+This can be modified through /proc/net/layer7_numpackets */
+static int num_packets = 10;
+
+static struct pattern_cache {
+	char * regex_string;
+	regexp * pattern;
+	struct pattern_cache * next;
+} * first_pattern_cache = NULL;
+
+DEFINE_SPINLOCK(l7_lock);
+
+static int total_acct_packets(struct nf_conn *ct)
+{
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 26)
+	BUG_ON(ct == NULL);
+	return (ct->counters[IP_CT_DIR_ORIGINAL].packets + ct->counters[IP_CT_DIR_REPLY].packets);
+#else
+	struct nf_conn_counter *acct;
+
+	BUG_ON(ct == NULL);
+	acct = nf_conn_acct_find(ct);
+	if (!acct)
+		return 0;
+	return (acct[IP_CT_DIR_ORIGINAL].packets + acct[IP_CT_DIR_REPLY].packets);
+#endif
+}
+
+#ifdef CONFIG_IP_NF_MATCH_LAYER7_DEBUG
+/* Converts an unfriendly string into a friendly one by
+replacing unprintables with periods and all whitespace with " ". */
+static char * friendly_print(unsigned char * s)
+{
+	char * f = kmalloc(strlen(s) + 1, GFP_ATOMIC);
+	int i;
+
+	if(!f) {
+		if (net_ratelimit())
+			printk(KERN_ERR "layer7: out of memory in "
+					"friendly_print, bailing.\n");
+		return NULL;
+	}
+
+	for(i = 0; i < strlen(s); i++){
+		if(isprint(s[i]) && s[i] < 128)	f[i] = s[i];
+		else if(isspace(s[i]))		f[i] = ' ';
+		else 				f[i] = '.';
+	}
+	f[i] = '\0';
+	return f;
+}
+
+static char dec2hex(int i)
+{
+	switch (i) {
+		case 0 ... 9:
+			return (i + '0');
+			break;
+		case 10 ... 15:
+			return (i - 10 + 'a');
+			break;
+		default:
+			if (net_ratelimit())
+				printk("layer7: Problem in dec2hex\n");
+			return '\0';
+	}
+}
+
+static char * hex_print(unsigned char * s)
+{
+	char * g = kmalloc(strlen(s)*3 + 1, GFP_ATOMIC);
+	int i;
+
+	if(!g) {
+	       if (net_ratelimit())
+			printk(KERN_ERR "layer7: out of memory in hex_print, "
+					"bailing.\n");
+	       return NULL;
+	}
+
+	for(i = 0; i < strlen(s); i++) {
+		g[i*3    ] = dec2hex(s[i]/16);
+		g[i*3 + 1] = dec2hex(s[i]%16);
+		g[i*3 + 2] = ' ';
+	}
+	g[i*3] = '\0';
+
+	return g;
+}
+#endif // DEBUG
+
+/* Use instead of regcomp.  As we expect to be seeing the same regexps over and
+over again, it make sense to cache the results. */
+static regexp * compile_and_cache(const char * regex_string, 
+                                  const char * protocol)
+{
+	struct pattern_cache * node               = first_pattern_cache;
+	struct pattern_cache * last_pattern_cache = first_pattern_cache;
+	struct pattern_cache * tmp;
+	unsigned int len;
+
+	while (node != NULL) {
+		if (!strcmp(node->regex_string, regex_string))
+		return node->pattern;
+
+		last_pattern_cache = node;/* points at the last non-NULL node */
+		node = node->next;
+	}
+
+	/* If we reach the end of the list, then we have not yet cached
+	   the pattern for this regex. Let's do that now.
+	   Be paranoid about running out of memory to avoid list corruption. */
+	tmp = kmalloc(sizeof(struct pattern_cache), GFP_ATOMIC);
+
+	if(!tmp) {
+		if (net_ratelimit())
+			printk(KERN_ERR "layer7: out of memory in "
+					"compile_and_cache, bailing.\n");
+		return NULL;
+	}
+
+	tmp->regex_string  = kmalloc(strlen(regex_string) + 1, GFP_ATOMIC);
+	tmp->pattern       = kmalloc(sizeof(struct regexp),    GFP_ATOMIC);
+	tmp->next = NULL;
+
+	if(!tmp->regex_string || !tmp->pattern) {
+		if (net_ratelimit())
+			printk(KERN_ERR "layer7: out of memory in "
+					"compile_and_cache, bailing.\n");
+		kfree(tmp->regex_string);
+		kfree(tmp->pattern);
+		kfree(tmp);
+		return NULL;
+	}
+
+	/* Ok.  The new node is all ready now. */
+	node = tmp;
+
+	if(first_pattern_cache == NULL) /* list is empty */
+		first_pattern_cache = node; /* make node the beginning */
+	else
+		last_pattern_cache->next = node; /* attach node to the end */
+
+	/* copy the string and compile the regex */
+	len = strlen(regex_string);
+	DPRINTK("About to compile this: \"%s\"\n", regex_string);
+	node->pattern = regcomp((char *)regex_string, &len);
+	if ( !node->pattern ) {
+		if (net_ratelimit())
+			printk(KERN_ERR "layer7: Error compiling regexp "
+					"\"%s\" (%s)\n", 
+					regex_string, protocol);
+		/* pattern is now cached as NULL, so we won't try again. */
+	}
+
+	strcpy(node->regex_string, regex_string);
+	return node->pattern;
+}
+
+static int can_handle(const struct sk_buff *skb)
+{
+	if(!ip_hdr(skb)) /* not IP */
+		return 0;
+	if(ip_hdr(skb)->protocol != IPPROTO_TCP &&
+	   ip_hdr(skb)->protocol != IPPROTO_UDP &&
+	   ip_hdr(skb)->protocol != IPPROTO_ICMP)
+		return 0;
+	return 1;
+}
+
+/* Returns offset the into the skb->data that the application data starts */
+static int app_data_offset(const struct sk_buff *skb)
+{
+	/* In case we are ported somewhere (ebtables?) where ip_hdr(skb)
+	isn't set, this can be gotten from 4*(skb->data[0] & 0x0f) as well. */
+	int ip_hl = 4*ip_hdr(skb)->ihl;
+
+	if( ip_hdr(skb)->protocol == IPPROTO_TCP ) {
+		/* 12 == offset into TCP header for the header length field.
+		Can't get this with skb->h.th->doff because the tcphdr
+		struct doesn't get set when routing (this is confirmed to be
+		true in Netfilter as well as QoS.) */
+		int tcp_hl = 4*(skb->data[ip_hl + 12] >> 4);
+
+		return ip_hl + tcp_hl;
+	} else if( ip_hdr(skb)->protocol == IPPROTO_UDP  ) {
+		return ip_hl + 8; /* UDP header is always 8 bytes */
+	} else if( ip_hdr(skb)->protocol == IPPROTO_ICMP ) {
+		return ip_hl + 8; /* ICMP header is 8 bytes */
+	} else {
+		if (net_ratelimit())
+			printk(KERN_ERR "layer7: tried to handle unknown "
+					"protocol!\n");
+		return ip_hl + 8; /* something reasonable */
+	}
+}
+
+/* handles whether there's a match when we aren't appending data anymore */
+static int match_no_append(struct nf_conn * conntrack, 
+                           struct nf_conn * master_conntrack, 
+                           enum ip_conntrack_info ctinfo,
+                           enum ip_conntrack_info master_ctinfo,
+                           const struct xt_layer7_info * info)
+{
+	/* If we're in here, throw the app data away */
+	if(master_conntrack->layer7.app_data != NULL) {
+
+	#ifdef CONFIG_IP_NF_MATCH_LAYER7_DEBUG
+		if(!master_conntrack->layer7.app_proto) {
+			char * f = 
+			  friendly_print(master_conntrack->layer7.app_data);
+			char * g = 
+			  hex_print(master_conntrack->layer7.app_data);
+			DPRINTK("\nl7-filter gave up after %d bytes "
+				"(%d packets):\n%s\n",
+				strlen(f), total_acct_packets(master_conntrack), f);
+			kfree(f);
+			DPRINTK("In hex: %s\n", g);
+			kfree(g);
+		}
+	#endif
+
+		kfree(master_conntrack->layer7.app_data);
+		master_conntrack->layer7.app_data = NULL; /* don't free again */
+	}
+
+	if(master_conntrack->layer7.app_proto){
+		/* Here child connections set their .app_proto (for /proc) */
+		if(!conntrack->layer7.app_proto) {
+			conntrack->layer7.app_proto = 
+			  kmalloc(strlen(master_conntrack->layer7.app_proto)+1, 
+			    GFP_ATOMIC);
+			if(!conntrack->layer7.app_proto){
+				if (net_ratelimit())
+					printk(KERN_ERR "layer7: out of memory "
+							"in match_no_append, "
+							"bailing.\n");
+				return 1;
+			}
+			strcpy(conntrack->layer7.app_proto, 
+				master_conntrack->layer7.app_proto);
+		}
+
+		return (!strcmp(master_conntrack->layer7.app_proto, 
+				info->protocol));
+	}
+	else {
+		/* If not classified, set to "unknown" to distinguish from
+		connections that are still being tested. */
+		master_conntrack->layer7.app_proto = 
+			kmalloc(strlen("unknown")+1, GFP_ATOMIC);
+		if(!master_conntrack->layer7.app_proto){
+			if (net_ratelimit())
+				printk(KERN_ERR "layer7: out of memory in "
+						"match_no_append, bailing.\n");
+			return 1;
+		}
+		strcpy(master_conntrack->layer7.app_proto, "unknown");
+		return 0;
+	}
+}
+
+/* add the new app data to the conntrack.  Return number of bytes added. */
+static int add_datastr(char *target, int offset, char *app_data, int len)
+{
+	int length = 0, i;
+	if (!target) return 0;
+
+	/* Strip nulls. Make everything lower case (our regex lib doesn't
+	do case insensitivity).  Add it to the end of the current data. */
+ 	for(i = 0; i < maxdatalen-offset-1 && i < len; i++) {
+		if(app_data[i] != '\0') {
+			/* the kernel version of tolower mungs 'upper ascii' */
+			target[length+offset] =
+				isascii(app_data[i])? 
+					tolower(app_data[i]) : app_data[i];
+			length++;
+		}
+	}
+	target[length+offset] = '\0';
+
+	return length;
+}
+
+/* add the new app data to the conntrack.  Return number of bytes added. */
+static int add_data(struct nf_conn * master_conntrack,
+                    char * app_data, int appdatalen)
+{
+	int length;
+
+	length = add_datastr(master_conntrack->layer7.app_data, master_conntrack->layer7.app_data_len, app_data, appdatalen);
+	master_conntrack->layer7.app_data_len += length;
+
+	return length;
+}
+
+/* taken from drivers/video/modedb.c */
+static int my_atoi(const char *s)
+{
+	int val = 0;
+
+	for (;; s++) {
+		switch (*s) {
+			case '0'...'9':
+			val = 10*val+(*s-'0');
+			break;
+		default:
+			return val;
+		}
+	}
+}
+
+/* write out num_packets to userland. */
+static int layer7_read_proc(char* page, char ** start, off_t off, int count,
+                            int* eof, void * data)
+{
+	if(num_packets > 99 && net_ratelimit())
+		printk(KERN_ERR "layer7: NOT REACHED. num_packets too big\n");
+
+	page[0] = num_packets/10 + '0';
+	page[1] = num_packets%10 + '0';
+	page[2] = '\n';
+	page[3] = '\0';
+
+	*eof=1;
+
+	return 3;
+}
+
+/* Read in num_packets from userland */
+static int layer7_write_proc(struct file* file, const char* buffer,
+                             unsigned long count, void *data)
+{
+	char * foo = kmalloc(count, GFP_ATOMIC);
+
+	if(!foo){
+		if (net_ratelimit())
+			printk(KERN_ERR "layer7: out of memory, bailing. "
+					"num_packets unchanged.\n");
+		return count;
+	}
+
+	if(copy_from_user(foo, buffer, count)) {
+		return -EFAULT;
+	}
+
+
+	num_packets = my_atoi(foo);
+	kfree (foo);
+
+	/* This has an arbitrary limit to make the math easier. I'm lazy.
+	But anyway, 99 is a LOT! If you want more, you're doing it wrong! */
+	if(num_packets > 99) {
+		printk(KERN_WARNING "layer7: num_packets can't be > 99.\n");
+		num_packets = 99;
+	} else if(num_packets < 1) {
+		printk(KERN_WARNING "layer7: num_packets can't be < 1.\n");
+		num_packets = 1;
+	}
+
+	return count;
+}
+
+static bool
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+match(const struct sk_buff *skbin, const struct xt_match_param *par)
+#else
+match(const struct sk_buff *skbin,
+      const struct net_device *in,
+      const struct net_device *out,
+      const struct xt_match *match,
+      const void *matchinfo,
+      int offset,
+      unsigned int protoff,
+      bool *hotdrop)
+#endif
+{
+	/* sidestep const without getting a compiler warning... */
+	struct sk_buff * skb = (struct sk_buff *)skbin; 
+
+	const struct xt_layer7_info * info = 
+	#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+		par->matchinfo;
+	#else
+		matchinfo;
+	#endif
+
+	enum ip_conntrack_info master_ctinfo, ctinfo;
+	struct nf_conn *master_conntrack, *conntrack;
+	unsigned char *app_data, *tmp_data;
+	unsigned int pattern_result, appdatalen;
+	regexp * comppattern;
+
+	/* Be paranoid/incompetent - lock the entire match function. */
+	spin_lock_bh(&l7_lock);
+
+	if(!can_handle(skb)){
+		DPRINTK("layer7: This is some protocol I can't handle.\n");
+		spin_unlock_bh(&l7_lock);
+		return info->invert;
+	}
+
+	/* Treat parent & all its children together as one connection, except
+	for the purpose of setting conntrack->layer7.app_proto in the actual
+	connection. This makes /proc/net/ip_conntrack more satisfying. */
+	if(!(conntrack = nf_ct_get(skb, &ctinfo)) ||
+	   !(master_conntrack=nf_ct_get(skb,&master_ctinfo))){
+		DPRINTK("layer7: couldn't get conntrack.\n");
+		spin_unlock_bh(&l7_lock);
+		return info->invert;
+	}
+
+	/* Try to get a master conntrack (and its master etc) for FTP, etc. */
+	while (master_ct(master_conntrack) != NULL)
+		master_conntrack = master_ct(master_conntrack);
+
+	/* if we've classified it or seen too many packets */
+	if(!info->pkt && (total_acct_packets(master_conntrack) > num_packets ||
+	   master_conntrack->layer7.app_proto)) {
+
+		pattern_result = match_no_append(conntrack, master_conntrack, 
+						 ctinfo, master_ctinfo, info);
+
+		/* skb->cb[0] == seen. Don't do things twice if there are 
+		multiple l7 rules. I'm not sure that using cb for this purpose 
+		is correct, even though it says "put your private variables 
+		there". But it doesn't look like it is being used for anything
+		else in the skbs that make it here. */
+		skb->cb[0] = 1; /* marking it seen here's probably irrelevant */
+
+		spin_unlock_bh(&l7_lock);
+		return (pattern_result ^ info->invert);
+	}
+
+	if(skb_is_nonlinear(skb)){
+		if(skb_linearize(skb) != 0){
+			if (net_ratelimit())
+				printk(KERN_ERR "layer7: failed to linearize "
+						"packet, bailing.\n");
+			spin_unlock_bh(&l7_lock);
+			return info->invert;
+		}
+	}
+
+	/* now that the skb is linearized, it's safe to set these. */
+	app_data = skb->data + app_data_offset(skb);
+	appdatalen = skb_tail_pointer(skb) - app_data;
+
+	/* the return value gets checked later, when we're ready to use it */
+	comppattern = compile_and_cache(info->pattern, info->protocol);
+
+	if (info->pkt) {
+		tmp_data = kmalloc(maxdatalen, GFP_ATOMIC);
+		if(!tmp_data){
+			if (net_ratelimit())
+				printk(KERN_ERR "layer7: out of memory in match, bailing.\n");
+			return info->invert;
+		}
+
+		tmp_data[0] = '\0';
+		add_datastr(tmp_data, 0, app_data, appdatalen);
+		pattern_result = ((comppattern && regexec(comppattern, tmp_data)) ? 1 : 0);
+
+		kfree(tmp_data);
+		tmp_data = NULL;
+		spin_unlock_bh(&l7_lock);
+
+		return (pattern_result ^ info->invert);
+	}
+
+	/* On the first packet of a connection, allocate space for app data */
+	if(total_acct_packets(master_conntrack) == 1 && !skb->cb[0] && 
+	   !master_conntrack->layer7.app_data){
+		master_conntrack->layer7.app_data = 
+			kmalloc(maxdatalen, GFP_ATOMIC);
+		if(!master_conntrack->layer7.app_data){
+			if (net_ratelimit())
+				printk(KERN_ERR "layer7: out of memory in "
+						"match, bailing.\n");
+			spin_unlock_bh(&l7_lock);
+			return info->invert;
+		}
+
+		master_conntrack->layer7.app_data[0] = '\0';
+	}
+
+	/* Can be here, but unallocated, if numpackets is increased near
+	the beginning of a connection */
+	if(master_conntrack->layer7.app_data == NULL){
+		spin_unlock_bh(&l7_lock);
+		return info->invert; /* unmatched */
+	}
+
+	if(!skb->cb[0]){
+		int newbytes;
+		newbytes = add_data(master_conntrack, app_data, appdatalen);
+
+		if(newbytes == 0) { /* didn't add any data */
+			skb->cb[0] = 1;
+			/* Didn't match before, not going to match now */
+			spin_unlock_bh(&l7_lock);
+			return info->invert;
+		}
+	}
+
+	/* If looking for "unknown", then never match.  "Unknown" means that
+	we've given up; we're still trying with these packets. */
+	if(!strcmp(info->protocol, "unknown")) {
+		pattern_result = 0;
+	/* If looking for "unset", then always match. "Unset" means that we
+	haven't yet classified the connection. */
+	} else if(!strcmp(info->protocol, "unset")) {
+		pattern_result = 2;
+		DPRINTK("layer7: matched unset: not yet classified "
+			"(%d/%d packets)\n",
+                        total_acct_packets(master_conntrack), num_packets);
+	/* If the regexp failed to compile, don't bother running it */
+	} else if(comppattern && 
+		  regexec(comppattern, master_conntrack->layer7.app_data)){
+		DPRINTK("layer7: matched %s\n", info->protocol);
+		pattern_result = 1;
+	} else pattern_result = 0;
+
+	if(pattern_result == 1) {
+		master_conntrack->layer7.app_proto = 
+			kmalloc(strlen(info->protocol)+1, GFP_ATOMIC);
+		if(!master_conntrack->layer7.app_proto){
+			if (net_ratelimit())
+				printk(KERN_ERR "layer7: out of memory in "
+						"match, bailing.\n");
+			spin_unlock_bh(&l7_lock);
+			return (pattern_result ^ info->invert);
+		}
+		strcpy(master_conntrack->layer7.app_proto, info->protocol);
+	} else if(pattern_result > 1) { /* cleanup from "unset" */
+		pattern_result = 1;
+	}
+
+	/* mark the packet seen */
+	skb->cb[0] = 1;
+
+	spin_unlock_bh(&l7_lock);
+	return (pattern_result ^ info->invert);
+}
+
+// load nf_conntrack_ipv4
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+static bool check(const struct xt_mtchk_param *par)
+{
+        if (nf_ct_l3proto_try_module_get(par->match->family) < 0) {
+                printk(KERN_WARNING "can't load conntrack support for "
+                                    "proto=%d\n", par->match->family);
+#else
+static bool check(const char *tablename, const void *inf,
+		 const struct xt_match *match, void *matchinfo,
+		 unsigned int hook_mask)
+{
+        if (nf_ct_l3proto_try_module_get(match->family) < 0) {
+                printk(KERN_WARNING "can't load conntrack support for "
+                                    "proto=%d\n", match->family);
+#endif
+                return 0;
+        }
+	return 1;
+}
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+	static void destroy(const struct xt_mtdtor_param *par)
+	{
+		nf_ct_l3proto_module_put(par->match->family);
+	}
+#else
+	static void destroy(const struct xt_match *match, void *matchinfo)
+	{
+		nf_ct_l3proto_module_put(match->family);
+	}
+#endif
+
+static struct xt_match xt_layer7_match[] __read_mostly = {
+{
+	.name		= "layer7",
+	.family		= AF_INET,
+	.checkentry	= check,
+	.match		= match,
+	.destroy	= destroy,
+	.matchsize	= sizeof(struct xt_layer7_info),
+	.me		= THIS_MODULE
+}
+};
+
+static void layer7_cleanup_proc(void)
+{
+	remove_proc_entry("layer7_numpackets", init_net.proc_net);
+}
+
+/* register the proc file */
+static void layer7_init_proc(void)
+{
+	struct proc_dir_entry* entry;
+	entry = create_proc_entry("layer7_numpackets", 0644, init_net.proc_net);
+	entry->read_proc = layer7_read_proc;
+	entry->write_proc = layer7_write_proc;
+}
+
+static int __init xt_layer7_init(void)
+{
+	need_conntrack();
+
+	layer7_init_proc();
+	if(maxdatalen < 1) {
+		printk(KERN_WARNING "layer7: maxdatalen can't be < 1, "
+			"using 1\n");
+		maxdatalen = 1;
+	}
+	/* This is not a hard limit.  It's just here to prevent people from
+	bringing their slow machines to a grinding halt. */
+	else if(maxdatalen > 65536) {
+		printk(KERN_WARNING "layer7: maxdatalen can't be > 65536, "
+			"using 65536\n");
+		maxdatalen = 65536;
+	}
+	return xt_register_matches(xt_layer7_match,
+				   ARRAY_SIZE(xt_layer7_match));
+}
+
+static void __exit xt_layer7_fini(void)
+{
+	layer7_cleanup_proc();
+	xt_unregister_matches(xt_layer7_match, ARRAY_SIZE(xt_layer7_match));
+}
+
+module_init(xt_layer7_init);
+module_exit(xt_layer7_fini);
diff -Nru linux-2.6.30.5/net/packet/af_packet.c linux-2.6.30.5-wrt/net/packet/af_packet.c
--- linux-2.6.30.5/net/packet/af_packet.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/net/packet/af_packet.c	2009-09-06 18:43:48.438677047 +0200
@@ -192,6 +192,7 @@
 	unsigned int		tp_hdrlen;
 	unsigned int		tp_reserve;
 #endif
+	unsigned int		pkt_type;
 };
 
 struct packet_skb_cb {
@@ -282,6 +283,7 @@
 {
 	struct sock *sk;
 	struct sockaddr_pkt *spkt;
+	struct packet_sock *po;
 
 	/*
 	 *	When we registered the protocol we saved the socket in the data
@@ -289,6 +291,7 @@
 	 */
 
 	sk = pt->af_packet_priv;
+	po = pkt_sk(sk);
 
 	/*
 	 *	Yank back the headers [hope the device set this
@@ -301,7 +304,7 @@
 	 *	so that this procedure is noop.
 	 */
 
-	if (skb->pkt_type == PACKET_LOOPBACK)
+	if (!(po->pkt_type & (1 << skb->pkt_type)))
 		goto out;
 
 	if (dev_net(dev) != sock_net(sk))
@@ -486,12 +489,12 @@
 	int skb_len = skb->len;
 	unsigned int snaplen, res;
 
-	if (skb->pkt_type == PACKET_LOOPBACK)
-		goto drop;
-
 	sk = pt->af_packet_priv;
 	po = pkt_sk(sk);
 
+	if (!(po->pkt_type & (1 << skb->pkt_type)))
+		goto drop;
+
 	if (dev_net(dev) != sock_net(sk))
 		goto drop;
 
@@ -608,12 +611,12 @@
 	struct timeval tv;
 	struct timespec ts;
 
-	if (skb->pkt_type == PACKET_LOOPBACK)
-		goto drop;
-
 	sk = pt->af_packet_priv;
 	po = pkt_sk(sk);
 
+	if (!(po->pkt_type & (1 << skb->pkt_type)))
+		goto drop;
+
 	if (dev_net(dev) != sock_net(sk))
 		goto drop;
 
@@ -1072,6 +1075,7 @@
 	spin_lock_init(&po->bind_lock);
 	mutex_init(&po->pg_vec_lock);
 	po->prot_hook.func = packet_rcv;
+	po->pkt_type = PACKET_MASK_ANY & ~(1 << PACKET_LOOPBACK);
 
 	if (sock->type == SOCK_PACKET)
 		po->prot_hook.func = packet_rcv_spkt;
@@ -1412,6 +1416,16 @@
 			ret = packet_mc_drop(sk, &mreq);
 		return ret;
 	}
+	case PACKET_RECV_TYPE:
+	{
+		unsigned int val;
+		if (optlen != sizeof(val))
+			return -EINVAL;
+		if (copy_from_user(&val, optval, sizeof(val)))
+			return -EFAULT;
+		po->pkt_type = val & ~PACKET_LOOPBACK;
+		return 0;
+	}
 
 #ifdef CONFIG_PACKET_MMAP
 	case PACKET_RX_RING:
@@ -1543,6 +1557,13 @@
 
 		data = &val;
 		break;
+	case PACKET_RECV_TYPE:
+		if (len > sizeof(unsigned int))
+			len = sizeof(unsigned int);
+		val = po->pkt_type;
+
+		data = &val;
+		break;
 #ifdef CONFIG_PACKET_MMAP
 	case PACKET_VERSION:
 		if (len > sizeof(int))
diff -Nru linux-2.6.30.5/net/sched/Kconfig linux-2.6.30.5-wrt/net/sched/Kconfig
--- linux-2.6.30.5/net/sched/Kconfig	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/net/sched/Kconfig	2009-09-06 18:43:48.402669044 +0200
@@ -137,6 +137,37 @@
 	  To compile this code as a module, choose M here: the
 	  module will be called sch_sfq.
 
+config NET_SCH_ESFQ
+	tristate "Enhanced Stochastic Fairness Queueing (ESFQ)"
+	---help---
+	  Say Y here if you want to use the Enhanced Stochastic Fairness
+	  Queueing (ESFQ) packet scheduling algorithm for some of your network
+	  devices or as a leaf discipline for a classful qdisc such as HTB or
+	  CBQ (see the top of <file:net/sched/sch_esfq.c> for details and
+	  references to the SFQ algorithm).
+
+	  This is an enchanced SFQ version which allows you to control some
+	  hardcoded values in the SFQ scheduler.
+
+	  ESFQ also adds control of the hash function used to identify packet
+	  flows. The original SFQ discipline hashes by connection; ESFQ add
+	  several other hashing methods, such as by src IP or by dst IP, which
+	  can be more fair to users in some networking situations.
+
+	  To compile this code as a module, choose M here: the
+	  module will be called sch_esfq.
+
+config NET_SCH_ESFQ_NFCT
+	bool "Connection Tracking Hash Types"
+	depends on NET_SCH_ESFQ && NF_CONNTRACK
+	---help---
+	  Say Y here to enable support for hashing based on netfilter connection
+	  tracking information. This is useful for a router that is also using
+	  NAT to connect privately-addressed hosts to the Internet. If you want
+	  to provide fair distribution of upstream bandwidth, ESFQ must use
+	  connection tracking information, since all outgoing packets will share
+	  the same source address.
+
 config NET_SCH_TEQL
 	tristate "True Link Equalizer (TEQL)"
 	---help---
diff -Nru linux-2.6.30.5/net/sched/Makefile linux-2.6.30.5-wrt/net/sched/Makefile
--- linux-2.6.30.5/net/sched/Makefile	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/net/sched/Makefile	2009-09-06 18:43:48.402669044 +0200
@@ -24,6 +24,7 @@
 obj-$(CONFIG_NET_SCH_INGRESS)	+= sch_ingress.o 
 obj-$(CONFIG_NET_SCH_DSMARK)	+= sch_dsmark.o
 obj-$(CONFIG_NET_SCH_SFQ)	+= sch_sfq.o
+obj-$(CONFIG_NET_SCH_ESFQ)	+= sch_esfq.o
 obj-$(CONFIG_NET_SCH_TBF)	+= sch_tbf.o
 obj-$(CONFIG_NET_SCH_TEQL)	+= sch_teql.o
 obj-$(CONFIG_NET_SCH_PRIO)	+= sch_prio.o
diff -Nru linux-2.6.30.5/net/sched/sch_esfq.c linux-2.6.30.5-wrt/net/sched/sch_esfq.c
--- linux-2.6.30.5/net/sched/sch_esfq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.30.5-wrt/net/sched/sch_esfq.c	2009-09-06 18:43:48.402669044 +0200
@@ -0,0 +1,700 @@
+/*
+ * net/sched/sch_esfq.c	Extended Stochastic Fairness Queueing discipline.
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ * Authors:	Alexey Kuznetsov, <kuznet@ms2.inr.ac.ru>
+ *
+ * Changes:	Alexander Atanasov, <alex@ssi.bg>
+ *		Added dynamic depth,limit,divisor,hash_kind options.
+ *		Added dst and src hashes.
+ *
+ * 		Alexander Clouter, <alex@digriz.org.uk>
+ *		Ported ESFQ to Linux 2.6.
+ *
+ * 		Corey Hickey, <bugfood-c@fatooh.org>
+ *		Maintenance of the Linux 2.6 port.
+ *		Added fwmark hash (thanks to Robert Kurjata).
+ *		Added usage of jhash.
+ *		Added conntrack support.
+ *		Added ctnatchg hash (thanks to Ben Pfountz).
+ */
+
+#include <linux/module.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <linux/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/jiffies.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/if_ether.h>
+#include <linux/inet.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/notifier.h>
+#include <linux/init.h>
+#include <net/ip.h>
+#include <net/netlink.h>
+#include <linux/ipv6.h>
+#include <net/route.h>
+#include <linux/skbuff.h>
+#include <net/sock.h>
+#include <net/pkt_sched.h>
+#include <linux/jhash.h>
+#include <net/netfilter/nf_conntrack.h>
+
+/*	Stochastic Fairness Queuing algorithm.
+	For more comments look at sch_sfq.c.
+	The difference is that you can change limit, depth,
+	hash table size and choose alternate hash types.
+
+	classic:	same as in sch_sfq.c
+	dst:		destination IP address
+	src:		source IP address
+	fwmark:		netfilter mark value
+	ctorigdst:	original destination IP address
+	ctorigsrc:	original source IP address
+	ctrepldst:	reply destination IP address
+	ctreplsrc:	reply source IP
+
+*/
+
+#define ESFQ_HEAD 0
+#define ESFQ_TAIL 1
+
+/* This type should contain at least SFQ_DEPTH*2 values */
+typedef unsigned int esfq_index;
+
+struct esfq_head
+{
+	esfq_index	next;
+	esfq_index	prev;
+};
+
+struct esfq_sched_data
+{
+/* Parameters */
+	int		perturb_period;
+	unsigned	quantum;	/* Allotment per round: MUST BE >= MTU */
+	int		limit;
+	unsigned	depth;
+	unsigned	hash_divisor;
+	unsigned	hash_kind;
+/* Variables */
+	struct timer_list perturb_timer;
+	int		perturbation;
+	esfq_index	tail;		/* Index of current slot in round */
+	esfq_index	max_depth;	/* Maximal depth */
+
+	esfq_index	*ht;			/* Hash table */
+	esfq_index	*next;			/* Active slots link */
+	short		*allot;			/* Current allotment per slot */
+	unsigned short	*hash;			/* Hash value indexed by slots */
+	struct sk_buff_head	*qs;		/* Slot queue */
+	struct esfq_head	*dep;		/* Linked list of slots, indexed by depth */
+};
+
+/* This contains the info we will hash. */
+struct esfq_packet_info
+{
+	u32	proto;		/* protocol or port */
+	u32	src;		/* source from packet header */
+	u32	dst;		/* destination from packet header */
+	u32	ctorigsrc;	/* original source from conntrack */
+	u32	ctorigdst;	/* original destination from conntrack */
+	u32	ctreplsrc;	/* reply source from conntrack */
+	u32	ctrepldst;	/* reply destination from conntrack */
+	u32	mark;		/* netfilter mark (fwmark) */
+};
+
+static __inline__ unsigned esfq_jhash_1word(struct esfq_sched_data *q,u32 a)
+{
+	return jhash_1word(a, q->perturbation) & (q->hash_divisor-1);
+}
+
+static __inline__ unsigned esfq_jhash_2words(struct esfq_sched_data *q, u32 a, u32 b)
+{
+	return jhash_2words(a, b, q->perturbation) & (q->hash_divisor-1);
+}
+
+static __inline__ unsigned esfq_jhash_3words(struct esfq_sched_data *q, u32 a, u32 b, u32 c)
+{
+	return jhash_3words(a, b, c, q->perturbation) & (q->hash_divisor-1);
+}
+
+static unsigned esfq_hash(struct esfq_sched_data *q, struct sk_buff *skb)
+{
+	struct esfq_packet_info info;
+#ifdef CONFIG_NET_SCH_ESFQ_NFCT
+	enum ip_conntrack_info ctinfo;
+	struct nf_conn *ct = nf_ct_get(skb, &ctinfo);
+#endif
+
+	switch (skb->protocol) {
+	case __constant_htons(ETH_P_IP):
+	{
+		struct iphdr *iph = ip_hdr(skb);
+		info.dst = iph->daddr;
+		info.src = iph->saddr;
+		if (!(iph->frag_off&htons(IP_MF|IP_OFFSET)) &&
+		    (iph->protocol == IPPROTO_TCP ||
+		     iph->protocol == IPPROTO_UDP ||
+		     iph->protocol == IPPROTO_SCTP ||
+		     iph->protocol == IPPROTO_DCCP ||
+		     iph->protocol == IPPROTO_ESP))
+			info.proto = *(((u32*)iph) + iph->ihl);
+		else
+			info.proto = iph->protocol;
+		break;
+	}
+	case __constant_htons(ETH_P_IPV6):
+	{
+		struct ipv6hdr *iph = ipv6_hdr(skb);
+		/* Hash ipv6 addresses into a u32. This isn't ideal,
+		 * but the code is simple. */
+		info.dst = jhash2(iph->daddr.s6_addr32, 4, q->perturbation);
+		info.src = jhash2(iph->saddr.s6_addr32, 4, q->perturbation);
+		if (iph->nexthdr == IPPROTO_TCP ||
+		    iph->nexthdr == IPPROTO_UDP ||
+		    iph->nexthdr == IPPROTO_SCTP ||
+		    iph->nexthdr == IPPROTO_DCCP ||
+		    iph->nexthdr == IPPROTO_ESP)
+			info.proto = *(u32*)&iph[1];
+		else
+			info.proto = iph->nexthdr;
+		break;
+	}
+	default:
+		info.dst   = (u32)(unsigned long)skb->dst;
+		info.src   = (u32)(unsigned long)skb->sk;
+		info.proto = skb->protocol;
+	}
+
+	info.mark = skb->mark;
+
+#ifdef CONFIG_NET_SCH_ESFQ_NFCT
+	/* defaults if there is no conntrack info */
+	info.ctorigsrc = info.src;
+	info.ctorigdst = info.dst;
+	info.ctreplsrc = info.dst;
+	info.ctrepldst = info.src;
+	/* collect conntrack info */
+	if (ct && ct != &nf_conntrack_untracked) {
+		if (skb->protocol == __constant_htons(ETH_P_IP)) {
+			info.ctorigsrc = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;
+			info.ctorigdst = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip;
+			info.ctreplsrc = ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3.ip;
+			info.ctrepldst = ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip;
+		}
+		else if (skb->protocol == __constant_htons(ETH_P_IPV6)) {
+			/* Again, hash ipv6 addresses into a single u32. */
+			info.ctorigsrc = jhash2(ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip6, 4, q->perturbation);
+			info.ctorigdst = jhash2(ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip6, 4, q->perturbation);
+			info.ctreplsrc = jhash2(ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3.ip6, 4, q->perturbation);
+			info.ctrepldst = jhash2(ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip6, 4, q->perturbation);
+		}
+
+	}
+#endif
+
+	switch(q->hash_kind) {
+	case TCA_SFQ_HASH_CLASSIC:
+		return esfq_jhash_3words(q, info.dst, info.src, info.proto);
+	case TCA_SFQ_HASH_DST:
+		return esfq_jhash_1word(q, info.dst);
+	case TCA_SFQ_HASH_SRC:
+		return esfq_jhash_1word(q, info.src);
+	case TCA_SFQ_HASH_FWMARK:
+		return esfq_jhash_1word(q, info.mark);
+#ifdef CONFIG_NET_SCH_ESFQ_NFCT
+	case TCA_SFQ_HASH_CTORIGDST:
+		return esfq_jhash_1word(q, info.ctorigdst);
+	case TCA_SFQ_HASH_CTORIGSRC:
+		return esfq_jhash_1word(q, info.ctorigsrc);
+	case TCA_SFQ_HASH_CTREPLDST:
+		return esfq_jhash_1word(q, info.ctrepldst);
+	case TCA_SFQ_HASH_CTREPLSRC:
+		return esfq_jhash_1word(q, info.ctreplsrc);
+	case TCA_SFQ_HASH_CTNATCHG:
+	{
+		if (info.ctorigdst == info.ctreplsrc)
+			return esfq_jhash_1word(q, info.ctorigsrc);
+		return esfq_jhash_1word(q, info.ctreplsrc);
+	}
+#endif
+	default:
+		if (net_ratelimit())
+			printk(KERN_WARNING "ESFQ: Unknown hash method. Falling back to classic.\n");
+	}
+	return esfq_jhash_3words(q, info.dst, info.src, info.proto);
+}
+
+static inline void esfq_link(struct esfq_sched_data *q, esfq_index x)
+{
+	esfq_index p, n;
+	int d = q->qs[x].qlen + q->depth;
+
+	p = d;
+	n = q->dep[d].next;
+	q->dep[x].next = n;
+	q->dep[x].prev = p;
+	q->dep[p].next = q->dep[n].prev = x;
+}
+
+static inline void esfq_dec(struct esfq_sched_data *q, esfq_index x)
+{
+	esfq_index p, n;
+
+	n = q->dep[x].next;
+	p = q->dep[x].prev;
+	q->dep[p].next = n;
+	q->dep[n].prev = p;
+
+	if (n == p && q->max_depth == q->qs[x].qlen + 1)
+		q->max_depth--;
+
+	esfq_link(q, x);
+}
+
+static inline void esfq_inc(struct esfq_sched_data *q, esfq_index x)
+{
+	esfq_index p, n;
+	int d;
+
+	n = q->dep[x].next;
+	p = q->dep[x].prev;
+	q->dep[p].next = n;
+	q->dep[n].prev = p;
+	d = q->qs[x].qlen;
+	if (q->max_depth < d)
+		q->max_depth = d;
+
+	esfq_link(q, x);
+}
+
+static unsigned int esfq_drop(struct Qdisc *sch)
+{
+	struct esfq_sched_data *q = qdisc_priv(sch);
+	esfq_index d = q->max_depth;
+	struct sk_buff *skb;
+	unsigned int len;
+
+	/* Queue is full! Find the longest slot and
+	   drop a packet from it */
+
+	if (d > 1) {
+		esfq_index x = q->dep[d+q->depth].next;
+		skb = q->qs[x].prev;
+		len = skb->len;
+		__skb_unlink(skb, &q->qs[x]);
+		kfree_skb(skb);
+		esfq_dec(q, x);
+		sch->q.qlen--;
+		sch->qstats.drops++;
+		sch->qstats.backlog -= len;
+		return len;
+	}
+
+	if (d == 1) {
+		/* It is difficult to believe, but ALL THE SLOTS HAVE LENGTH 1. */
+		d = q->next[q->tail];
+		q->next[q->tail] = q->next[d];
+		q->allot[q->next[d]] += q->quantum;
+		skb = q->qs[d].prev;
+		len = skb->len;
+		__skb_unlink(skb, &q->qs[d]);
+		kfree_skb(skb);
+		esfq_dec(q, d);
+		sch->q.qlen--;
+		q->ht[q->hash[d]] = q->depth;
+		sch->qstats.drops++;
+		sch->qstats.backlog -= len;
+		return len;
+	}
+
+	return 0;
+}
+
+static void esfq_q_enqueue(struct sk_buff *skb, struct esfq_sched_data *q, unsigned int end)
+{
+	unsigned hash = esfq_hash(q, skb);
+	unsigned depth = q->depth;
+	esfq_index x;
+
+	x = q->ht[hash];
+	if (x == depth) {
+		q->ht[hash] = x = q->dep[depth].next;
+		q->hash[x] = hash;
+	}
+
+	if (end == ESFQ_TAIL)
+		__skb_queue_tail(&q->qs[x], skb);
+	else
+		__skb_queue_head(&q->qs[x], skb);
+
+	esfq_inc(q, x);
+	if (q->qs[x].qlen == 1) {		/* The flow is new */
+		if (q->tail == depth) {	/* It is the first flow */
+			q->tail = x;
+			q->next[x] = x;
+			q->allot[x] = q->quantum;
+		} else {
+			q->next[x] = q->next[q->tail];
+			q->next[q->tail] = x;
+			q->tail = x;
+		}
+	}
+}
+
+static int esfq_enqueue(struct sk_buff *skb, struct Qdisc* sch)
+{
+	struct esfq_sched_data *q = qdisc_priv(sch);
+	esfq_q_enqueue(skb, q, ESFQ_TAIL);
+	sch->qstats.backlog += skb->len;
+	if (++sch->q.qlen < q->limit-1) {
+		sch->bstats.bytes += skb->len;
+		sch->bstats.packets++;
+		return 0;
+	}
+
+	sch->qstats.drops++;
+	esfq_drop(sch);
+	return NET_XMIT_CN;
+}
+
+static struct sk_buff *esfq_peek(struct Qdisc* sch)
+{
+	struct esfq_sched_data *q = qdisc_priv(sch);
+	esfq_index a;
+
+	/* No active slots */
+	if (q->tail == q->depth)
+		return NULL;
+
+	a = q->next[q->tail];
+	return skb_peek(&q->qs[a]);
+}
+
+static struct sk_buff *esfq_q_dequeue(struct esfq_sched_data *q)
+{
+	struct sk_buff *skb;
+	unsigned depth = q->depth;
+	esfq_index a, old_a;
+
+	/* No active slots */
+	if (q->tail == depth)
+		return NULL;
+
+	a = old_a = q->next[q->tail];
+
+	/* Grab packet */
+	skb = __skb_dequeue(&q->qs[a]);
+	esfq_dec(q, a);
+
+	/* Is the slot empty? */
+	if (q->qs[a].qlen == 0) {
+		q->ht[q->hash[a]] = depth;
+		a = q->next[a];
+		if (a == old_a) {
+			q->tail = depth;
+			return skb;
+		}
+		q->next[q->tail] = a;
+		q->allot[a] += q->quantum;
+	} else if ((q->allot[a] -= skb->len) <= 0) {
+		q->tail = a;
+		a = q->next[a];
+		q->allot[a] += q->quantum;
+	}
+
+	return skb;
+}
+
+static struct sk_buff *esfq_dequeue(struct Qdisc* sch)
+{
+	struct esfq_sched_data *q = qdisc_priv(sch);
+	struct sk_buff *skb;
+
+	skb = esfq_q_dequeue(q);
+	if (skb == NULL)
+		return NULL;
+	sch->q.qlen--;
+	sch->qstats.backlog -= skb->len;
+	return skb;
+}
+
+static void esfq_q_destroy(struct esfq_sched_data *q)
+{
+	del_timer(&q->perturb_timer);
+	if(q->ht)
+		kfree(q->ht);
+	if(q->dep)
+		kfree(q->dep);
+	if(q->next)
+		kfree(q->next);
+	if(q->allot)
+		kfree(q->allot);
+	if(q->hash)
+		kfree(q->hash);
+	if(q->qs)
+		kfree(q->qs);
+}
+
+static void esfq_destroy(struct Qdisc *sch)
+{
+	struct esfq_sched_data *q = qdisc_priv(sch);
+	esfq_q_destroy(q);
+}
+
+
+static void esfq_reset(struct Qdisc* sch)
+{
+	struct sk_buff *skb;
+
+	while ((skb = esfq_dequeue(sch)) != NULL)
+		kfree_skb(skb);
+}
+
+static void esfq_perturbation(unsigned long arg)
+{
+	struct Qdisc *sch = (struct Qdisc*)arg;
+	struct esfq_sched_data *q = qdisc_priv(sch);
+
+	q->perturbation = net_random()&0x1F;
+
+	if (q->perturb_period) {
+		q->perturb_timer.expires = jiffies + q->perturb_period;
+		add_timer(&q->perturb_timer);
+	}
+}
+
+static unsigned int esfq_check_hash(unsigned int kind)
+{
+	switch (kind) {
+	case TCA_SFQ_HASH_CTORIGDST:
+	case TCA_SFQ_HASH_CTORIGSRC:
+	case TCA_SFQ_HASH_CTREPLDST:
+	case TCA_SFQ_HASH_CTREPLSRC:
+	case TCA_SFQ_HASH_CTNATCHG:
+#ifndef CONFIG_NET_SCH_ESFQ_NFCT
+	{
+		if (net_ratelimit())
+			printk(KERN_WARNING "ESFQ: Conntrack hash types disabled in kernel config. Falling back to classic.\n");
+		return TCA_SFQ_HASH_CLASSIC;
+	}
+#endif
+	case TCA_SFQ_HASH_CLASSIC:
+	case TCA_SFQ_HASH_DST:
+	case TCA_SFQ_HASH_SRC:
+	case TCA_SFQ_HASH_FWMARK:
+		return kind;
+	default:
+	{
+		if (net_ratelimit())
+			printk(KERN_WARNING "ESFQ: Unknown hash type. Falling back to classic.\n");
+		return TCA_SFQ_HASH_CLASSIC;
+	}
+	}
+}
+
+static int esfq_q_init(struct esfq_sched_data *q, struct nlattr *opt)
+{
+	struct tc_esfq_qopt *ctl = nla_data(opt);
+	esfq_index p = ~0U/2;
+	int i;
+
+	if (opt && opt->nla_len < nla_attr_size(sizeof(*ctl)))
+		return -EINVAL;
+
+	q->perturbation = 0;
+	q->hash_kind = TCA_SFQ_HASH_CLASSIC;
+	q->max_depth = 0;
+	if (opt == NULL) {
+		q->perturb_period = 0;
+		q->hash_divisor = 1024;
+		q->tail = q->limit = q->depth = 128;
+
+	} else {
+		struct tc_esfq_qopt *ctl = nla_data(opt);
+		if (ctl->quantum)
+			q->quantum = ctl->quantum;
+		q->perturb_period = ctl->perturb_period*HZ;
+		q->hash_divisor = ctl->divisor ? : 1024;
+		q->tail = q->limit = q->depth = ctl->flows ? : 128;
+
+		if ( q->depth > p - 1 )
+			return -EINVAL;
+
+		if (ctl->limit)
+			q->limit = min_t(u32, ctl->limit, q->depth);
+
+		if (ctl->hash_kind) {
+			q->hash_kind = esfq_check_hash(ctl->hash_kind);
+		}
+	}
+
+	q->ht = kmalloc(q->hash_divisor*sizeof(esfq_index), GFP_KERNEL);
+	if (!q->ht)
+		goto err_case;
+	q->dep = kmalloc((1+q->depth*2)*sizeof(struct esfq_head), GFP_KERNEL);
+	if (!q->dep)
+		goto err_case;
+	q->next = kmalloc(q->depth*sizeof(esfq_index), GFP_KERNEL);
+	if (!q->next)
+		goto err_case;
+	q->allot = kmalloc(q->depth*sizeof(short), GFP_KERNEL);
+	if (!q->allot)
+		goto err_case;
+	q->hash = kmalloc(q->depth*sizeof(unsigned short), GFP_KERNEL);
+	if (!q->hash)
+		goto err_case;
+	q->qs = kmalloc(q->depth*sizeof(struct sk_buff_head), GFP_KERNEL);
+	if (!q->qs)
+		goto err_case;
+
+	for (i=0; i< q->hash_divisor; i++)
+		q->ht[i] = q->depth;
+	for (i=0; i<q->depth; i++) {
+		skb_queue_head_init(&q->qs[i]);
+		q->dep[i+q->depth].next = i+q->depth;
+		q->dep[i+q->depth].prev = i+q->depth;
+	}
+
+	for (i=0; i<q->depth; i++)
+		esfq_link(q, i);
+	return 0;
+err_case:
+	esfq_q_destroy(q);
+	return -ENOBUFS;
+}
+
+static int esfq_init(struct Qdisc *sch, struct nlattr *opt)
+{
+	struct esfq_sched_data *q = qdisc_priv(sch);
+	int err;
+
+	q->quantum = psched_mtu(qdisc_dev(sch)); /* default */
+	if ((err = esfq_q_init(q, opt)))
+		return err;
+
+	init_timer(&q->perturb_timer);
+	q->perturb_timer.data = (unsigned long)sch;
+	q->perturb_timer.function = esfq_perturbation;
+	if (q->perturb_period) {
+		q->perturb_timer.expires = jiffies + q->perturb_period;
+		add_timer(&q->perturb_timer);
+	}
+
+	return 0;
+}
+
+static int esfq_change(struct Qdisc *sch, struct nlattr *opt)
+{
+	struct esfq_sched_data *q = qdisc_priv(sch);
+	struct esfq_sched_data new;
+	struct sk_buff *skb;
+	int err;
+
+	/* set up new queue */
+	memset(&new, 0, sizeof(struct esfq_sched_data));
+	new.quantum = psched_mtu(qdisc_dev(sch)); /* default */
+	if ((err = esfq_q_init(&new, opt)))
+		return err;
+
+	/* copy all packets from the old queue to the new queue */
+	sch_tree_lock(sch);
+	while ((skb = esfq_q_dequeue(q)) != NULL)
+		esfq_q_enqueue(skb, &new, ESFQ_TAIL);
+
+	/* clean up the old queue */
+	esfq_q_destroy(q);
+
+	/* copy elements of the new queue into the old queue */
+	q->perturb_period = new.perturb_period;
+	q->quantum        = new.quantum;
+	q->limit          = new.limit;
+	q->depth          = new.depth;
+	q->hash_divisor   = new.hash_divisor;
+	q->hash_kind      = new.hash_kind;
+	q->tail           = new.tail;
+	q->max_depth      = new.max_depth;
+	q->ht    = new.ht;
+	q->dep   = new.dep;
+	q->next  = new.next;
+	q->allot = new.allot;
+	q->hash  = new.hash;
+	q->qs    = new.qs;
+
+	/* finish up */
+	if (q->perturb_period) {
+		q->perturb_timer.expires = jiffies + q->perturb_period;
+		add_timer(&q->perturb_timer);
+	} else {
+		q->perturbation = 0;
+	}
+	sch_tree_unlock(sch);
+	return 0;
+}
+
+static int esfq_dump(struct Qdisc *sch, struct sk_buff *skb)
+{
+	struct esfq_sched_data *q = qdisc_priv(sch);
+	unsigned char *b = skb_tail_pointer(skb);
+	struct tc_esfq_qopt opt;
+
+	opt.quantum = q->quantum;
+	opt.perturb_period = q->perturb_period/HZ;
+
+	opt.limit = q->limit;
+	opt.divisor = q->hash_divisor;
+	opt.flows = q->depth;
+	opt.hash_kind = q->hash_kind;
+
+	NLA_PUT(skb, TCA_OPTIONS, sizeof(opt), &opt);
+
+	return skb->len;
+
+nla_put_failure:
+	nlmsg_trim(skb, b);
+	return -1;
+}
+
+static struct Qdisc_ops esfq_qdisc_ops =
+{
+	.next		=	NULL,
+	.cl_ops		=	NULL,
+	.id		=	"esfq",
+	.priv_size	=	sizeof(struct esfq_sched_data),
+	.enqueue	=	esfq_enqueue,
+	.dequeue	=	esfq_dequeue,
+	.peek		=	esfq_peek,
+	.drop		=	esfq_drop,
+	.init		=	esfq_init,
+	.reset		=	esfq_reset,
+	.destroy	=	esfq_destroy,
+	.change		=	esfq_change,
+	.dump		=	esfq_dump,
+	.owner		=	THIS_MODULE,
+};
+
+static int __init esfq_module_init(void)
+{
+	return register_qdisc(&esfq_qdisc_ops);
+}
+static void __exit esfq_module_exit(void)
+{
+	unregister_qdisc(&esfq_qdisc_ops);
+}
+module_init(esfq_module_init)
+module_exit(esfq_module_exit)
+MODULE_LICENSE("GPL");
diff -Nru linux-2.6.30.5/net/sched/sch_generic.c linux-2.6.30.5-wrt/net/sched/sch_generic.c
--- linux-2.6.30.5/net/sched/sch_generic.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/net/sched/sch_generic.c	2009-09-06 18:43:48.442687784 +0200
@@ -371,16 +371,50 @@
 
 #define PFIFO_FAST_BANDS 3
 
+struct pfifo_fast_sched_data {
+	struct tcf_proto *filter_list;
+	struct sk_buff_head list[PFIFO_FAST_BANDS];
+};
+
 static inline struct sk_buff_head *prio2list(struct sk_buff *skb,
 					     struct Qdisc *qdisc)
 {
-	struct sk_buff_head *list = qdisc_priv(qdisc);
+	struct pfifo_fast_sched_data *q = qdisc_priv(qdisc);
+	struct sk_buff_head *list = q->list;
 	return list + prio2band[skb->priority & TC_PRIO_MAX];
 }
 
+static int pfifo_fast_filter(struct sk_buff *skb, struct Qdisc* qdisc)
+{
+#ifdef CONFIG_NET_CLS_ACT
+	struct pfifo_fast_sched_data *q = qdisc_priv(qdisc);
+	int result = 0, ret = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;
+	struct tcf_result res;
+
+	if (q->filter_list != NULL)
+		result = tc_classify(skb, q->filter_list, &res);
+	if (result >= 0) {
+		switch (result) {
+		case TC_ACT_STOLEN:
+		case TC_ACT_QUEUED:
+			ret = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;
+		case TC_ACT_SHOT:
+			kfree_skb(skb);
+			return ret;
+		}
+	}
+#endif
+	return 0;
+}
+
 static int pfifo_fast_enqueue(struct sk_buff *skb, struct Qdisc* qdisc)
 {
 	struct sk_buff_head *list = prio2list(skb, qdisc);
+	int ret;
+
+	ret = pfifo_fast_filter(skb, qdisc);
+	if (ret)
+		return ret;
 
 	if (skb_queue_len(list) < qdisc_dev(qdisc)->tx_queue_len) {
 		qdisc->q.qlen++;
@@ -392,8 +426,9 @@
 
 static struct sk_buff *pfifo_fast_dequeue(struct Qdisc* qdisc)
 {
+	struct pfifo_fast_sched_data *q = qdisc_priv(qdisc);
+	struct sk_buff_head *list = q->list;
 	int prio;
-	struct sk_buff_head *list = qdisc_priv(qdisc);
 
 	for (prio = 0; prio < PFIFO_FAST_BANDS; prio++) {
 		if (!skb_queue_empty(list + prio)) {
@@ -420,8 +455,9 @@
 
 static void pfifo_fast_reset(struct Qdisc* qdisc)
 {
+	struct pfifo_fast_sched_data *q = qdisc_priv(qdisc);
+	struct sk_buff_head *list = q->list;
 	int prio;
-	struct sk_buff_head *list = qdisc_priv(qdisc);
 
 	for (prio = 0; prio < PFIFO_FAST_BANDS; prio++)
 		__qdisc_reset_queue(qdisc, list + prio);
@@ -444,8 +480,9 @@
 
 static int pfifo_fast_init(struct Qdisc *qdisc, struct nlattr *opt)
 {
+	struct pfifo_fast_sched_data *q = qdisc_priv(qdisc);
+	struct sk_buff_head *list = q->list;
 	int prio;
-	struct sk_buff_head *list = qdisc_priv(qdisc);
 
 	for (prio = 0; prio < PFIFO_FAST_BANDS; prio++)
 		skb_queue_head_init(list + prio);
@@ -453,9 +490,36 @@
 	return 0;
 }
 
+static int pfifo_fast_change_class(struct Qdisc *qdisc, u32 classid, u32 parentid,
+			    struct nlattr **tca, unsigned long *arg)
+{
+	return -EOPNOTSUPP;
+}
+
+static unsigned long pfifo_fast_get(struct Qdisc *qdisc, u32 classid)
+{
+	return 0;
+}
+
+static struct tcf_proto **pfifo_fast_find_tcf(struct Qdisc *qdisc, unsigned long cl)
+{
+	struct pfifo_fast_sched_data *q = qdisc_priv(qdisc);
+
+	if (cl)
+		return NULL;
+	return &q->filter_list;
+}
+
+static const struct Qdisc_class_ops pfifo_fast_class_ops = {
+	.get		=	pfifo_fast_get,
+	.change		=	pfifo_fast_change_class,
+	.tcf_chain	=	pfifo_fast_find_tcf,
+};
+
 static struct Qdisc_ops pfifo_fast_ops __read_mostly = {
 	.id		=	"pfifo_fast",
-	.priv_size	=	PFIFO_FAST_BANDS * sizeof(struct sk_buff_head),
+	.cl_ops		=	&pfifo_fast_class_ops,
+	.priv_size	=	sizeof(struct pfifo_fast_sched_data),
 	.enqueue	=	pfifo_fast_enqueue,
 	.dequeue	=	pfifo_fast_dequeue,
 	.peek		=	pfifo_fast_peek,
@@ -735,3 +799,18 @@
 	shutdown_scheduler_queue(dev, &dev->rx_queue, &noop_qdisc);
 	WARN_ON(timer_pending(&dev->watchdog_timer));
 }
+
+#ifdef CONFIG_NET_SCHED
+static int __init sch_generic_init(void)
+{
+	return register_qdisc(&pfifo_fast_ops);
+}
+
+static void __exit sch_generic_exit(void)
+{
+	unregister_qdisc(&pfifo_fast_ops);
+}
+
+module_init(sch_generic_init)
+module_exit(sch_generic_exit)
+#endif
diff -Nru linux-2.6.30.5/net/wireless/Kconfig linux-2.6.30.5-wrt/net/wireless/Kconfig
--- linux-2.6.30.5/net/wireless/Kconfig	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/net/wireless/Kconfig	2009-09-06 18:44:12.038667117 +0200
@@ -63,13 +63,13 @@
 	  you want this built into your kernel.
 
 config LIB80211_CRYPT_WEP
-	tristate
+	tristate "LIB80211_CRYPT_WEP"
 
 config LIB80211_CRYPT_CCMP
-	tristate
+	tristate "LIB80211_CRYPT_CCMP"
 
 config LIB80211_CRYPT_TKIP
-	tristate
+	tristate "LIB80211_CRYPT_TKIP"
 
 config LIB80211_DEBUG
 	bool "lib80211 debugging messages"
diff -Nru linux-2.6.30.5/scripts/Makefile.lib linux-2.6.30.5-wrt/scripts/Makefile.lib
--- linux-2.6.30.5/scripts/Makefile.lib	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/scripts/Makefile.lib	2009-09-06 18:44:12.075167378 +0200
@@ -204,4 +204,4 @@
 # ---------------------------------------------------------------------------
 
 quiet_cmd_lzma = LZMA    $@
-cmd_lzma = (lzma -9 -c $< && $(size_append) $<) >$@ || (rm -f $@ ; false)
+cmd_lzma = lzma e $< $@ -lc1 -lp2 -pb2 -eos
diff -Nru linux-2.6.30.5/scripts/gen_initramfs_list.sh linux-2.6.30.5-wrt/scripts/gen_initramfs_list.sh
--- linux-2.6.30.5/scripts/gen_initramfs_list.sh	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/scripts/gen_initramfs_list.sh	2009-09-06 18:44:12.075167378 +0200
@@ -225,7 +225,7 @@
 output="/dev/stdout"
 output_file=""
 is_cpio_compressed=
-compr="gzip -9 -f"
+compr="gzip -9 -f -"
 
 arg="$1"
 case "$arg" in
@@ -239,9 +239,9 @@
 		output_file="$1"
 		cpio_list="$(mktemp ${TMPDIR:-/tmp}/cpiolist.XXXXXX)"
 		output=${cpio_list}
-		echo "$output_file" | grep -q "\.gz$" && compr="gzip -9 -f"
-		echo "$output_file" | grep -q "\.bz2$" && compr="bzip2 -9 -f"
-		echo "$output_file" | grep -q "\.lzma$" && compr="lzma -9 -f"
+		echo "$output_file" | grep -q "\.gz$" && compr="gzip -9 -f -"
+		echo "$output_file" | grep -q "\.bz2$" && compr="bzip2 -9 -f -"
+		echo "$output_file" | grep -q "\.lzma$" && compr="lzma e -d20 -lc1 -lp2 -pb2 -si -so"
 		echo "$output_file" | grep -q "\.cpio$" && compr="cat"
 		shift
 		;;
@@ -292,7 +292,7 @@
 	if [ "${is_cpio_compressed}" = "compressed" ]; then
 		cat ${cpio_tfile} > ${output_file}
 	else
-		(cat ${cpio_tfile} | ${compr}  - > ${output_file}) \
+		(cat ${cpio_tfile} | ${compr} > ${output_file}) \
 		|| (rm -f ${output_file} ; false)
 	fi
 	[ -z ${cpio_file} ] && rm ${cpio_tfile}
diff -Nru linux-2.6.30.5/scripts/genksyms/parse.c_shipped linux-2.6.30.5-wrt/scripts/genksyms/parse.c_shipped
--- linux-2.6.30.5/scripts/genksyms/parse.c_shipped	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/scripts/genksyms/parse.c_shipped	2009-09-06 18:44:06.795167127 +0200
@@ -160,7 +160,9 @@
 
 
 #include <assert.h>
+#ifndef __APPLE__
 #include <malloc.h>
+#endif
 #include "genksyms.h"
 
 static int is_typedef;
diff -Nru linux-2.6.30.5/scripts/genksyms/parse.y linux-2.6.30.5-wrt/scripts/genksyms/parse.y
--- linux-2.6.30.5/scripts/genksyms/parse.y	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/scripts/genksyms/parse.y	2009-09-06 18:44:06.795167127 +0200
@@ -24,7 +24,9 @@
 %{
 
 #include <assert.h>
+#ifndef __APPLE__
 #include <malloc.h>
+#endif
 #include "genksyms.h"
 
 static int is_typedef;
diff -Nru linux-2.6.30.5/scripts/kallsyms.c linux-2.6.30.5-wrt/scripts/kallsyms.c
--- linux-2.6.30.5/scripts/kallsyms.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/scripts/kallsyms.c	2009-09-06 18:44:06.795167127 +0200
@@ -22,6 +22,35 @@
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
+#ifdef __APPLE__
+/* Darwin has no memmem implementation, this one is ripped of the uClibc-0.9.28 source */
+void *memmem (const void *haystack, size_t haystack_len,
+                          const void *needle,  size_t needle_len)
+{
+  const char *begin;
+  const char *const last_possible
+    = (const char *) haystack + haystack_len - needle_len;
+
+  if (needle_len == 0)
+    /* The first occurrence of the empty string is deemed to occur at
+       the beginning of the string.  */
+    return (void *) haystack;
+
+  /* Sanity check, otherwise the loop might search through the whole
+     memory.  */
+  if (__builtin_expect (haystack_len < needle_len, 0))
+    return NULL;
+
+  for (begin = (const char *) haystack; begin <= last_possible; ++begin)
+    if (begin[0] == ((const char *) needle)[0] &&
+        !memcmp ((const void *) &begin[1],
+                 (const void *) ((const char *) needle + 1),
+                 needle_len - 1))
+      return (void *) begin;
+
+  return NULL;
+}
+#endif
 
 #define KSYM_NAME_LEN		128
 
diff -Nru linux-2.6.30.5/scripts/kconfig/Makefile linux-2.6.30.5-wrt/scripts/kconfig/Makefile
--- linux-2.6.30.5/scripts/kconfig/Makefile	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/scripts/kconfig/Makefile	2009-09-06 18:44:06.795167127 +0200
@@ -97,6 +97,9 @@
 # we really need to do so. (Do not call gcc as part of make mrproper)
 HOST_EXTRACFLAGS = $(shell $(CONFIG_SHELL) $(check-lxdialog) -ccflags)
 HOST_LOADLIBES   = $(shell $(CONFIG_SHELL) $(check-lxdialog) -ldflags $(HOSTCC))
+ifeq ($(shell uname -s),Darwin)
+HOST_LOADLIBES  += -lncurses
+endif
 
 HOST_EXTRACFLAGS += -DLOCALE
 
diff -Nru linux-2.6.30.5/scripts/mod/mk_elfconfig.c linux-2.6.30.5-wrt/scripts/mod/mk_elfconfig.c
--- linux-2.6.30.5/scripts/mod/mk_elfconfig.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/scripts/mod/mk_elfconfig.c	2009-09-06 18:44:06.795167127 +0200
@@ -1,7 +1,11 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#ifndef __APPLE__
 #include <elf.h>
+#else
+#include "../../../../../tools/sstrip/include/elf.h"
+#endif
 
 int
 main(int argc, char **argv)
diff -Nru linux-2.6.30.5/scripts/mod/modpost.h linux-2.6.30.5-wrt/scripts/mod/modpost.h
--- linux-2.6.30.5/scripts/mod/modpost.h	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/scripts/mod/modpost.h	2009-09-06 18:44:06.795167127 +0200
@@ -7,7 +7,11 @@
 #include <sys/mman.h>
 #include <fcntl.h>
 #include <unistd.h>
+#if !(defined(__APPLE__) || defined(__CYGWIN__))
 #include <elf.h>
+#else
+#include "../../../../../tools/sstrip/include/elf.h"
+#endif
 
 #include "elfconfig.h"
 
diff -Nru linux-2.6.30.5/sound/core/Kconfig linux-2.6.30.5-wrt/sound/core/Kconfig
--- linux-2.6.30.5/sound/core/Kconfig	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/sound/core/Kconfig	2009-09-06 18:43:48.434699261 +0200
@@ -7,7 +7,7 @@
 	select SND_TIMER
 
 config SND_HWDEP
-	tristate
+	tristate "Sound hardware support"
 
 config SND_RAWMIDI
 	tristate
diff -Nru linux-2.6.30.5/sound/soc/soc-jack.c linux-2.6.30.5-wrt/sound/soc/soc-jack.c
--- linux-2.6.30.5/sound/soc/soc-jack.c	2009-08-16 23:19:38.000000000 +0200
+++ linux-2.6.30.5-wrt/sound/soc/soc-jack.c	2009-09-06 18:44:06.791167574 +0200
@@ -220,6 +220,9 @@
 		if (ret)
 			goto err;
 
+		INIT_WORK(&gpios[i].work, gpio_work);
+		gpios[i].jack = jack;
+
 		ret = request_irq(gpio_to_irq(gpios[i].gpio),
 				gpio_handler,
 				IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
@@ -227,9 +230,6 @@
 				&gpios[i]);
 		if (ret)
 			goto err;
-
-		INIT_WORK(&gpios[i].work, gpio_work);
-		gpios[i].jack = jack;
 	}
 
 	return 0;
